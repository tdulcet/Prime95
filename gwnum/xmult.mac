; Copyright 2001-2005 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros take the basic FFT building blocks and build even
; larger building blocks.
;

; *************** macros to expand 4 types of fft macros ******************

xsave_registers MACRO
	push	rbp
	push	rbx
	push	rdi
	push	rsi
	IFDEF X86_64
	sub	rsp, 80
	_movsd	[rsp+72], xmm6
	_movsd	[rsp+64], xmm7
	_movsd	[rsp+56], xmm8
	_movsd	[rsp+48], xmm9
	_movsd	[rsp+40], xmm10
	_movsd	[rsp+32], xmm11
	_movsd	[rsp+24], xmm12
	_movsd	[rsp+16], xmm13
	_movsd	[rsp+8], xmm14
	_movsd	[rsp], xmm15
	ENDIF
	ENDM

xrestore_registers MACRO
	IFDEF X86_64
	_movsd	xmm15, [rsp]
	_movsd	xmm14, [rsp+8]
	_movsd	xmm13, [rsp+16]
	_movsd	xmm12, [rsp+24]
	_movsd	xmm11, [rsp+32]
	_movsd	xmm10, [rsp+40]
	_movsd	xmm9, [rsp+48]
	_movsd	xmm8, [rsp+56]
	_movsd	xmm7, [rsp+64]
	_movsd	xmm6, [rsp+72]
	add	rsp, 80
	ENDIF
	pop	rsi			;; Pop values and return
	pop	rdi
	pop	rbx
	pop	rbp
	ENDM

;;
;; Generate the 4 types of FFTs for the given run length.
;; The 4 types are:
;;	1) forward FFT,
;;	2) square (forward FFT, multiply, inverse FFT)
;;	3) multiply (forward FFT src1, multiply by src2, inverse FFT)
;;	4) multiply (multiply src1 by src2, inverse FFT)
;;

xfft	MACRO fft_length
	type1	&fft_length, _1
	type2	&fft_length, _2
	type3	&fft_length, _3
	type4	&fft_length, _4
	purge	xfft&fft_length
	ENDM

xfftclm	MACRO fft_length, clm
	type1	&fft_length, _1, clm, %(xpass2_levels)
	type2	&fft_length, _2, clm, %(xpass2_levels)
	type3	&fft_length, _3, clm, %(xpass2_levels)
	type4	&fft_length, _4, clm, %(xpass2_levels)
	ENDM

;;
;; Perform an FFT in preparation for a later multiply
;; Do the forward FFT
;;

type1	MACRO fft_length, suffix, clm, levels
PUBLICP	xfft&fft_length&clm&levels&suffix
LABELP	xfft&fft_length&clm&levels&suffix
	xsave_registers
	mov	rsi, _DESTARG
	mov	rbx, _SRCARG
	sub	rbx, rsi
	IF EXPANDING GE 2
	mov	ffttype, 1
	JMPP	xfft2a&fft_length&clm&levels
	ELSE
	xfft&fft_length 1
	ENDIF
	ENDM

;;
;; Square a number mod 2**p-1
;; Do the forward FFT, squaring, and inverse FFT
;;

type2	MACRO fft_length, suffix, clm, levels
PUBLICP	xfft&fft_length&clm&levels&suffix
LABELP	xfft&fft_length&clm&levels&suffix
	xsave_registers
	mov	rsi, _DESTARG
	sub	rbx, rbx
	IF EXPANDING GE 2
	mov	ffttype, 2
LABELP	xfft2a&fft_length&clm&levels
	IFB <clm>
	xfft&fft_length
	ELSE
	xscfft&fft_length clm
	ENDIF
	ELSE
	xfft&fft_length 2
	ENDIF
	ENDM

;;
;; Multiply two numbers mod 2**p-1.  One of the input numbers (SRCARG) must
;; have already been passed through gw_fft.
;; Do the forward FFT, multiply, and inverse FFT
;;

type3	MACRO fft_length, suffix, clm, levels
PUBLICP	xfft&fft_length&clm&levels&suffix
LABELP	xfft&fft_length&clm&levels&suffix
	xsave_registers
	mov	rsi, _DESTARG
	sub	rbx, rbx
	IF EXPANDING GE 2
	mov	ffttype, 3
	JMPP	xfft2a&fft_length&clm&levels
	ELSE
	xfft&fft_length 3
	ENDIF
	ENDM

;;
;; Multiply two numbers mod 2**p-1.  Both of the input numbers must
;; have already been passed through gw_fft.
;; Do the multiply and inverse FFT
;;

type4	MACRO fft_length, suffix, clm, levels
PUBLICP	xfft&fft_length&clm&levels&suffix
LABELP	xfft&fft_length&clm&levels&suffix
	xsave_registers
	mov	rsi, _DESTARG
	mov	rbx, _SRC2ARG
	sub	rbx, rsi
	IF EXPANDING GE 2
	mov	ffttype, 4
	JMPP	xfft2a&fft_length&clm&levels
	ELSE
	xfft&fft_length 4
	ENDIF
	ENDM

; Return from a type 1 FFT - return to caller

xfft_1_ret MACRO
	xrestore_registers
	ret
	ENDM

; Return from a type 2,3, or 4 FFT - jump to the common normalization code
; used in one-pass FFTs only.

xfft_3_ret MACRO
	mov	rax, _NORMRTN
	jmp	rax
	ENDM

;;
;; Common definitions in SSE2 FFTs
;;

XMM_SCD	= 96			;; Sizeof an SSE2 sin/cos table entry
XMM_PMD = 128			;; Sizeof an entry in premultiplier table

;; 
;; Number of pad bytes between two pass 2 data blocks.  For best distribution
;; of data in the L2 cache during pass 1, this should be an odd multiple
;; of the amount of data read in during a pass 1 iteration (clm*128 if not
;; prefetching, 2*clm*128 if we are prefetching).  This odd multiple must also
;; take into account the 128 pad bytes already added every 8KB in the block.
;; We also want to avoid gaps that are a multiple of 2KB as that hurts the
;; g4cl macros on a P4.
;;
;; A summary follows below:
;;
;; pass2 levels 8:
;;		read		skip
;; clm1:	256		128+128
;; clm4:	1K		128+896
;;
;; pass2 levels 10:
;;		read		skip
;; clm0:	128		512+/-128
;; clm1:	256		512+256
;; clm2:	512		512+0		0 is perfect!
;; clm4:	1K		512+512		512 IS perfect!
;; clm8:	2K		512+512		decent solution
;;
;; pass2 levels 11:
;;		read		skip
;; clm0:	128		1K+/-128	perfect
;; clm1:	256		1K+256		perfect
;; clm2:	512		1k+512		perfect
;; clm4:	1K		1K+0		0 IS perfect!
;; clm8:	2K		1k+0		decent solution
;;
;; pass2 levels 12:
;;		read		skip
;; clm0:	128		2K+/-128	perfect!
;; clm1:	256		2K+256		perfect!
;; clm2:	512		2k+512		perfect!
;; clm4:	1K		2K+1K		perfect!
;; clm8:	2K		2k+1k		decent solution
;;
;; pass2 levels 13:
;;		read		skip
;; clm0:	128		4K+/-128	perfect!
;; clm1:	256		4K+256		PERFECT!
;; clm2:	512		4k+512		perfect
;; clm4:	1K		4K+1024		perfect
;; clm8:	2K		4k+1024		decent solution

GAP2_8_1	= 128
GAP2_8_4	= 896
GAP2_10_0	= -128
GAP2_10_1	= 256
GAP2_10_2	= 0
GAP2_10_4	= 512
GAP2_10_8	= 512
GAP2_11_0	= -128
GAP2_11_1	= 256
GAP2_11_2	= 512
GAP2_11_4	= 0
GAP2_11_8	= 0
GAP2_12_0	= -128
GAP2_12_1	= 256
GAP2_12_2	= 512
GAP2_12_4	= 1024
GAP2_12_8	= 1024
GAP2_13_0	= -128
GAP2_13_1	= 256
GAP2_13_2	= 512
GAP2_13_4	= 1024
GAP2_13_8	= 1024

;;
;; Cacheline multiples.  In SSE2 first pass, how many cache lines should
;; be processed in each loop.  Note that the clm value must be at least 2.
;;

clm = 4				;; Used for all FFTs <= 512K

;;
;; Common utility macros used in one and two pass SSE2 FFTs
;;

multwo	MACRO	r
	mulpd	r, XMM_TWO
	ENDM

mulhalf	MACRO	r
	mulpd	r, XMM_HALF
	ENDM

xtouch	MACRO	addr
	IF PREFETCHING NE 0
	cmp	rsp, addr
	ENDIF
	ENDM

; Macro to prefetch a line into the L2 cache

xprefetcht1 MACRO addr
	IF PREFETCHING NE 0
	IFDEF AMD
	prefetchw addr
	prefetchw addr[64]
	ELSE
	prefetcht1 addr
	ENDIF
	ENDIF
	ENDM

; Macro to prefetch a line into the L1 cache (AMD only)

xprefetch MACRO addr
	IFDEF AMD
	prefetch addr
	ENDIF
	ENDM
xprefetchw MACRO addr
	IFDEF AMD
	prefetchw addr
	ENDIF
	ENDM

