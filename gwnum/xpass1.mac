; Copyright 2001-2005 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros do the first pass of 2 pass FFTs using SSE2 instructions.
;

; ********************************************************
; ********************************************************
; ******************  PASS 1 MACROS  *********************
; ********************************************************
; ********************************************************

;; When doing zero-padded FFTs, the 7 words around the halfway point must
;; be copied for later processing.  This macro does that before a typical
;; forward FFT.

xcopy_7_words MACRO
	LOCAL	nozpad
	cmp	_ZERO_PADDED_FFT, 0	;; Is this a zero-padded FFT?
	je	short nozpad		;; No, skip 7 word copy
	_movsd	xmm0, [rsi+rbx+32]	;; Copy 1st word above half-way point
	_movsd	[rsi-40], xmm0
	_movsd	xmm1, [rsi+rbx+96]	;; Copy 2nd word
	_movsd	[rsi-48], xmm1
	_movsd	xmm2, [rsi+rbx+160]	;; Copy 3rd word
	_movsd	[rsi-56], xmm2
	_movsd	xmm3, [rsi+rbx+224]	;; Copy 4th word
	_movsd	[rsi-64], xmm3
	mov	eax, _HIGH_WORD1_OFFSET	;; Copy 1st word below half-way
	add	rax, rsi
	_movsd	xmm0, [rax+rbx]
	_movsd	[rsi-72], xmm0
	mov	eax, _HIGH_WORD2_OFFSET	;; Copy 2nd word below
	add	rax, rsi
	_movsd	xmm1, [rax+rbx]
	_movsd	[rsi-80], xmm1
	mov	eax, _HIGH_WORD3_OFFSET	;; Copy 3rd word below
	add	rax, rsi
	_movsd	xmm2, [rax+rbx]
	_movsd	[rsi-88], xmm2
nozpad:
	ENDM

;; When POSTFFT is set, we must copy the 7 words at two different spots.
;; These two macros copy the four values above the half-way point after
;; carries have been propagated and copy the three words just below the
;; half-way point right after the last NORMRTN has been called.

xcopy_4_words MACRO
	LOCAL	nozpad
	cmp	_ZERO_PADDED_FFT, 0	;; Is this a zero-padded FFT?
	je	short nozpad		;; No, skip 4 word copy
	_movsd	xmm0, [rsi+32]		;; Copy 1st word above half-way point
	_movsd	[rsi-40], xmm0
	_movsd	xmm1, [rsi+96]		;; Copy 2nd word
	_movsd	[rsi-48], xmm1
	_movsd	xmm2, [rsi+160]		;; Copy 3rd word
	_movsd	[rsi-56], xmm2
	_movsd	xmm3, [rsi+224]		;; Copy 4th word
	_movsd	[rsi-64], xmm3
nozpad:
	ENDM

xcopy_3_words MACRO clm, scratch
	LOCAL	nozpad, iter2
	cmp	_ZERO_PADDED_FFT, 0	;; Is this a zero-padded FFT?
	je	short nozpad		;; No, skip 3 word copy

	IF clm GE 2
	cmp	edx, 65536+256		;; Only copy on last inverse FFT pass
	jne	short nozpad		;; Jump if delaying
	mov	rdi, _DESTARG		;; Load destination pointer
	IF scratch EQ 0
	mov	eax, _HIGH_WORD1_OFFSET	;; Copy 1st word below half-way
	_movsd	xmm0, [rdi+rax]
	_movsd	[rdi-72], xmm0
	mov	eax, _HIGH_WORD2_OFFSET	;; Copy 2nd word below
	_movsd	xmm1, [rdi+rax]
	_movsd	[rdi-80], xmm1
	mov	eax, _HIGH_WORD3_OFFSET	;; Copy 3rd word below
	_movsd	xmm2, [rdi+rax]
	_movsd	[rdi-88], xmm2
	ENDIF
	IF scratch EQ 1
	mov	rcx, scratch_area
	mov	eax, _HIGH_SCRATCH1_OFFSET;; Copy 1st word below half-way
	_movsd	xmm0, [rcx+rax]
	_movsd	[rdi-72], xmm0
	mov	eax, _HIGH_SCRATCH2_OFFSET;; Copy 2nd word
	_movsd	xmm1, [rcx+rax]
	_movsd	[rdi-80], xmm1
	mov	eax, _HIGH_SCRATCH3_OFFSET;; Copy 3rd word
	_movsd	xmm2, [rcx+rax]
	_movsd	[rdi-88], xmm2
	ENDIF
	ENDIF

	IF clm EQ 1
	cmp	edx, 65536+2*256	;; Copy on last 2 inverse FFT passes
	jg	short nozpad		;; Jump if delaying
	mov	rdi, _DESTARG		;; Load destination pointer
	IF scratch EQ 1
	mov	rcx, scratch_area
	ENDIF
	je	short iter2		;; Jump if doing second to last iter
	IF scratch EQ 0
	mov	eax, _HIGH_WORD1_OFFSET	;; Copy 1st word below half-way
	_movsd	xmm0, [rdi+rax]
	_movsd	[rdi-72], xmm0
	mov	eax, _HIGH_WORD2_OFFSET	;; Copy 2nd word
	_movsd	xmm1, [rdi+rax]
	_movsd	[rdi-80], xmm1
	jmp	short nozpad
iter2:	mov	eax, _HIGH_WORD3_OFFSET	;; Copy 3rd word
	_movsd	xmm2, [rdi+rax]
	_movsd	[rdi-88], xmm2
	ENDIF
	IF scratch EQ 1
	mov	rcx, scratch_area
	mov	eax, _HIGH_SCRATCH1_OFFSET;; Copy 1st word below half-way
	_movsd	xmm0, [rcx+rax]
	_movsd	[rdi-72], xmm0
	mov	eax, _HIGH_SCRATCH2_OFFSET;; Copy 2nd word
	_movsd	xmm1, [rcx+rax]
	_movsd	[rdi-80], xmm1
	jmp	short nozpad
iter2:	mov	eax, _HIGH_SCRATCH3_OFFSET;; Copy 3rd word
	_movsd	xmm2, [rcx+rax]
	_movsd	[rdi-88], xmm2
	ENDIF
	ENDIF
nozpad:
	ENDM

;;***********************************************************************
;; Pass 1 macros
;;
;; p2cl = number of 128-byte cache lines processed from a pass 2 block
;; clm = cache line multiplier (num cache lines processed each iteration)
;;***********************************************************************

; Note:  All memory layouts are for 64 byte L1 cache lines.  The high
; order XMM words are not shown (they are 1K higher than the low
; order XMM word.  Since the L2 cache reads 128 byte cache lines, two
; 64 byte cache lines are processed at a time.  The second 64 byte
; cache line contains a completely independent set of data.


;; Perform a 40K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels5pfa5 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1b, b2b, b3a, b3b, c0b, c1b, c2b, c3a, c3b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 4 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...

;; Do 1 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

c0b:	start_timer 18
c2b:	x1cl_half_eight_reals_unfft_2 rsi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

;; Do 4 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*2*blkdst-blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	20K	22K
;;	4K	12K	24K	32K
;;	6K
;;	...
;;	10K

;; Do 8 five_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 1 macros each processing 40 data values

	start_timer 19
	xfive_reals_unfft_preload	;; Preload consts for five real macros
c1b:	x5cl_five_reals_last_unfft rsi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1b
	lea	rsi, [rsi-2*clm*64]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	20K	22K
;;	4K	12K	24K	32K
;;	6K
;;	...
;;	10K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 8 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 1 iterations each processing 40 data values

b0b:	start_timer 21
	sub	rax, rax		;; 1 iteration of 2*clm
	xfive_reals_fft_preload		;; Preload consts for five real macros
b1b:	x5cl_five_reals_first_fft rsi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1b
	lea	rsi, [rsi-2*clm*64]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 16K-39K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

	start_timer 22
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64-blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 20 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 48K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels5pfa6 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, c0b, c1a, c1b, c2b, c3a, c3b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 5 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 18
c2b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2b

;; Do 4 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*2*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	12K	24K	36K
;;	...
;;	10K

;; Do 8 six_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 24 data values

	start_timer 19
	mov	al, 2			;; 2 iterations of 2*clm
	xsix_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x3cl_six_reals_last_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	12K	24K	36K
;;	...
;;	10K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 8 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 2			;; 2 iterations of 2*clm
	xsix_reals_fft_preload
b1a:	sub	rbp, rbp
b1b:	x3cl_six_reals_first_fft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+5*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-47K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

	start_timer 22
b2a:	sub	rbp, rbp
b2b:	x2cl_eight_reals_fft_2 rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64-2*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 24 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 48K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels5complex3 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, c0b, c1a, c1b, c3a, c3b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 6 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 6 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 3 macros each processing 16 data values

c0b:	start_timer 18
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*2*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	12K	24K	36K
;;	...
;;	10K

;; Do 8 three_complex_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 24 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 2			;; 2 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x3cl_three_complex_last_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	12K	24K	36K
;;	...
;;	10K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 8 three_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 24 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 2			;; 2 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x3cl_three_complex_first_fft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+5*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 6 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values
;;	do 1 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos1		;; Load sin/cos pointer
b2a:	sub	rbp, rbp
b2b:	x2cl_four_complex_fft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sin/cos pointer
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64-2*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 24 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 56K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels5pfa7 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1b, b2b, b3aa, b3a, b3ba, b3b
	LOCAL	c0b, c1a, c1b, c2b, c3a, c3b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 6 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...

;; Do 1 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 18
c2b:	x1cl_half_eight_reals_unfft_2 rsi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

;; Do 6 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 3 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*2*blkdst-blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	28K	30K
;;	4K	8K	32K	36K
;;	6K
;;	12K	20K	40K	48K
;;	14K
;;	...
;;	18K

;; Do 8 seven_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 1 macros each processing 56 data values

	start_timer 19
	xseven_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x7cl_seven_reals_last_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+3*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	28K	30K
;;	4K	8K	32K	36K
;;	6K
;;	12K	20K	40K	48K
;;	14K
;;	...
;;	18K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 8 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 1 iterations each processing 56 data values

b0b:	start_timer 21
	sub	rax, rax		;; 1 iteration of 2*clm
	xseven_reals_fft_preload
b1b:	x7cl_seven_reals_first_fft rsi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1b
	lea	rsi, [rsi-2*clm*64]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-55K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

	start_timer 22
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b

;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
b3aa:	sub	rbp, rbp
b3a:	x2cl_four_complex_fft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3aa

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
b3ba:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3ba
	lea	rsi, [rsi-2*clm*64-3*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 28 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 64K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels5pfa8 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, c0b, c1a, c1b, c2b, c3a, c3b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 7 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 18
c2b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2b

;; Do 6 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 3 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*2*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K

;; Do 8 eight_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values

	start_timer 19
	mov	al, 2			;; 2 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_eight_reals_last_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 4 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_eight_reals_first_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-63K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos1		;; Load sin/cos pointer
b2a:	sub	rbp, rbp
b2b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a

;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64-4*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 32 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 64K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels5complex4 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b3a, b3b, c0b, c1a, c1b, c3a, c3b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 8 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

c0b:	start_timer 18
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*2*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K

;; Do 8 four_complex_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 2			;; 2 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_four_complex_last_unfft rsi, 64, 2*blkdst, 4*blkdst, 2*128
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 four_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 4 iterations each processing 16 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 4			;; 4 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_four_complex_first_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b3a
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 32 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 80K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels6pfa5 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2b, b3a, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 9 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 1 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 rsi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 9 two_two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 9 macros each processing 8 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2*clm
c5b:	x1cl_two_complex_unfft rsi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [rsi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	rsi, [rsi-10*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 16 data values

	start_timer 18
c2a:	sub	rbp, rbp
c2b:	x2cl_half_eight_reals_unfft_2 rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*4*blkdst-2*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	40K	44K
;;	2K	...
;;	8K	24K	48K	64K
;;	10K
;;	...
;;	22K

;; Do 16 five_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 2 macros each processing 40 data values

	start_timer 19
	mov	al, 2			;; 2 iterations of 2*clm
	xfive_reals_unfft_preload	;; Preload consts for five real macros
c1a:	sub	rbp, rbp
c1b:	x5cl_five_reals_last_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	40K	44K
;;	2K	...
;;	8K	24K	48K	64K
;;	10K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 2 iterations each processing 40 data values

b0b:	start_timer 21
	mov	eax, 2			;; 2 iterations of 2*clm
	xfive_reals_fft_preload		;; Preload consts for five real macros
b1a:	sub	rbp, rbp
b1b:	x5cl_five_reals_first_fft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	xprefetcht1 [rsi-64+3*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+9*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 8 data values

	start_timer 22
	mov	al, 2			;; 2 iterations of 2*clm
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst-2*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 rsi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-5*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 40 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 96K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels6pfa6 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 11 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 1 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 rsi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 11 two_two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 11 macros each processing 8 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2*clm
c5b:	x1cl_two_complex_unfft rsi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [rsi-128+blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	rsi, [rsi-12*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values

	start_timer 18
c2a:	sub	rbp, rbp
c2b:	x4cl_eight_reals_unfft_2 rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*4*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	24K	48K	72K
;;	...
;;	22K

;; Do 16 six_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 24 data values

	start_timer 19
	mov	al, 4			;; 4 iterations of 2*clm
	xsix_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x3cl_six_reals_last_unfft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	24K	48K	72K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2*clm
	xsix_reals_fft_preload
b1a:	sub	rbp, rbp
b1b:	x3cl_six_reals_first_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+9*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

	start_timer 22
	mov	al, 2			;; 2 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x2cl_eight_reals_fft_2 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst-4*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 rsi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 10 two_two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 5 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-6*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 48 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 96K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels6complex3 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c3a, c3b, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 12 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

c0b:	start_timer 16
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 6			;; 6 iterations of 2*clm
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [rsi-128+blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	rsi, [rsi-6*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 12 two_two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 16 data values

	start_timer 18
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iters of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_two_complex_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*4*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	24K	48K	72K
;;	...
;;	22K

;; Do 8 three_complex_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 24 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 4			;; 4 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x3cl_three_complex_last_unfft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	24K	48K	72K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 16 three_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 24 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 4			;; 4 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x3cl_three_complex_first_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+9*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 12 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 16 data values

	start_timer 22
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x2cl_two_complex_fft_in_place rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x2cl_two_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst-4*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 12 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 3 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-3*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 48 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 112K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels6pfa7 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1b, b2b, b3aa, b3a, b3ba, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 13 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 1 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 rsi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 13 two_two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 13 macros each processing 8 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2*clm
c5b:	x1cl_two_complex_unfft rsi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [rsi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	rsi, [rsi-14*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 16 data values

	start_timer 18
c2a:	sub	rbp, rbp
c2b:	x2cl_half_eight_reals_unfft_2 rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2a			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*4*blkdst-2*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	56K	60K
;;	2K	...
;;	8K	16K	64K	72K
;;	10K
;;	...
;;	14K
;;	24K	40K	80K	96K
;;	26K
;;	...
;;	38K

;; Do 16 seven_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 2 macros each processing 56 data values

	start_timer 19
	mov	al, 2			;; 2 iterations of 2*clm
	xseven_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x7cl_seven_reals_last_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+6*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	56K	60K
;;	2K	...
;;	8K	16K	64K	72K
;;	10K
;;	...
;;	14K
;;	24K	40K	80K	96K
;;	26K
;;	...
;;	38K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 2 iterations each processing 56 data values

b0b:	start_timer 21
	mov	eax, 2			;; 2 iterations of 2*clm
	xseven_reals_fft_preload
b1b:	x7cl_seven_reals_first_fft rsi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1b
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-111K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 8 data values

	start_timer 22
	mov	al, 2			;; 2 iterations of 2*clm
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
b3aa:	sub	rbp, rbp
b3a:	x2cl_four_complex_fft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3aa
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3aa			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2*clm
b3ba:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3ba
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3ba			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst-6*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-111K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 rsi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 12 two_two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-7*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 56 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 128K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels6pfa8 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 15 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 1 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 rsi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 15 two_two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 15 macros each processing 8 data values

	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2*clm
c5b:	x1cl_two_complex_unfft rsi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [rsi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values

	start_timer 18
c2a:	sub	rbp, rbp
c2b:	x4cl_eight_reals_unfft_2 rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*4*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K

;; Do 16 eight_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 19
	mov	al, 4			;; 4 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_eight_reals_last_unfft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 8 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_eight_reals_first_fft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x4cl_eight_reals_fft_2 rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 rsi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 14 two_two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 7 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-8*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 64 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 128K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels6complex4 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c3a, c3b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 16 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 16 data values

c0b:	start_timer 16
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+3*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-8*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 16 two_two_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 8 macros each processing 16 data values

	start_timer 18
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 4*256+2		;; 4 iters of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_two_complex_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*4*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K

;; Do 16 four_complex_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 4			;; 4 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_four_complex_last_unfft rsi, 64, 4*blkdst, 8*blkdst, 4*128
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 four_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 8 iterations each processing 16 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 8			;; 8 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_four_complex_first_fft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	start_timer 22
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iters of 4 iters of 2*clm
b3a:	sub	rbp, rbp
b3b:	x2cl_two_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sin/cos pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-2*8*blkdst]	;; Restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 64 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 160K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels7pfa5 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2b, b3a, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 19 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 18 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 9 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+6*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-10*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 16 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x2cl_half_eight_reals_unfft_2 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*8*blkdst-4*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	80K	88K
;;	2K	...
;;	...
;;	6K
;;	16K	48K	96K	128K
;;	18K
;;	...
;;	46K

;; Do 32 five_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 4 macros each processing 40 data values

	start_timer 19
	mov	al, 4			;; 4 iterations of 2*clm
	xfive_reals_unfft_preload	;; Preload consts for five real macros
c1a:	sub	rbp, rbp
c1b:	x5cl_five_reals_last_unfft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+16*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	80K	88K
;;	2K	...
;;	...
;;	6K
;;	16K	48K	96K	128K
;;	18K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 32 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 4 iterations each processing 40 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2*clm
	xfive_reals_fft_preload		;; Preload consts for five real macros
b1a:	sub	rbp, rbp
b1b:	x5cl_five_reals_first_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	xprefetcht1 [rsi-64+5*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+17*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-159K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 8 data values

	start_timer 22
	mov	al, 4			;; 4 iterations of 2*clm
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst-4*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-159K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-5*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 80 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 192K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels7pfa6 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 23 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 22 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 11 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+6*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-12*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x4cl_eight_reals_unfft_2 rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	48K	96K	144K
;;	...
;;	46K

;; Do 32 six_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 24 data values

	start_timer 19
	mov	al, 8			;; 8 iterations of 2*clm
	xsix_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x3cl_six_reals_last_unfft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+16*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	48K	96K	144K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 32 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2*clm
	xsix_reals_fft_preload
b1a:	sub	rbp, rbp
b1b:	x3cl_six_reals_first_fft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+17*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 22
	mov	al, 4			;; 4 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x2cl_eight_reals_fft_2 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 20 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 5 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-6*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 96 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 192K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels7complex3 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c3a, c3b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 24 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 16 data values

c0b:	start_timer 16
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 12			;; 12 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+6*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-12*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 32 data values

	start_timer 18
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	48K	96K	144K
;;	...
;;	46K

;; Do 32 three_complex_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 24 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 8			;; 8 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x3cl_three_complex_last_unfft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+16*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	48K	96K	144K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 32 three_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 24 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 8			;; 8 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x3cl_three_complex_first_fft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+17*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 24 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values
;;	do 4 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x2cl_four_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 24 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 6			;; 6 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-6*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 96 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 224K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels7pfa7 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2b, b3aa, b3a, b3ba, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 27 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 26 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 13 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+6*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-14*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 16 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x2cl_half_eight_reals_unfft_2 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*8*blkdst-4*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	112K	128K	144K
;;	98K
;;	...
;;	110K
;;	160K	176K	192K	208K
;;	162K
;;	...
;;	174K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	112K	120K
;;	2K	...
;;	...
;;	6K
;;	16K	32K	128K	144K
;;	18K
;;	...
;;	30K
;;	48K	80K	160K	192K
;;	50K
;;	...
;;	78K

;; Do 32 seven_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 4 macros each processing 56 data values

	start_timer 19
	mov	al, 4			;; 4 iterations of 2*clm
	xseven_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x7cl_seven_reals_last_unfft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+12*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	112K	120K
;;	2K	...
;;	...
;;	6K
;;	16K	32K	128K	144K
;;	18K
;;	...
;;	30K
;;	48K	80K	160K	192K
;;	50K
;;	...
;;	78K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 32 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 4 iterations each processing 56 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2*clm
	xseven_reals_fft_preload
b1a:	sub	rbp, rbp
b1b:	x7cl_seven_reals_first_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+blkdst][rbp]
	xprefetcht1 [rsi-64+5*blkdst][rbp]
	xprefetcht1 [rsi-64+9*blkdst][rbp]
	mov	ebp, -64+12*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+25*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 8 data values

	start_timer 22
	mov	al, 4			;; 4 iterations of 2*clm
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3aa:	sub	rbp, rbp
b3a:	x2cl_four_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3aa
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3aa			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3ba:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3ba
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3ba			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst-12*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 24 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-7*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 112 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 256K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels7pfa8 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 31 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 30 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 15 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+6*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-16*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x4cl_eight_reals_unfft_2 rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 32 data values

	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K

;; Do 32 eight_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 19
	mov	al, 8			;; 8 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_eight_reals_last_unfft rsi, 64, 8*blkdst, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 16 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 16			;; 16 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_eight_reals_first_fft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+4*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x4cl_eight_reals_fft_2 rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst-16*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 28 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 7 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-8*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 128 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 256K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels7complex4 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5a, b5b
	LOCAL	c0b, c1a, c1b, c3a, c3b, c5a, c5b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 32 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 16 macros each processing 16 data values

c0b:	start_timer 16
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_four_complex_unfft rsi, 64, blkdst
	xprefetcht1 [rsi-64+6*blkdst][rbp]
	mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-16*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 18
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 4*256+2		;; 4 iterations of 2 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K

;; Do 32 four_complex_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 8			;; 8 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_four_complex_last_unfft rsi, 64, 8*blkdst, 16*blkdst, 8*128
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 four_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 16 iterations each processing 16 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 16			;; 16 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_four_complex_first_fft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+4*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations 4 iters of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256
	mov	al, 4
	jnz	b3a
	lea	rsi, [rsi-2*16*blkdst]	;; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-8*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 128 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 320K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels8pfa5 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2b, b3a, b3b, b4a, b4b, b5a, b5b, b6b, b7a, b7b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b
	LOCAL	c4a, c4b, c5a, c5b, c6b, c7a, c7b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 39 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 38 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 19 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 19			;; 19 iterations of 2*clm
c7a:	;sub	rbp, rbp
c7b:	x2cl_four_complex_unfft rsi, 64, blkdst
	;xprefetcht1 [rsi-64+6*blkdst][rbp]
	;mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c7a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	rsi, [rsi-20*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2*clm
c4a:	sub	rbp, rbp
c4b:	x2cl_eight_reals_unfft_1 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 36 two_two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 16 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_two_complex_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-10*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 16 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x2cl_half_eight_reals_unfft_2 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-2*16*blkdst-8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	160K	176K
;;	2K	...
;;	...
;;	14K
;;	32K	96K	192K	256K
;;	34K
;;	...
;;	94K

;; Do 64 five_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 8 macros each processing 40 data values

	start_timer 19
	mov	al, 8			;; 8 iterations of 2*clm
	xfive_reals_unfft_preload	;; Preload consts for five real macros
c1a:	sub	rbp, rbp
c1b:	x5cl_five_reals_last_unfft rsi, 64, 8*blkdst
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
;	xprefetcht1 [rsi-128+clm*128+32*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	160K	176K
;;	2K	...
;;	...
;;	14K
;;	32K	96K	192K	256K
;;	34K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 64 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 8 iterations each processing 40 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2*clm
	xfive_reals_fft_preload		;; Preload consts for five real macros
b1a:	sub	rbp, rbp
b1b:	x5cl_five_reals_first_fft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	xprefetcht1 [rsi-64+10*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
;	xprefetcht1 [rsi-128+34*blkdst][rbp]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-319K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 8 data values

	start_timer 22
	mov	al, 8			;; 8 iterations of 2*clm
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 8*blkdst, 16*blkdst
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_1 macros
;; Do 4 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 23
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b4a:	sub	rbp, rbp
b4b:	x2cl_eight_reals_fft_1 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4a			;; Iterate if necessary

;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 16 macros each processing 16 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-5*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 36 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 9 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2*clm
b7a:	sub	rbp, rbp
b7b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b7a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7a			;; Iterate if necessary
	lea	rsi, [rsi-10*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 160 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 384K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels8pfa6 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b
	LOCAL	b4a, b4b, b5a, b5b, b6b, b7a, b7b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b
	LOCAL	c4a, c4b, c5a, c5b, c6b, c7a, c7b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 47 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 46 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 23 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 23			;; 23 iterations of 2*clm
c7a:	;sub	rbp, rbp
c7b:	x2cl_four_complex_unfft rsi, 64, blkdst
	;xprefetcht1 [rsi-64+6*blkdst][rbp]
	;mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c7a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	rsi, [rsi-24*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2*clm
c4a:	sub	rbp, rbp
c4b:	x2cl_eight_reals_unfft_1 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 44 two_two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 22 macros each processing 16 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_two_complex_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-12*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x4cl_eight_reals_unfft_2 rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*16*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	96K	192K	288K
;;	...
;;	94K

;; Do 64 six_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 24 data values

	start_timer 19
	mov	al, 16			;; 16 iterations of 2*clm
	xsix_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x3cl_six_reals_last_unfft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
;	xprefetcht1 [rsi-128+clm*128+32*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	96K	192K	288K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 64 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 16			;; 16 iterations of 2*clm
	xsix_reals_fft_preload
b1a:	sub	rbp, rbp
b1b:	x3cl_six_reals_first_fft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
;	xprefetcht1 [rsi-128+34*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, and
;; 128K-383K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

	start_timer 22
	mov	al, 8			;; 8 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x2cl_eight_reals_fft_2 rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	lea	rsi, [rsi-8*blkdst+16*blkdst];; Next source pointer
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 8*blkdst, 16*blkdst
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst-16*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_1 macros
;; Do 4 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 23
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b4a:	sub	rbp, rbp
b4b:	x2cl_eight_reals_fft_1 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4a			;; Iterate if necessary

;; Do 40 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 20 macros each processing 16 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-6*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 44 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 11 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2*clm
b7a:	sub	rbp, rbp
b7b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b7a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7a			;; Iterate if necessary
	lea	rsi, [rsi-12*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 192 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 384K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels8complex3 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b5a, b5b, b7a, b7b
	LOCAL	c0b, c1a, c1b, c3a, c3b, c5a, c5b, c7a, c7b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 48 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 24 macros each processing 16 data values

c0b:	start_timer 16
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 24			;; 24 iterations of 2*clm
c7a:	;sub	rbp, rbp
c7b:	x2cl_four_complex_unfft rsi, 64, blkdst
	;xprefetcht1 [rsi-64+6*blkdst][rbp]
	;mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c7a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	rsi, [rsi-24*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	start_timer 17
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 6*256+2		;; 6 iterations of 2 iters of 2*clm
c5a:	sub	rbp, rbp
c5b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-6*8*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 48 two_two_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 16 data values

	start_timer 18
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+8		;; 3 iterations of 8 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_two_complex_unfft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*16*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	96K	192K	288K
;;	...
;;	94K

;; Do 64 three_complex_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 24 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 16			;; 16 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x3cl_three_complex_last_unfft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128+32*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	96K	192K	288K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 64 three_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 24 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 16			;; 16 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x3cl_three_complex_first_fft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+2*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+34*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+192]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 48 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 16 data values

	start_timer 22
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x2cl_two_complex_fft_in_place rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 16			;; 16 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x2cl_two_complex_fft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst-16*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 48 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	start_timer 23
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-3*16*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 48 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 12			;; 12 iterations of 2*clm
b7a:	sub	rbp, rbp
b7b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b7a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7a			;; Iterate if necessary
	lea	rsi, [rsi-12*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 192 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 448K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels8pfa7 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3aa, b3a, b3ba, b3b
	LOCAL	b4a, b4b, b5a, b5b, b6b, b7a, b7b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b
	LOCAL	c4a, c4b, c5a, c5b, c6b, c7a, c7b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 55 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 54 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 27 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 27			;; 27 iterations of 2*clm
c7a:	;sub	rbp, rbp
c7b:	x2cl_four_complex_unfft rsi, 64, blkdst
	;xprefetcht1 [rsi-64+6*blkdst][rbp]
	;mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c7a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	rsi, [rsi-28*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2*clm
c4a:	sub	rbp, rbp
c4b:	x2cl_eight_reals_unfft_1 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 52 two_two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 16 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_two_complex_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-14*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 16 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x2cl_half_eight_reals_unfft_2 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-3*16*blkdst-8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	224K	240K
;;	2K	...
;;	...
;;	14K
;;	32K	64K	256K	288K
;;	34K
;;	...
;;	62K
;;	96K	160K	320K	384K
;;	98K
;;	...
;;	158K

;; Do 64 seven_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 8 macros each processing 56 data values

	start_timer 19
	mov	al, 8			;; 8 iterations of 2*clm
	xseven_reals_unfft_preload
c1a:	sub	rbp, rbp
c1b:	x7cl_seven_reals_last_unfft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	xprefetcht1 [rsi-64+clm*128+16*blkdst][rbp]
	mov	ebp, -64+24*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
;	xprefetcht1 [rsi-128+clm*128+48*blkdst]
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	224K	240K
;;	2K	...
;;	...
;;	14K
;;	32K	64K	256K	288K
;;	34K
;;	...
;;	62K
;;	96K	160K	320K	384K
;;	98K
;;	...
;;	158K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 64 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 8 iterations each processing 56 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2*clm
	xseven_reals_fft_preload
b1a:	sub	rbp, rbp
b1b:	x7cl_seven_reals_first_fft rsi, 64, 8*blkdst
;	xprefetcht1 [rsi-64+2*blkdst][rbp]
	xprefetcht1 [rsi-64+10*blkdst][rbp]
;	xprefetcht1 [rsi-64+18*blkdst][rbp]
	mov	ebp, -64+24*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [rsi-128+50*blkdst]
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-447K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 8 data values

	start_timer 22
	mov	al, 8			;; 8 iterations of 2*clm
b2b:	x1cl_half_eight_reals_fft_2 rsi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [rsi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
b3aa:	sub	rbp, rbp
b3a:	x2cl_four_complex_fft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3aa
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3aa			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	lea	rsi, [rsi-8*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2*clm
b3ba:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 8*blkdst, 16*blkdst
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3ba
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3ba			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst-24*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_1 macros
;; Do 4 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 23
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b4a:	sub	rbp, rbp
b4b:	x2cl_eight_reals_fft_1 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4a			;; Iterate if necessary

;; Do 48 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 16 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-7*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 52 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 13 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2*clm
b7a:	sub	rbp, rbp
b7b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b7a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7a			;; Iterate if necessary
	lea	rsi, [rsi-14*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 224 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 512K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels8pfa8 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4a, b4b
	LOCAL	b5a, b5b, b6b, b7a, b7b
	LOCAL	c0b, c1a, c1b, c2a, c2b, c3a, c3b, c4a, c4b
	LOCAL	c5a, c5b, c6b, c7a, c7b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	pass2			;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	xcopy_7_words
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 63 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 1 eight_reals_unfft_2 macros
;; Do 1 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 rsi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 62 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 31 macros each processing 16 data values

	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 31			;; 31 iterations of 2*clm
c7a:	;sub	rbp, rbp
c7b:	x2cl_four_complex_unfft rsi, 64, blkdst
	;xprefetcht1 [rsi-64+6*blkdst][rbp]
	;mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c7a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	rsi, [rsi-32*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2*clm
c4a:	sub	rbp, rbp
c4b:	x2cl_eight_reals_unfft_1 rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 60 two_two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 16 data values

	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters of 2*clm
c5a:	sub	rbp, rbp
c5b:	x2cl_two_complex_unfft rsi, 64, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-16*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2*clm
c2a:	sub	rbp, rbp
c2b:	x4cl_eight_reals_unfft_2 rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x4cl_four_complex_unfft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*16*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K

;; Do 64 eight_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

	start_timer 19
	mov	al, 16			;; 16 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_eight_reals_last_unfft rsi, 64, 16*blkdst, 32*blkdst
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+16*blkdst][rbp]
	mov	ebp, -64+32*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT
	xcopy_3_words clm, 0

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 64 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 32 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 32			;; 32 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_eight_reals_first_fft rsi, 64, 32*blkdst
	xprefetcht1 [rsi-64+4*blkdst][rbp]
	mov	ebp, -64+32*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-32*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	start_timer 22
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2*clm
b2a:	sub	rbp, rbp
b2b:	x4cl_eight_reals_fft_2 rsi, 64, 8*blkdst, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b2a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	lea	rsi, [rsi-8*blkdst+32*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x4cl_four_complex_fft rsi, 64, 8*blkdst, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+8*blkdst][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst-32*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_fft_1 macros
;; Do 4 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 23
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2*clm
b4a:	sub	rbp, rbp
b4b:	x2cl_eight_reals_fft_1 rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4a			;; Iterate if necessary

;; Do 56 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 28 macros each processing 16 data values

	lea	rsi, [rsi-4*blkdst+8*blkdst];; Load source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2*clm
b5a:	sub	rbp, rbp
b5b:	x2cl_two_complex_fft rsi, 64, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-8*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 1 eight_reals_fft_2 macros
;; Do 1 nop_two_two_complex_fft_2 macros
;; Do 2 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 1 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 rsi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 60 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 15 macros each processing 32 data values

	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2*clm
b7a:	sub	rbp, rbp
b7b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b7a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7a			;; Iterate if necessary
	lea	rsi, [rsi-16*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 256 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	fftdn1			;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	xcopy_4_words
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM


;; Perform a 512K-element all-complex FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xpass1levels8complex4 MACRO pass2_macro, p2cl, clm
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5a, b5b, b7a, b7b
	LOCAL	c0b, c1a, c1b, c3a, c3b, c5a, c5b, c7a, c7b
	LOCAL	pass2, no_fft, more, fftdn, fftdn1

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [rsi-28][rbx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 64 pass2_11_levels_complex

pass2:	start_timer 0
	mov	rbp, _SRCARG
	sub	rbp, rsi
	CALLP	pass2_macro
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_Y	xgw_finish_fft
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	rdx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, rdx		;; Save ptr
	mov	rdx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, rdx		;; Save ptr
	mov	edx, p2cl/64*65536+64/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 32 macros each processing 16 data values

c0b:	start_timer 16
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	eax, 32			;; 32 iterations of 2*clm
c7a:	;sub	rbp, rbp
c7b:	x2cl_four_complex_unfft rsi, 64, blkdst
	;xprefetcht1 [rsi-64+6*blkdst][rbp]
	;mov	ebp, -64+blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c7a
	lea	rsi, [rsi-2*clm*64+2*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	rsi, [rsi-32*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 16 macros each processing 32 data values

	start_timer 17
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 8*256+2		;; 8 iterations of 2 iters of 2*clm
c5a:	sub	rbp, rbp
c5b:	x4cl_four_complex_unfft rsi, 64, 2*blkdst, 4*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+2*blkdst][rbp]
	mov	ebp, -64+4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-2*blkdst+8*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	rsi, [rsi-8*8*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 64 two_two_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

	start_timer 18
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 4*256+8		;; 4 iterations of 8 iters of 2*clm
c3a:	sub	rbp, rbp
c3b:	x2cl_two_complex_unfft rsi, 64, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-8*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	jnz	c3a			;; Iterate if necessary
	lea	rsi, [rsi-4*16*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K

;; Do 64 four_complex_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

	start_timer 19
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	al, 16			;; 16 iterations of 2*clm
c1a:	sub	rbp, rbp
c1b:	x4cl_four_complex_last_unfft rsi, 64, 16*blkdst, 32*blkdst, 16*128
;	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+16*blkdst][rbp]
	mov	ebp, -64+32*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	c1a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	mov	rax, _NORMRTN		;; Addr of normalization routine
	call	rax
	sub	rax, rax
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set
	cmp	edx, p2cl/64*65536+(64/clm-4/clm)*256;; Delay fft on 8 sets
	jg	no_fft			;; Jump if delaying FFT

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 64 four_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 32 iterations each processing 16 data values

b0b:	start_timer 21
	mov	rdi, plus1_premults	;; Address of premultiplier table
	mov	eax, 32			;; 32 iterations of 2*clm
b1a:	sub	rbp, rbp
b1b:	x2cl_four_complex_first_fft rsi, 64, 32*blkdst
	xprefetcht1 [rsi-64+4*blkdst][rbp]
	mov	ebp, -64+32*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	lea	rdi, [rdi+128]		;; Next premultiplier pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	rsi, [rsi-32*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

	start_timer 22
	mov	rdi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+16		;; 2 iters of 16 iterations of 2*clm
b3a:	sub	rbp, rbp
b3b:	x2cl_two_complex_fft rsi, 64, 16*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	mov	ebp, -64+16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b3a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-16*blkdst+32*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sin/cos pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16
	jnz	b3a			;; Iterate if necessary
	lea	rsi, [rsi-2*32*blkdst]	;; Restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 16 macros each processing 32 data values

	start_timer 23
	mov	rdi, sincos2		;; Load sin/cos pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2*clm
b5a:	sub	rbp, rbp
b5b:	x4cl_four_complex_fft rsi, 64, 4*blkdst, 8*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
;	xprefetcht1 [rsi-64+clm*128+4*blkdst][rbp]
	mov	ebp, -64+8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b5a
	lea	rsi, [rsi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*blkdst+16*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	rsi, [rsi-4*16*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 16 macros each processing 32 data values

	start_timer 24
	mov	rdi, sincos1		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2*clm
b7a:	sub	rbp, rbp
b7b:	x4cl_four_complex_fft rsi, 64, blkdst, 2*blkdst
	xprefetcht1 [rsi-64+clm*128][rbp]
	xprefetcht1 [rsi-64+clm*128+blkdst][rbp]
	mov	ebp, -64+2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b7a
	lea	rsi, [rsi-2*clm*64+4*blkdst];; Next source pointer
	lea	rdi, [rdi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7a			;; Iterate if necessary
	lea	rsi, [rsi-16*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 256 values

no_fft:	lea	rsi, [rsi+clm*128]	;; Next source pointer
	sub	dh, 1			;; Test loop counter
	jnz	short more		;; Do more FFTs
	lea	rsi, [rsi+128]		;; Skip pad every 8KB
	sub	edx, 65536		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	mov	dh, 64/clm		;; Restore cache line counter
more:	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	rsi, [rsi-p2cl*128-p2cl/64*128];; Restore source pointer
	sub	rbx, rbx
	cmp	rsi, _DESTARG		;; If esi was not restored, then we 
	jne	short fftdn1		;; just finished skipped postfft data
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.  Then add the carries back to the
;; FFT data.

	start_timer 26
	CALL_Y	xgw_carries
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, set loop to FFT the first few cache lines now that the carries
;; have been added in.

	cmp	_POSTFFT, 0		;; Test flag
	je	short fftdn1		;; Skip FFT code if flag not set
	mov	rsi, _DESTARG		;; Load FFT data address
	sub	rbx, rbx
	mov	edx, 65536+4/clm*256	;; Do 8 previously skipped cache lines
	mov	norm_ptr1, 0		;; Set flag so only forward FFT is done
	jmp	b0b

;; Now cleanup and return

fftdn1:	end_timer 1
	JMP_Y	xgw_finish_mult
	ENDM

