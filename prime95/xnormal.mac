; Copyright 2000-2001 - Just For Fun Software, Inc.
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros efficiently implement the normalization to integers
; and multiplication by two-to-phi powers using SSE2 instructions.
;


; These macros implement the variants of the normalization routines
; in a non-pipelined way.  It is simply too much work to hand optimize
; all normalization variants.

; Compute the convolution error and if greater than MAXERR, set MAXERR

brute_force_error_check MACRO xmmreg, tmpreg, errreg
	movapd	tmpreg, XMM_BIGVAL	;; Convert to an integer
	addpd	tmpreg, xmmreg
	subpd	tmpreg, XMM_BIGVAL
	subpd	tmpreg, xmmreg		;; This is the convolution error
	andpd	tmpreg, XMM_ABSVAL	;; Compute absolute value
	maxpd	errreg, tmpreg		;; Compute maximum error
	ENDM

; Multiply the FFT result by a small constant.  Since we are worried that
; the FFT data times a small constant will overflow 51 bits, we split
; the FFT data into two pieces before multiplying by the constant.

brute_force_mul_by_const MACRO xmmreg, xmmreg2
	movapd	xmmreg2, XMM_BIGBIGVAL
	addpd	xmmreg2, xmmreg		;; Round to nearest multiple of 2^25
	addpd	xmmreg, XMM_BIGVAL	;; Round to an integer
	subpd	xmmreg2, XMM_BIGBIGVAL
	subpd	xmmreg, XMM_BIGVAL
	subpd	xmmreg, xmmreg2		;; xmmreg now contains low 25 bits
	mulpd	xmmreg2, XMM_MULCONST	;; Multiply by the small constant
	mulpd	xmmreg, XMM_MULCONST
	ENDM

; Zero upper words of FFT.  The C code will set 8 pointers - 4 tell us
; the point where we switch from no zeroing to zeroing the LSW.  The other
; 4 pointers tells where we switch from zeroing the LSW to zeroing the
; entire xmm register.

brute_force_zero MACRO col, xmmreg
	LOCAL	zdone, z_one
	cmp	esi, _FFTZERO+col*8+4	;; Check second pointer
	jl	short zdone		;; Jump if no zeroing
	cmp	esi, _FFTZERO+col*8	;; Check first pointer
	jl	short z_one		;; Jump if zeroing one double
	subpd	xmmreg, xmmreg		;; Zero both doubles
	jmp	short zdone
z_one:	andpd	xmmreg, XMM_ZERO_MSW	;; Clear just one double
zdone:
	ENDM

; Macro to rotate the four carries in xmm2 and xmm3

xnorm_rotate_carries MACRO x2, x3
	LOCAL	signok
	movapd	xmm0, x2		;; Rotate carries
	shufpd	x2, x3, 1		;; LSW = MSW of xmm2, MSW = LSW of xmm3
	shufpd	x3, xmm0, 1		;; LSW = MSW of xmm3, MSW = LSW of xmm2
	cmp	_PLUS1, 0		;; Invert carry if necessary
	jz	short signok
	subsd	x3, XMM_BIGVAL
	xorpd	x3, XMM_NEGATE_LSW
	addsd	x3, XMM_BIGVAL
signok:
	ENDM


;
; Now for the actual normalization macros!
;


; For 1D macros, these registers are set on input:
; xmm7 = sumout
; xmm6 = MAXERR
; xmm3 = carry #2
; xmm2 = carry #1
; esi = pointer to the FFT data values
; ebp = pointer two-to-phi multipliers
; edi = pointer to array of big vs. little flags
; ecx = big vs. little word flag #2
; eax = big vs. little word flag #1


; *************** 1D macro ******************
; A pipelined version of this code:
;	mov	al, [edi]		;; Load big vs. little flags
;	movapd	xmm0, [esi+0*dist1]	;; Load values
;	addpd	sumout, xmm0		;; sumout += values
;	mulpd	xmm0, [ebp+0]		;; Mul values1 by two-to-minus-phi
;	addpd	xmm0, xmm4		;; x = values + carry
;	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
;	addpd	xmm2, xmm0		;; y = top bits of x
;	movapd	xmm6, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
;	addpd	xmm6, xmm2		;; z = y - (maximum * BIGVAL - BIGVAL)
;	subpd	xmm0, xmm6		;; rounded value = x - z
;	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y
;	mulpd	xmm0, [ebp+16]		;; new value = val * two-to-phi
;	movapd	[esi+0*dist1], xmm0	;; Save new value

xnorm_1d MACRO numvals, ttp, zero, echk, const
	IF numvals EQ 8
ttp	mov	al, [edi]		;; Load big vs. little flags
ttp	mov	cl, [edi+2]
	movapd	xmm0, [esi]		;; Load values1
	unpcklpd xmm0, [esi+16]
	addpd	xmm7, xmm0		;; sumout += values1
	mulpd	xmm0, [ebp]		;; Mul values1 by two-to-minus-phi
echk	brute_force_error_check xmm0, xmm4, xmm6
const	brute_force_mul_by_const xmm0, xmm4
	movapd	xmm1, [esi+32]		;; Load values2
	unpcklpd xmm1, [esi+48]
	addpd	xmm7, xmm1		;; sumout += values2
	mulpd	xmm1, [ebp+64]		;; Mul values2 by two-to-minus-phi
echk	brute_force_error_check xmm1, xmm4, xmm6
const	brute_force_mul_by_const xmm1, xmm5
	addpd	xmm2, xmm0		;; x1 = values + carry
	addpd	xmm3, xmm1		;; x2 = values + carry
	movapd	xmm0, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm0, xmm2		;; y1 = top bits of x
	movapd	xmm1, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm1, xmm3		;; y2 = top bits of x
const	addpd	xmm4, xmm0		;; Add in upper mul-by-const bits
const	mulpd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const movapd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const mulpd	xmm4, xmm0		;; next carry = shifted y1
	subpd	xmm0, XMM_LIMIT_BIGMAX[eax];; z1 = y1 - (maximum*BIGVAL-BIGVAL)
const	addpd	xmm5, xmm1		;; Add in upper mul-by-const bits
const	mulpd	xmm5, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const movapd	xmm5, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const mulpd	xmm5, xmm1		;; next carry = shifted y2
	subpd	xmm1, XMM_LIMIT_BIGMAX[ecx];; z2 = y2 - (maximum*BIGVAL-BIGVAL)
	subpd	xmm2, xmm0		;; rounded value = x1 - z1
	subpd	xmm3, xmm1		;; rounded value = x2 - z2
ttp	mulpd	xmm2, [ebp+16]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm3, [ebp+80]		;; new value2 = val * two-to-phi
ttp	mov	al, [edi+1]		;; Load big vs. little flags
ttp	mov	cl, [edi+3]
	movapd	xmm0, [esi]		;; Load values1
	unpckhpd xmm0, [esi+16]
	addpd	xmm7, xmm0		;; sumout += values1
	mulpd	xmm0, [ebp+32]		;; Mul values1 by two-to-minus-phi
zero	brute_force_zero 0, xmm2
	movapd	[esi], xmm2		;; Save previous value1
echk	brute_force_error_check xmm0, xmm2, xmm6
const	brute_force_mul_by_const xmm0, xmm2
	movapd	xmm1, [esi+32]		;; Load values2
	unpckhpd xmm1, [esi+48]
	addpd	xmm7, xmm1		;; sumout += values2
	mulpd	xmm1, [ebp+96]		;; Mul values2 by two-to-minus-phi
zero	brute_force_zero 2, xmm3
	movapd	[esi+32], xmm3		;; Save previous value2
echk	brute_force_error_check xmm1, xmm3, xmm6
const	brute_force_mul_by_const xmm1, xmm3
	addpd	xmm0, xmm4		;; x1 = values + carry
	addpd	xmm1, xmm5		;; x2 = values + carry
	movapd	xmm4, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm4, xmm0		;; y1 = top bits of x
	movapd	xmm5, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm5, xmm1		;; y2 = top bits of x
const	addpd	xmm2, xmm4		;; Add in upper mul-by-const bits
const	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const movapd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const mulpd	xmm2, xmm4		;; next carry = shifted y1
	subpd	xmm4, XMM_LIMIT_BIGMAX[eax];; z1 = y1 - (maximum*BIGVAL-BIGVAL)
const	addpd	xmm3, xmm5		;; Add in upper mul-by-const bits
const	mulpd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const movapd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const mulpd	xmm3, xmm5		;; next carry = shifted y2
	subpd	xmm5, XMM_LIMIT_BIGMAX[ecx];; z2 = y2 - (maximum*BIGVAL-BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
ttp	mulpd	xmm0, [ebp+48]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebp+112]		;; new value2 = val * two-to-phi
zero	brute_force_zero 1, xmm0
	movapd	[esi+16], xmm0		;; Save new value1
zero	brute_force_zero 3, xmm1
	movapd	[esi+48], xmm1		;; Save new value2
	ENDIF

	IF numvals EQ 4
ttp	mov	al, [edi]		;; Load big vs. little flags
	movapd	xmm0, [esi]		;; Load values1
	unpcklpd xmm0, [esi+16]
	addpd	xmm7, xmm0		;; sumout += values1
	mulpd	xmm0, [ebp]		;; Mul values1 by two-to-minus-phi
echk	brute_force_error_check xmm0, xmm4, xmm6
const	brute_force_mul_by_const xmm0, xmm4
	addpd	xmm2, xmm0		;; x1 = values + carry
	movapd	xmm0, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm0, xmm2		;; y1 = top bits of x
const	addpd	xmm4, xmm0		;; Add in upper mul-by-const bits
const	mulpd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const movapd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const mulpd	xmm4, xmm0		;; next carry = shifted y1
	subpd	xmm0, XMM_LIMIT_BIGMAX[eax];; z1 = y1 - (maximum*BIGVAL-BIGVAL)
	subpd	xmm2, xmm0		;; rounded value = x1 - z1
ttp	mulpd	xmm2, [ebp+16]		;; new value1 = val * two-to-phi
ttp	mov	al, [edi+1]		;; Load big vs. little flags
	movapd	xmm0, [esi]		;; Load values1
	unpckhpd xmm0, [esi+16]
	addpd	xmm7, xmm0		;; sumout += values1
	mulpd	xmm0, [ebp+32]		;; Mul values1 by two-to-minus-phi
zero	brute_force_zero 0, xmm2
	movapd	[esi], xmm2		;; Save previous value1
echk	brute_force_error_check xmm0, xmm2, xmm6
const	brute_force_mul_by_const xmm0, xmm2
	addpd	xmm0, xmm4		;; x1 = values + carry
	movapd	xmm4, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm4, xmm0		;; y1 = top bits of x
const	addpd	xmm2, xmm4		;; Add in upper mul-by-const bits
const	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const movapd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const mulpd	xmm2, xmm4		;; next carry = shifted y1
	subpd	xmm4, XMM_LIMIT_BIGMAX[eax];; z1 = y1 - (maximum*BIGVAL-BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
ttp	mulpd	xmm0, [ebp+48]		;; new value1 = val * two-to-phi
zero	brute_force_zero 1, xmm0
	movapd	[esi+16], xmm0		;; Save new value1
	ENDIF
	ENDM


; *************** 1D followup macro ******************
; This macro finishes the normalize process by adding the final
; carry from the first pass back into the lower two data values.
; We take advantage of the fact that the first two-to-phi multiplier
; and the first two-to-minus-phi multiplier are one.  We also know
; the first data value is a big word (eax would be -1).
; st(0) = carry
; esi = pointer to the FFT data values
; ebp = pointer two-to-power multipliers
; NOTE: If NUMLIT is zero we could eliminate 8 multiplies.

xnorm012_1d MACRO zero
	xnorm_rotate_carries xmm2, xmm3	;; Rotate the carries
	mov	al, [edi]		;; Load big vs. little flags
	mov	cl, [edi+2]
	movapd	xmm0, [esi]		;; Load values1
	mulpd	xmm0, [ebp]		;; Mul values1 by two-to-minus-phi
	mulpd	xmm0, XMM_NORM012_FF	;; Mul by FFTLEN/2
	movapd	xmm1, [esi+32]		;; Load values2
	mulpd	xmm1, [ebp+64]		;; Mul values2 by two-to-minus-phi
	mulpd	xmm1, XMM_NORM012_FF	;; Mul by FFTLEN/2
	addpd	xmm0, xmm3		;; x1 = values + carry
	addpd	xmm1, xmm2		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
	mulpd	xmm0, [ebp+16]		;; new value1 = val * two-to-phi
	mulpd	xmm1, [ebp+80]		;; new value2 = val * two-to-phi
zero	brute_force_zero 0, xmm0
	movapd	[esi], xmm0		;; Save previous value1
zero	brute_force_zero 2, xmm1
	movapd	[esi+32], xmm1		;; Save previous value2
	movapd	xmm0, [esi+16]		;; Load values1
	movapd	xmm1, [esi+48]		;; Load values2
	subpd	xmm2, XMM_BIGVAL	;; Remove integer rounding constant
	subpd	xmm3, XMM_BIGVAL	;; Remove integer rounding constant
	mulpd	xmm2, [ebp+48]		;; carry *= two-to-phi
	mulpd	xmm3, [ebp+112]		;; carry *= two-to-phi
	addpd	xmm0, xmm2		;; value1 = values + carry
	addpd	xmm1, xmm3		;; value2 = values + carry
zero	brute_force_zero 1, xmm0
	movapd	[esi+16], xmm0		;; Save new value1
zero	brute_force_zero 3, xmm1
	movapd	[esi+48], xmm1		;; Save new value2
	ENDM



; For 2D macros, these registers are set on input:
; xmm7 = sumout
; xmm6 = maxerr
; ebp = pointer to carries
; edi = pointer to big/little flags
; esi = pointer to the FFT data
; ebx = pointer two-to-power column multipliers
; edx = pointer two-to-power group multipliers
; ecx = big vs. little word flag #2
; eax = big vs. little word flag #1


; *************** 2D macro ******************
; A pipelined version of this code:
;	mov	al, [edi]		;; Load big vs. little flags
;	movapd	xmm0, [esi+0*dist1]	;; Load values1
;	addpd	sumout, xmm0		;; sumout += values1
;	movapd	xmm2, [ebx]		;; col two-to-minus-phi
;	mulpd	xmm2, XMM_TTMP_FUDGE[eax];; Mul by fudge two-to-minus-phi
;	mulpd	xmm0, [edx]		;; Mul by grp two-to-minus-phi
;	mulpd	xmm0, xmm2		;; Mul by fudged col two-to-minus-phi
;	addpd	xmm0, [ebp+0*16]	;; x1 = values + carry
;	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
;	addpd	xmm2, xmm0		;; y1 = top bits of x
;	movapd	xmm6, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
;	addpd	xmm6, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
;	subpd	xmm0, xmm6		;; rounded value = x1 - z1
;	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
;	movapd	xmm4, [ebx]		;; col two-to-phi
;	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
;	mulpd	xmm0, [edx+0*32+16]	;; new value1 = val * grp two-to-phi
;	mulpd	xmm0, xmm4		;; new value1 *= fudged col two-to-phi
;	movapd	[esi+0*dist1], xmm0	;; Save new value1
;	movapd	[ebp+0*16], xmm2	;; Save carry
;

xnorm_2d MACRO ttp, zero, echk, const
ttp	mov	al, [edi+0]		;; Load big vs. little flags
ttp	mov	cl, [edi+1]		;; Load big vs. little flags
	movapd	xmm0, [esi+0*16]	;; Load values1
	addpd	xmm7, xmm0		;; sumout += values1
	movapd	xmm2, [ebx]		;; col two-to-minus-phi
ttp	mulpd	xmm2, XMM_TTMP_FUDGE[eax];; Mul by fudge two-to-minus-phi
ttp	mulpd	xmm0, [edx+0*32]	;; Mul by grp two-to-minus-phi
	mulpd	xmm0, xmm2		;; Mul by fudged col two-to-minus-phi
echk	brute_force_error_check xmm0, xmm4, xmm6
const	brute_force_mul_by_const xmm0, xmm4
	movapd	xmm1, [esi+1*16]	;; Load values2
	addpd	xmm7, xmm1		;; sumout += values2
	movapd	xmm3, [ebx]		;; col two-to-minus-phi
ttp	mulpd	xmm3, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
ttp	mulpd	xmm1, [edx+1*32]	;; Mul by grp two-to-minus-phi
	mulpd	xmm1, xmm3		;; Mul by fudged col two-to-minus-phi
echk	brute_force_error_check xmm1, xmm5, xmm6
const	brute_force_mul_by_const xmm1, xmm5
	addpd	xmm0, [ebp+0*16]	;; x1 = values + carry
	addpd	xmm1, [ebp+1*16]	;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y2 = top bits of x
const	addpd	xmm4, xmm2		;; Add in upper mul-by-const bits
const	mulpd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const movapd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const mulpd	xmm4, xmm2		;; next carry = shifted y1
	subpd	xmm2, XMM_LIMIT_BIGMAX[eax];; z1 = y1 - (maximum*BIGVAL-BIGVAL)
const	addpd	xmm5, xmm3		;; Add in upper mul-by-const bits
const	mulpd	xmm5, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const movapd	xmm5, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const mulpd	xmm5, xmm3		;; next carry = shifted y2
	subpd	xmm3, XMM_LIMIT_BIGMAX[ecx];; z2 = y2 - (maximum*BIGVAL-BIGVAL)
	subpd	xmm0, xmm2		;; rounded value = x1 - z1
	subpd	xmm1, xmm3		;; rounded value = x2 - z2
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
ttp	mulpd	xmm0, [edx+0*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm0, xmm2		;; new value1 *= fudged col two-to-phi
zero	brute_force_zero 0, xmm0
	movapd	[esi+0*16], xmm0	;; Save new value1
	movapd	[ebp+0*16], xmm4	;; Save carry
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm1, [edx+1*32+16]	;; new value2 = val * grp two-to-phi
ttp	mulpd	xmm1, xmm3		;; new value2 *= fudged col two-to-phi
zero	brute_force_zero 1, xmm1
	movapd	[esi+1*16], xmm1	;; Save new value2
	movapd	[ebp+1*16], xmm5	;; Save carry

ttp	mov	al, [edi+2]		;; Load big vs. little flags
ttp	mov	cl, [edi+3]		;; Load big vs. little flags
	movapd	xmm0, [esi+2*16]	;; Load values1
	addpd	xmm7, xmm0		;; sumout += values1
	movapd	xmm2, [ebx]		;; col two-to-minus-phi
ttp	mulpd	xmm2, XMM_TTMP_FUDGE[eax];; Mul by fudge two-to-minus-phi
ttp	mulpd	xmm0, [edx+2*32]	;; Mul by grp two-to-minus-phi
	mulpd	xmm0, xmm2		;; Mul by fudged col two-to-minus-phi
echk	brute_force_error_check xmm0, xmm4, xmm6
const	brute_force_mul_by_const xmm0, xmm4
	movapd	xmm1, [esi+3*16]	;; Load values2
	addpd	xmm7, xmm1		;; sumout += values2
	movapd	xmm3, [ebx]		;; col two-to-minus-phi
ttp	mulpd	xmm3, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
ttp	mulpd	xmm1, [edx+3*32]	;; Mul by grp two-to-minus-phi
	mulpd	xmm1, xmm3		;; Mul by fudged col two-to-minus-phi
echk	brute_force_error_check xmm1, xmm5, xmm6
const	brute_force_mul_by_const xmm1, xmm5
	addpd	xmm0, [ebp+2*16]	;; x1 = values + carry
	addpd	xmm1, [ebp+3*16]	;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y2 = top bits of x
const	addpd	xmm4, xmm2		;; Add in upper mul-by-const bits
const	mulpd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const movapd	xmm4, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
no const mulpd	xmm4, xmm2		;; next carry = shifted y1
	subpd	xmm2, XMM_LIMIT_BIGMAX[eax];; z1 = y1 - (maximum*BIGVAL-BIGVAL)
const	addpd	xmm5, xmm3		;; Add in upper mul-by-const bits
const	mulpd	xmm5, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const movapd	xmm5, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y2
no const mulpd	xmm5, xmm3		;; next carry = shifted y2
	subpd	xmm3, XMM_LIMIT_BIGMAX[ecx];; z2 = y2 - (maximum*BIGVAL-BIGVAL)
	subpd	xmm0, xmm2		;; rounded value = x1 - z1
	subpd	xmm1, xmm3		;; rounded value = x2 - z2
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
ttp	mulpd	xmm0, [edx+2*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm0, xmm2		;; new value1 *= fudged col two-to-phi
zero	brute_force_zero 2, xmm0
	movapd	[esi+2*16], xmm0	;; Save new value1
	movapd	[ebp+2*16], xmm4	;; Save carry
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm1, [edx+3*32+16]	;; new value2 = val * grp two-to-phi
ttp	mulpd	xmm1, xmm3		;; new value2 *= fudged col two-to-phi
zero	brute_force_zero 3, xmm1
	movapd	[esi+3*16], xmm1	;; Save new value2
	movapd	[ebp+3*16], xmm5	;; Save carry
	ENDM


; *************** 2D followup macro ******************
; This macro finishes the normalize process by adding the final carries
; back into the appropriate FFT values.
; esi = pointer to carries
; ebp = pointer after carries (store high carry words here)
; edi = pointer to big/little flags
; ebx = pointer two-to-power column multipliers
; edx = pointer two-to-power group multipliers
; ecx = big vs. little word flag #2
; eax = big vs. little word flag #1

xnorm012_2d_part1 MACRO
	LOCAL	signok
	_movsd	xmm7, [ebp-8]		; Load very last carry
	cmp	_PLUS1, 0		; See if sign needs to change
	jz	short signok
	subsd	xmm7, XMM_BIGVAL	; Negate the carry
	xorpd	xmm7, XMM_NEGATE_LSW
	addsd	xmm7, XMM_BIGVAL
signok:
	ENDM
xnorm012_2d_part2 MACRO
	_movsd	xmm0, xmm7		; Copy last carry from prev section
	_movsd	xmm1, [ebx-56]		; Load first 3 carries in this section
	_movsd	xmm2, [ebx-40]
	_movsd	xmm3, [ebx-24]
	_movsd	xmm7, [ebx-8]		; Remember last carry for next section
	ENDM
xnorm012_2d MACRO
	mov	al, [edi+0]		;; Load big vs. little flag
	mov	cl, [edi+4]
	movhpd	xmm0, [esi+0*16]	;; Load high word of carry XMM reg
	movapd	xmm5, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm5, xmm0		;; y1 = top bits of carry
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm5		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; low carry = x1 - z1
	mulpd	xmm5, XMM_LIMIT_INVERSE[eax];; high carry = shifted y1
	subpd	xmm5, XMM_BIGVAL
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+0*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm0		;; low carry *= two-to-phi
	_movsd	xmm0, [esi+0*16+8]	;; Load carry for next row
	movapd	[esi+0*16], xmm4	;; Save low carry
	movapd	xmm4, [ebx+48]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
	mulpd	xmm5, [edx+0*32+16]	;; high carry *= grp two-to-phi
	mulpd	xmm5, xmm4		;; high carry *= fudged col two-to-phi
	movapd	[ebp+0*16], xmm5	;; Save high carry

	mov	al, [edi+1]		;; Load big vs. little flag
	mov	cl, [edi+5]
	movhpd	xmm1, [esi+1*16]	;; Load high word of carry XMM reg
	movapd	xmm5, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm5, xmm1		;; y1 = top bits of carry
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm5		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm1, xmm4		;; low carry = x1 - z1
	mulpd	xmm5, XMM_LIMIT_INVERSE[eax];; high carry = shifted y1
	subpd	xmm5, XMM_BIGVAL
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+1*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm1		;; low carry *= two-to-phi
	_movsd	xmm1, [esi+1*16+8]	;; Load carry for next row
	movapd	[esi+1*16], xmm4	;; Save low carry
	movapd	xmm4, [ebx+48]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
	mulpd	xmm5, [edx+1*32+16]	;; high carry *= grp two-to-phi
	mulpd	xmm5, xmm4		;; high carry *= fudged col two-to-phi
	movapd	[ebp+1*16], xmm5	;; Save high carry

	mov	al, [edi+2]		;; Load big vs. little flag
	mov	cl, [edi+6]
	movhpd	xmm2, [esi+2*16]	;; Load high word of carry XMM reg
	movapd	xmm5, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm5, xmm2		;; y1 = top bits of carry
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm5		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm2, xmm4		;; low carry = x1 - z1
	mulpd	xmm5, XMM_LIMIT_INVERSE[eax];; high carry = shifted y1
	subpd	xmm5, XMM_BIGVAL
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+2*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm2		;; low carry *= two-to-phi
	_movsd	xmm2, [esi+2*16+8]	;; Load carry for next row
	movapd	[esi+2*16], xmm4	;; Save low carry
	movapd	xmm4, [ebx+48]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
	mulpd	xmm5, [edx+2*32+16]	;; high carry *= grp two-to-phi
	mulpd	xmm5, xmm4		;; high carry *= fudged col two-to-phi
	movapd	[ebp+2*16], xmm5	;; Save high carry

	mov	al, [edi+3]		;; Load big vs. little flag
	mov	cl, [edi+7]
	movhpd	xmm3, [esi+3*16]	;; Load high word of carry XMM reg
	movapd	xmm5, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm5, xmm3		;; y1 = top bits of carry
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm5		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm3, xmm4		;; low carry = x1 - z1
	mulpd	xmm5, XMM_LIMIT_INVERSE[eax];; high carry = shifted y1
	subpd	xmm5, XMM_BIGVAL
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+3*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm3		;; low carry *= two-to-phi
	_movsd	xmm3, [esi+3*16+8]	;; Load carry for next row
	movapd	[esi+3*16], xmm4	;; Save low carry
	movapd	xmm4, [ebx+48]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
	mulpd	xmm5, [edx+3*32+16]	;; high carry *= grp two-to-phi
	mulpd	xmm5, xmm4		;; high carry *= fudged col two-to-phi
	movapd	[ebp+3*16], xmm5	;; Save high carry
	ENDM
xnorm012_2d_addin MACRO zero
	movapd	xmm0, [esi+0*16]	;; Load FFT word
	addpd	xmm0, [ebp+0*16]	;; Add in carries
zero	brute_force_zero 0, xmm0
	movapd	[esi+0*16], xmm0	;; Save FFT word
	movapd	xmm1, [esi+1*16]	;; Load FFT word
	addpd	xmm1, [ebp+1*16]	;; Add in carries
zero	brute_force_zero 1, xmm1
	movapd	[esi+1*16], xmm1	;; Save FFT word
	movapd	xmm2, [esi+2*16]	;; Load FFT word
	addpd	xmm2, [ebp+2*16]	;; Add in carries
zero	brute_force_zero 2, xmm2
	movapd	[esi+2*16], xmm2	;; Save FFT word
	movapd	xmm3, [esi+3*16]	;; Load FFT word
	addpd	xmm3, [ebp+3*16]	;; Add in carries
zero	brute_force_zero 3, xmm3
	movapd	[esi+3*16], xmm3	;; Save FFT word
	movapd	[ebp], xmm4		;; Reset carry
	movapd	[ebp+16], xmm4		;; Reset carry
	movapd	[ebp+32], xmm4		;; Reset carry
	movapd	[ebp+48], xmm4		;; Reset carry
	movapd	xmm0, [esi+64+0*16]	;; Load FFT word
	addpd	xmm0, [ebx+0*16]	;; Add in carries
zero	lea	esi, [esi+64]
zero	brute_force_zero 0, xmm0
zero	lea	esi, [esi-64]
	movapd	[esi+64+0*16], xmm0	;; Save FFT word
	movapd	xmm1, [esi+64+1*16]	;; Load FFT word
	addpd	xmm1, [ebx+1*16]	;; Add in carries
zero	lea	esi, [esi+64]
zero	brute_force_zero 1, xmm1
zero	lea	esi, [esi-64]
	movapd	[esi+64+1*16], xmm1	;; Save FFT word
	movapd	xmm2, [esi+64+2*16]	;; Load FFT word
	addpd	xmm2, [ebx+2*16]	;; Add in carries
zero	lea	esi, [esi+64]
zero	brute_force_zero 2, xmm2
zero	lea	esi, [esi-64]
	movapd	[esi+64+2*16], xmm2	;; Save FFT word
	movapd	xmm3, [esi+64+3*16]	;; Load FFT word
	addpd	xmm3, [ebx+3*16]	;; Add in carries
zero	lea	esi, [esi+64]
zero	brute_force_zero 3, xmm3
zero	lea	esi, [esi-64]
	movapd	[esi+64+3*16], xmm3	;; Save FFT word
	ENDM


; *************** 1D normalized add/sub macro ******************
; This macro adds or subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the summed values by
; two-to-minus-phi.  Rounding the value to an integer.  Making sure
; the integer is smaller than the maximum allowable integer, generating
; a carry if necessary. Finally, the value is multiplied by two-to-phi
; and stored.
; xmm3 = carry #2
; xmm2 = carry #1
; ecx = pointer to the first number
; edx = pointer to the second number
; esi = pointer to destination
; ebp = pointer two-to-phi multipliers
; edi = pointer to array of big vs. little flags
; ebx = big vs. little word flag #2
; eax = big vs. little word flag #1
; A pipelined version of this code:
;	mov	al, [edi]		;; Load big vs. little flags
;	movapd	xmm0, [edx+0*dist1]	;; Load second number
;	fop	xmm0, [ecx]		;; Add/sub first number
;	mulpd	xmm0, [ebp+0]		;; Mul values1 by two-to-minus-phi
;	addpd	xmm0, xmm4		;; x = values + carry
;	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
;	addpd	xmm2, xmm0		;; y = top bits of x
;	movapd	xmm6, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
;	addpd	xmm6, xmm2		;; z = y - (maximum * BIGVAL - BIGVAL)
;	subpd	xmm0, xmm6		;; rounded value = x - z
;	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y
;	mulpd	xmm0, [ebp+16]		;; new value = val * two-to-phi
;	movapd	[esi+0*dist1], xmm0	;; Save new value

xnorm_op_1d MACRO fop, numvals, ttp
	IF numvals EQ 8
ttp	mov	al, [edi]		;; Load big vs. little flags
ttp	mov	bl, [edi+2]
	movapd	xmm0, [edx]		;; Load second number
	fop	xmm0, [ecx]		;; Add/sub first number
ttp	mulpd	xmm0, [ebp]		;; Mul values1 by two-to-minus-phi
ttp	mulpd	xmm0, XMM_NORM012_FF	;; Mul by FFTLEN/2
	movapd	xmm1, [edx+32]		;; Load second number
	fop	xmm1, [ecx+32]		;; Add/sub first number
ttp	mulpd	xmm1, [ebp+64]		;; Mul values2 by two-to-minus-phi
ttp	mulpd	xmm1, XMM_NORM012_FF	;; Mul by FFTLEN/2
	addpd	xmm0, xmm2		;; x1 = values + carry
	addpd	xmm1, xmm3		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ebx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ebx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm3, XMM_LIMIT_INVERSE[ebx];; next carry = shifted y2
ttp	mulpd	xmm0, [ebp+16]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebp+80]		;; new value2 = val * two-to-phi
	movapd	[esi], xmm0		;; Save value1
	movapd	[esi+32], xmm1		;; Save value2
ttp	mov	al, [edi+1]		;; Load big vs. little flags
ttp	mov	bl, [edi+3]
	movapd	xmm0, [edx+16]		;; Load values1
	fop	xmm0, [ecx+16]		;; Add/sub first number
ttp	mulpd	xmm0, [ebp+32]		;; Mul values1 by two-to-minus-phi
ttp	mulpd	xmm0, XMM_NORM012_FF	;; Mul by FFTLEN/2
	movapd	xmm1, [edx+48]		;; Load values2
	fop	xmm1, [ecx+48]		;; Add/sub first number
ttp	mulpd	xmm1, [ebp+96]		;; Mul values2 by two-to-minus-phi
ttp	mulpd	xmm1, XMM_NORM012_FF	;; Mul by FFTLEN/2
	addpd	xmm0, xmm2		;; x1 = values + carry
	addpd	xmm1, xmm3		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ebx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ebx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm3, XMM_LIMIT_INVERSE[ebx];; next carry = shifted y2
ttp	mulpd	xmm0, [ebp+48]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebp+112]		;; new value2 = val * two-to-phi
	movapd	[esi+16], xmm0		;; Save new value1
	movapd	[esi+48], xmm1		;; Save new value2
ttp	lea	edi, [edi+4]		;; Next flags ptr
	lea	ecx, [ecx+64]		;; Next src ptr
	lea	edx, [edx+64]		;; Next src ptr
ttp	lea	ebp, [ebp+128]		;; Next two-to-phi ptr
	lea	esi, [esi+64]		;; Next dest ptr
	ENDIF

	IF numvals EQ 4
ttp	mov	al, [edi]		;; Load big vs. little flags
	movapd	xmm0, [edx]		;; Load second number
	fop	xmm0, [ecx]		;; Add/sub first number
ttp	mulpd	xmm0, [ebp]		;; Mul values1 by two-to-minus-phi
ttp	mulpd	xmm0, XMM_NORM012_FF	;; Mul by FFTLEN/2
	addpd	xmm0, xmm2		;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
ttp	mulpd	xmm0, [ebp+16]		;; new value1 = val * two-to-phi
	movapd	[esi], xmm0		;; Save value1
ttp	mov	al, [edi+1]		;; Load big vs. little flags
	movapd	xmm0, [edx+16]		;; Load values1
	fop	xmm0, [ecx+16]		;; Add/sub first number
ttp	mulpd	xmm0, [ebp+32]		;; Mul values1 by two-to-minus-phi
ttp	mulpd	xmm0, XMM_NORM012_FF	;; Mul by FFTLEN/2
	addpd	xmm0, xmm2		;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
ttp	mulpd	xmm0, [ebp+48]		;; new value1 = val * two-to-phi
	movapd	[esi+16], xmm0		;; Save new value1
ttp	lea	edi, [edi+2]		;; Next flags ptr
	lea	ecx, [ecx+64]		;; Next src ptr
	lea	edx, [edx+64]		;; Next src ptr
ttp	lea	ebp, [ebp+64]		;; Next two-to-phi ptr
	lea	esi, [esi+64]		;; Next dest ptr
	ENDIF
	ENDM

xnorm_op_1d_cleanup MACRO
	xnorm_rotate_carries xmm2, xmm3	;; Rotate the carries
	movapd	xmm0, [ecx]		;; Load values1
	movapd	xmm1, [ecx+32]		;; Load values2
	subpd	xmm2, XMM_BIGVAL	;; Remove BIGVAL from carries
	subpd	xmm3, XMM_BIGVAL
	mulpd	xmm2, [ebp+16]		;; carry *= two-to-phi
	mulpd	xmm3, [ebp+80]		;; carry *= two-to-phi
	addpd	xmm0, xmm3		;; value1 = values + carry
	addpd	xmm1, xmm2		;; value2 = values + carry
	movapd	[ecx], xmm0		;; Save new value1
	movapd	[ecx+32], xmm1		;; Save new value2
	ENDM


; *************** 1D normalized add/sub macro ******************
; This macro adds and subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the sum values by
; two-to-minus-phi.  Adding, subtracting and rounding the value to an
; integer.  Make sure the integer is smaller than the maximum allowable
; integer, generating carries if necessary.  Finally, the values are
; multiplied by two-to-phi and stored.
; xmm7 = sub carry #2
; xmm6 = sub carry #1
; xmm3 = add carry #2
; xmm2 = add carry #1
; ecx = pointer to the first number
; edx = pointer to the second number
; esi = pointer to destination #1
; ebp = pointer to destination #2
; ebx = pointer two-to-phi multipliers
; edi = pointer to array of big vs. little flags
; eax = big vs. little word flag #1

xnorm_addsub_1d MACRO numvals, ttp
	IF numvals EQ 8
ttp	mov	al, [edi]		;; Load big vs. little flags
	movapd	xmm0, [ecx]		;; Load first number
	addpd	xmm0, [edx]		;; Add second number
ttp	movapd	xmm5, [ebx]		;; Load fudged two-to-minus-phi
ttp	mulpd	xmm5, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm5		;; Mul values1 by two-to-minus-phi
	movapd	xmm1, [ecx]		;; Load first number
	subpd	xmm1, [edx]		;; Sub second number
ttp	mulpd	xmm1, xmm5		;; Mul values2 by two-to-minus-phi
	addpd	xmm0, xmm2		;; x1 = values + carry
	addpd	xmm1, xmm6		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm6, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm6, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm6		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm6, XMM_LIMIT_INVERSE[eax];; next carry = shifted y2
ttp	mulpd	xmm0, [ebx+16]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebx+16]		;; new value2 = val * two-to-phi
	movapd	[esi], xmm0		;; Save value1
	movapd	[ebp], xmm1		;; Save value2

ttp	mov	al, [edi+2]		;; Load big vs. little flags
	movapd	xmm0, [ecx+32]		;; Load first number
	addpd	xmm0, [edx+32]		;; Add second number
ttp	movapd	xmm5, [ebx+64]		;; Load fudged two-to-minus-phi
ttp	mulpd	xmm5, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm5		;; Mul values1 by two-to-minus-phi
	movapd	xmm1, [ecx+32]		;; Load first number
	subpd	xmm1, [edx+32]		;; Sub second number
ttp	mulpd	xmm1, xmm5		;; Mul values2 by two-to-minus-phi
	addpd	xmm0, xmm3		;; x1 = values + carry
	addpd	xmm1, xmm7		;; x2 = values + carry
	movapd	xmm3, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm0		;; y1 = top bits of x
	movapd	xmm7, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm7, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm7		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm7, XMM_LIMIT_INVERSE[eax];; next carry = shifted y2
ttp	mulpd	xmm0, [ebx+80]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebx+80]		;; new value2 = val * two-to-phi
	movapd	[esi+32], xmm0		;; Save value1
	movapd	[ebp+32], xmm1		;; Save value2

ttp	mov	al, [edi+1]		;; Load big vs. little flags
	movapd	xmm0, [ecx+16]		;; Load first number
	addpd	xmm0, [edx+16]		;; Add second number
ttp	movapd	xmm5, [ebx+32]		;; Load fudged two-to-minus-phi
ttp	mulpd	xmm5, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm5		;; Mul values1 by two-to-minus-phi
	movapd	xmm1, [ecx+16]		;; Load first number
	subpd	xmm1, [edx+16]		;; Sub second number
ttp	mulpd	xmm1, xmm5		;; Mul values2 by two-to-minus-phi
	addpd	xmm0, xmm2		;; x1 = values + carry
	addpd	xmm1, xmm6		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm6, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm6, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm6		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm6, XMM_LIMIT_INVERSE[eax];; next carry = shifted y2
ttp	mulpd	xmm0, [ebx+48]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebx+48]		;; new value2 = val * two-to-phi
	movapd	[esi+16], xmm0		;; Save value1
	movapd	[ebp+16], xmm1		;; Save value2

ttp	mov	al, [edi+3]		;; Load big vs. little flags
	movapd	xmm0, [ecx+48]		;; Load first number
	addpd	xmm0, [edx+48]		;; Add second number
ttp	movapd	xmm5, [ebx+96]		;; Load fudged two-to-minus-phi
ttp	mulpd	xmm5, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm5		;; Mul values1 by two-to-minus-phi
	movapd	xmm1, [ecx+48]		;; Load first number
	subpd	xmm1, [edx+48]		;; Sub second number
ttp	mulpd	xmm1, xmm5		;; Mul values2 by two-to-minus-phi
	addpd	xmm0, xmm3		;; x1 = values + carry
	addpd	xmm1, xmm7		;; x2 = values + carry
	movapd	xmm3, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm0		;; y1 = top bits of x
	movapd	xmm7, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm7, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm7		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm7, XMM_LIMIT_INVERSE[eax];; next carry = shifted y2
ttp	mulpd	xmm0, [ebx+112]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebx+112]		;; new value2 = val * two-to-phi
	movapd	[esi+48], xmm0		;; Save value1
	movapd	[ebp+48], xmm1		;; Save value2

ttp	lea	edi, [edi+4]		;; Next flags ptr
	lea	ecx, [ecx+64]		;; Next src ptr
	lea	edx, [edx+64]		;; Next src ptr
ttp	lea	ebx, [ebx+128]		;; Next two-to-phi ptr
	lea	esi, [esi+64]		;; Next dest ptr
	lea	ebp, [ebp+64]		;; Next dest ptr
	ENDIF

	IF numvals EQ 4
ttp	mov	al, [edi]		;; Load big vs. little flags
	movapd	xmm0, [ecx]		;; Load first number
	addpd	xmm0, [edx]		;; Add second number
ttp	movapd	xmm5, [ebx]		;; Load fudged two-to-minus-phi
ttp	mulpd	xmm5, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm5		;; Mul values1 by two-to-minus-phi
	movapd	xmm1, [ecx]		;; Load first number
	subpd	xmm1, [edx]		;; Sub second number
ttp	mulpd	xmm1, xmm5		;; Mul values2 by two-to-minus-phi
	addpd	xmm0, xmm2		;; x1 = values + carry
	addpd	xmm1, xmm6		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm6, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm6, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm6		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm6, XMM_LIMIT_INVERSE[eax];; next carry = shifted y2
ttp	mulpd	xmm0, [ebx+16]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebx+16]		;; new value2 = val * two-to-phi
	movapd	[esi], xmm0		;; Save value1
	movapd	[ebp], xmm1		;; Save value2

ttp	mov	al, [edi+1]		;; Load big vs. little flags
	movapd	xmm0, [ecx+16]		;; Load first number
	addpd	xmm0, [edx+16]		;; Add second number
ttp	movapd	xmm5, [ebx+32]		;; Load fudged two-to-minus-phi
ttp	mulpd	xmm5, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm5		;; Mul values1 by two-to-minus-phi
	movapd	xmm1, [ecx+16]		;; Load first number
	subpd	xmm1, [edx+16]		;; Sub second number
ttp	mulpd	xmm1, xmm5		;; Mul values2 by two-to-minus-phi
	addpd	xmm0, xmm2		;; x1 = values + carry
	addpd	xmm1, xmm6		;; x2 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm6, XMM_LIMIT_BIGMAX[eax];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm6, xmm1		;; y2 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[eax];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm6		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[eax];; next carry = shifted y1
	subpd	xmm1, xmm5		;; rounded value = x2 - z2
	mulpd	xmm6, XMM_LIMIT_INVERSE[eax];; next carry = shifted y2
ttp	mulpd	xmm0, [ebx+48]		;; new value1 = val * two-to-phi
ttp	mulpd	xmm1, [ebx+48]		;; new value2 = val * two-to-phi
	movapd	[esi+16], xmm0		;; Save value1
	movapd	[ebp+16], xmm1		;; Save value2

ttp	lea	edi, [edi+2]		;; Next flags ptr
	lea	ecx, [ecx+64]		;; Next src ptr
	lea	edx, [edx+64]		;; Next src ptr
ttp	lea	ebx, [ebx+64]		;; Next two-to-phi ptr
	lea	esi, [esi+64]		;; Next dest ptr
	lea	ebp, [ebp+64]		;; Next dest ptr
	ENDIF
	ENDM

xnorm_addsub_1d_cleanup MACRO
	xnorm_rotate_carries xmm2, xmm3	;; Rotate the carries
	movapd	xmm0, [esi]		;; Load values1
	movapd	xmm1, [esi+32]		;; Load values2
	subpd	xmm2, XMM_BIGVAL	;; Remove BIGVAL from carries
	subpd	xmm3, XMM_BIGVAL
	mulpd	xmm2, [ebx+16]		;; carry *= two-to-phi
	mulpd	xmm3, [ebx+80]		;; carry *= two-to-phi
	addpd	xmm0, xmm3		;; value1 = values + carry
	addpd	xmm1, xmm2		;; value2 = values + carry
	movapd	[esi], xmm0		;; Save new value1
	movapd	[esi+32], xmm1		;; Save new value2

	xnorm_rotate_carries xmm6, xmm7	;; Rotate the carries
	movapd	xmm0, [ebp]		;; Load values1
	movapd	xmm1, [ebp+32]		;; Load values2
	subpd	xmm6, XMM_BIGVAL	;; Remove BIGVAL from carries
	subpd	xmm7, XMM_BIGVAL
	mulpd	xmm6, [ebx+16]		;; carry *= two-to-phi
	mulpd	xmm7, [ebx+80]		;; carry *= two-to-phi
	addpd	xmm0, xmm7		;; value1 = values + carry
	addpd	xmm1, xmm6		;; value2 = values + carry
	movapd	[ebp], xmm0		;; Save new value1
	movapd	[ebp+32], xmm1		;; Save new value2
	ENDM



; *************** 2D normalized add/sub macro ******************
; This macro adds or subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the summed values by
; two-to-minus-phi.  Rounding the value to an integer.  Making sure
; the integer is smaller than the maximum allowable integer, generating
; a carry if necessary. Finally, the value is multiplied by two-to-phi
; and stored.
; ecx = pointer to the first number
; edx = pointer to the second number
; esi = pointer to destination
; ebp = pointer to carries
; edi = pointer to array of big vs. little flags
; ebx = pointer to two-to-phi column multipliers
; eax = pointer two-to-phi group multipliers
; A pipelined version of this code:
;	movapd	xmm0, [edx]		;; Load second number
;	fop	xmm0, [ecx]		;; Add/sub first number
;	push	ecx
;	sub	ecx, ecx
;	mov	cl, [edi]		;; Load big vs. little flags
;	movapd	xmm2, [ebx]		;; col two-to-minus-phi
;	mulpd	xmm2, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
;	mulpd	xmm0, [eax]		;; Mul by grp two-to-minus-phi
;	mulpd	xmm0, xmm2		;; Mul by fudged col two-to-minus-phi
;	addpd	xmm0, [ebp+0*16]	;; x1 = values + carry
;	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
;	addpd	xmm2, xmm0		;; y1 = top bits of x
;	movapd	xmm6, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
;	addpd	xmm6, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
;	subpd	xmm0, xmm6		;; rounded value = x1 - z1
;	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
;	movapd	xmm4, [ebx]		;; col two-to-phi
;	mulpd	xmm4, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
;	mulpd	xmm0, [eax+0*32+16]	;; new value1 = val * grp two-to-phi
;	mulpd	xmm0, xmm4		;; new value1 *= fudged col two-to-phi
;	movapd	[esi+0*dist1], xmm0	;; Save new value1
;	movapd	[ebp+0*16], xmm2	;; Save carry
;	pop	ecx

xnorm_op_2d MACRO fop, ttp
	movapd	xmm0, [edx]		;; Load second number
	fop	xmm0, [ecx]		;; Add/sub first number
ttp	movapd	xmm2, [ebx]		;; Col two-to-minus-phi
ttp	mulpd	xmm2, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm2		;; Mul values1 by col two-to-minus-phi
	movapd	xmm1, [edx+16]		;; Load second number
	fop	xmm1, [ecx+16]		;; Add/sub first number
ttp	mulpd	xmm1, xmm2		;; Mul values2 by col two-to-minus-phi
	movapd	xmm6, [edx+32]		;; Load second number
	fop	xmm6, [ecx+32]		;; Add/sub first number
ttp	mulpd	xmm6, xmm2		;; Mul values3 by col two-to-minus-phi
	movapd	xmm7, [edx+48]		;; Load second number
	fop	xmm7, [ecx+48]		;; Add/sub first number
ttp	mulpd	xmm7, xmm2		;; Mul values4 by col two-to-minus-phi
	push	ecx
	push	edx
	mov	ecx, 48			;; Rational FFTs are all big words
	mov	edx, 48
ttp	mov	cl, [edi]		;; Load big vs. little flags
ttp	mov	dl, [edi+1]
ttp	mulpd	xmm0, [eax+0*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm0, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm0, [ebp+0*16]	;; x1 = values + carry
ttp	mulpd	xmm1, [eax+1*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm1, XMM_TTMP_FUDGE[edx];; Mul by fudge two-to-minus-phi
	addpd	xmm1, [ebp+1*16]	;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[edx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[edx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[ebp+0*16], xmm2	;; Save carry
	subpd	xmm1, xmm5		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[edx];; next carry = shifted y1
	movapd	[ebp+1*16], xmm3	;; Save carry
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm0, [eax+0*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm0, xmm2		;; new value1 *= fudged col two-to-phi
	movapd	[esi+0*16], xmm0	;; Save new value1
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[edx];; mul by fudge two-to-phi
ttp	mulpd	xmm1, [eax+1*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm1, xmm3		;; new value1 *= fudged col two-to-phi
	movapd	[esi+1*16], xmm1	;; Save new value1

ttp	mov	cl, [edi+2]		;; Load big vs. little flags
ttp	mov	dl, [edi+3]
ttp	mulpd	xmm6, [eax+2*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm6, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm6, [ebp+2*16]	;; x1 = values + carry
ttp	mulpd	xmm7, [eax+3*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm7, XMM_TTMP_FUDGE[edx];; Mul by fudge two-to-minus-phi
	addpd	xmm7, [ebp+3*16]	;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm6		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[edx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm7		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[edx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm6, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[ebp+2*16], xmm2	;; Save carry
	subpd	xmm7, xmm5		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[edx];; next carry = shifted y1
	movapd	[ebp+3*16], xmm3	;; Save carry
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm6, [eax+2*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm6, xmm2		;; new value1 *= fudged col two-to-phi
	movapd	[esi+2*16], xmm6	;; Save new value1
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[edx];; mul by fudge two-to-phi
ttp	mulpd	xmm7, [eax+3*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm7, xmm3		;; new value1 *= fudged col two-to-phi
	movapd	[esi+3*16], xmm7	;; Save new value1
	pop	edx
	pop	ecx
ttp	lea	edi, [edi+4]		;; Next flags ptr
ttp	lea	ebx, [ebx+32]		;; Next column two-to-phi ptr
	lea	esi, [esi+64]		;; Next dest ptr
	lea	edx, [edx+64]		;; Next src ptr
	lea	ecx, [ecx+64]		;; Next src ptr
	ENDM

; *************** 2D followup macro ******************
; This macro finishes the normalize add/sub process by adding the final carries
; back into the appropriate FFT values.
; esi = pointer to carries
; ebp = pointer to FFT data
; edi = pointer to big/little flags
; ebx = pointer two-to-power column multipliers
; edx = pointer two-to-power group multipliers
; eax = big vs. little word flag #1
; xmm6 = XMM_BIGVAL
; xmm7 preserved

xnorm_op012_2d MACRO
	mov	al, [edi+0]		;; Load big vs. little flag
	movhpd	xmm0, [esi+0*16]	;; Load high word of carry XMM reg
	subpd	xmm0, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+0*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm0		;; carry *= two-to-phi
	_movsd	xmm0, [esi+0*16+8]	;; Load carry for next row
	addpd	xmm4, [ebp+0*16]	;; Add in FFT data
	movapd	[ebp+0*16], xmm4	;; Save FFT word
	movapd	[esi+0*16], xmm6	;; Reset carry

	mov	al, [edi+1]		;; Load big vs. little flag
	movhpd	xmm1, [esi+1*16]	;; Load high word of carry XMM reg
	subpd	xmm1, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+1*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm1		;; carry *= two-to-phi
	_movsd	xmm1, [esi+1*16+8]	;; Load carry for next row
	addpd	xmm4, [ebp+1*16]	;; Add in FFT data
	movapd	[ebp+1*16], xmm4	;; Save FFT word
	movapd	[esi+1*16], xmm6	;; Reset carry

	mov	al, [edi+2]		;; Load big vs. little flag
	movhpd	xmm2, [esi+2*16]	;; Load high word of carry XMM reg
	subpd	xmm2, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+2*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm2		;; carry *= two-to-phi
	_movsd	xmm2, [esi+2*16+8]	;; Load carry for next row
	addpd	xmm4, [ebp+2*16]	;; Add in FFT data
	movapd	[ebp+2*16], xmm4	;; Save FFT word
	movapd	[esi+2*16], xmm6	;; Reset carry

	mov	al, [edi+3]		;; Load big vs. little flag
	movhpd	xmm3, [esi+3*16]	;; Load high word of carry XMM reg
	subpd	xmm3, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+3*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm3		;; carry *= two-to-phi
	_movsd	xmm3, [esi+3*16+8]	;; Load carry for next row
	addpd	xmm4, [ebp+3*16]	;; Add in FFT data
	movapd	[ebp+3*16], xmm4	;; Save FFT word
	movapd	[esi+3*16], xmm6	;; Reset carry
	ENDM

; *************** 2D normalized add & sub macro ******************
; This macro adds and subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the summed values by
; two-to-minus-phi.  Rounding the value to an integer.  Making sure
; the integer is smaller than the maximum allowable integer, generating
; a carry if necessary. Finally, the value is multiplied by two-to-phi
; and stored.
; ecx = pointer to the first number
; edx = pointer to the second number
; esi = pointer to destination #1
; ebp = pointer to destination #2
; eax = pointer to carries
; edi = pointer to array of big vs. little flags
; ebx = pointer to two-to-phi column multipliers
; normgrpptr = pointer two-to-phi group multipliers

xnorm_addsub_2d MACRO ttp
	movapd	xmm1, [ecx+0*16]	;; Load first number
	movapd	xmm0, [edx+0*16]	;; Load second number
	subpd	xmm1, xmm0		;; first - second number
	addpd	xmm0, [ecx+0*16]	;; first + second number
ttp	movapd	xmm2, [ebx]		;; Col two-to-minus-phi
ttp	mulpd	xmm2, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm2		;; Mul values1 by col two-to-minus-phi
ttp	mulpd	xmm1, xmm2		;; Mul values1 by col two-to-minus-phi

	movapd	xmm7, [ecx+1*16]	;; Load first number
	movapd	xmm6, [edx+1*16]	;; Load second number
	subpd	xmm7, xmm6		;; first - second number
	addpd	xmm6, [ecx+1*16]	;; first + second number
ttp	mulpd	xmm6, xmm2		;; Mul values1 by col two-to-minus-phi
ttp	mulpd	xmm7, xmm2		;; Mul values1 by col two-to-minus-phi

	push	ecx
	push	edx
	mov	ecx, 48			;; Rational FFTs are all big words
	mov	edx, normgrpptr

ttp	mov	cl, [edi+0]		;; Load big vs. little flags
ttp	mulpd	xmm0, [edx+0*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm0, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm0, [eax+0*32+0]	;; x1 = values + carry
ttp	mulpd	xmm1, [edx+0*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm1, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm1, [eax+0*32+16]	;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+0*32+0], xmm2	;; Save carry
	subpd	xmm1, xmm5		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+0*32+16], xmm3	;; Save carry
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm0, [edx+0*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm0, xmm2		;; new value1 *= fudged col two-to-phi
	movapd	[esi+0*16], xmm0	;; Save new value1
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm1, [edx+0*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm1, xmm3		;; new value1 *= fudged col two-to-phi
	movapd	[ebp+0*16], xmm1	;; Save new value1

ttp	mov	cl, [edi+1]		;; Load big vs. little flags
ttp	mulpd	xmm6, [edx+1*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm6, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm6, [eax+1*32+0]	;; x1 = values + carry
ttp	mulpd	xmm7, [edx+1*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm7, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm7, [eax+1*32+16]	;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm6		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm7		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm6, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+1*32+0], xmm2	;; Save carry
	subpd	xmm7, xmm5		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+1*32+16], xmm3	;; Save carry
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm6, [edx+1*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm6, xmm2		;; new value1 *= fudged col two-to-phi
	movapd	[esi+1*16], xmm6	;; Save new value1
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm7, [edx+1*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm7, xmm3		;; new value1 *= fudged col two-to-phi
	movapd	[ebp+1*16], xmm7	;; Save new value1

	pop	edx
	pop	ecx

	movapd	xmm1, [ecx+2*16]	;; Load first number
	movapd	xmm0, [edx+2*16]	;; Load second number
	subpd	xmm1, xmm0		;; first - second number
	addpd	xmm0, [ecx+2*16]	;; first + second number
ttp	movapd	xmm2, [ebx]		;; Col two-to-minus-phi
ttp	mulpd	xmm2, XMM_NORM012_FF	;; Mul by FFTLEN/2
ttp	mulpd	xmm0, xmm2		;; Mul values1 by col two-to-minus-phi
ttp	mulpd	xmm1, xmm2		;; Mul values1 by col two-to-minus-phi

	movapd	xmm7, [ecx+3*16]	;; Load first number
	movapd	xmm6, [edx+3*16]	;; Load second number
	subpd	xmm7, xmm6		;; first - second number
	addpd	xmm6, [ecx+3*16]	;; first + second number
ttp	mulpd	xmm6, xmm2		;; Mul values1 by col two-to-minus-phi
ttp	mulpd	xmm7, xmm2		;; Mul values1 by col two-to-minus-phi

	push	ecx
	push	edx
	mov	ecx, 48			;; Rational FFTs are all big words
	mov	edx, normgrpptr

ttp	mov	cl, [edi+2]		;; Load big vs. little flags
ttp	mulpd	xmm0, [edx+2*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm0, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm0, [eax+2*32+0]	;; x1 = values + carry
ttp	mulpd	xmm1, [edx+2*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm1, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm1, [eax+2*32+16]	;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm0		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm1		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm0, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+2*32+0], xmm2	;; Save carry
	subpd	xmm1, xmm5		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+2*32+16], xmm3	;; Save carry
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm0, [edx+2*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm0, xmm2		;; new value1 *= fudged col two-to-phi
	movapd	[esi+2*16], xmm0	;; Save new value1
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm1, [edx+2*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm1, xmm3		;; new value1 *= fudged col two-to-phi
	movapd	[ebp+2*16], xmm1	;; Save new value1

ttp	mov	cl, [edi+3]		;; Load big vs. little flags
ttp	mulpd	xmm6, [edx+3*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm6, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm6, [eax+3*32+0]	;; x1 = values + carry
ttp	mulpd	xmm7, [edx+3*32]	;; Mul by grp two-to-minus-phi
ttp	mulpd	xmm7, XMM_TTMP_FUDGE[ecx];; Mul by fudge two-to-minus-phi
	addpd	xmm7, [eax+3*32+16]	;; x1 = values + carry
	movapd	xmm2, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm2, xmm6		;; y1 = top bits of x
	movapd	xmm3, XMM_LIMIT_BIGMAX[ecx];; Load maximum * BIGVAL - BIGVAL
	addpd	xmm3, xmm7		;; y1 = top bits of x
	movapd	xmm4, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm4, xmm2		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	movapd	xmm5, XMM_LIMIT_BIGMAX_NEG[ecx];; Load -(maximum*BIGVAL-BIGVAL)
	addpd	xmm5, xmm3		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	subpd	xmm6, xmm4		;; rounded value = x1 - z1
	mulpd	xmm2, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+3*32+0], xmm2	;; Save carry
	subpd	xmm7, xmm5		;; rounded value = x1 - z1
	mulpd	xmm3, XMM_LIMIT_INVERSE[ecx];; next carry = shifted y1
	movapd	[eax+3*32+16], xmm3	;; Save carry
ttp	movapd	xmm2, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm2, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm6, [edx+3*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm6, xmm2		;; new value1 *= fudged col two-to-phi
	movapd	[esi+3*16], xmm6	;; Save new value1
ttp	movapd	xmm3, [ebx+16]		;; col two-to-phi
ttp	mulpd	xmm3, XMM_TTP_FUDGE[ecx];; mul by fudge two-to-phi
ttp	mulpd	xmm7, [edx+3*32+16]	;; new value1 = val * grp two-to-phi
ttp	mulpd	xmm7, xmm3		;; new value1 *= fudged col two-to-phi
	movapd	[ebp+3*16], xmm7	;; Save new value1

	pop	edx
	pop	ecx

	lea	edx, [edx+64]		;; Next src ptr
	lea	ecx, [ecx+64]		;; Next src ptr
ttp	lea	edi, [edi+4]		;; Next flags ptr
ttp	lea	ebx, [ebx+32]		;; Next column two-to-phi ptr
	lea	esi, [esi+64]		;; Next dest ptr
	lea	ebp, [ebp+64]		;; Next dest ptr
	ENDM

xnorm_as012_2d_part1 MACRO
	LOCAL	signok
	_movsd	xmm7, [ebp-24]		; Load very last carry #1
	_movsd	xmm5, [ebp-8]		; Load very last carry #2
	cmp	_PLUS1, 0		; See if sign needs to change
	jz	short signok
	subsd	xmm7, XMM_BIGVAL	; Negate the carry
	xorpd	xmm7, XMM_NEGATE_LSW
	addsd	xmm7, XMM_BIGVAL
	subsd	xmm5, XMM_BIGVAL	; Negate the carry
	xorpd	xmm5, XMM_NEGATE_LSW
	addsd	xmm5, XMM_BIGVAL
signok:	_movsd	XMM_TMP1, xmm5
	ENDM
xnorm_as012_2d_part2 MACRO
	_movsd	xmm0, xmm7		; Copy last carries from prev section
	_movsd	xmm1, [ebx-120]		; Load first 3 carries in this section
	_movsd	xmm2, [ebx-88]
	_movsd	xmm3, [ebx-56]
	_movsd	xmm5, XMM_TMP1		; Do same for dest #2 carries
	_movsd	XMM_TMP2, xmm5
	_movsd	xmm5, [ebx-104]
	_movsd	XMM_TMP2+8, xmm5
	_movsd	xmm5, [ebx-72]
	_movsd	XMM_TMP3, xmm5
	_movsd	xmm5, [ebx-40]
	_movsd	XMM_TMP3+8, xmm5
	_movsd	xmm7, [ebx-24]		; Remember last carry for next section
	_movsd	xmm5, [ebx-8]
	_movsd	XMM_TMP1, xmm5
	ENDM

xnorm_as012_2d MACRO
	mov	al, [edi+0]		;; Load big vs. little flag
	movhpd	xmm0, [esi+0*32]	;; Load high word of carry XMM reg
	subpd	xmm0, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+0*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm0		;; carry *= two-to-phi
	_movsd	xmm0, [esi+0*32+8]	;; Load carry for next row
	addpd	xmm4, [ebp+0*16]	;; Add in FFT data
	movapd	[ebp+0*16], xmm4	;; Save FFT word
	movapd	[esi+0*32], xmm6	;; Reset carry

	movlpd	xmm5, XMM_TMP2		;; Load saved carry for dest #2
	movhpd	xmm5, [esi+0*32+16]	;; Load high word of carry XMM reg
	subpd	xmm5, xmm6
	_movsd	xmm4, [esi+0*32+24]	;; Load carry for next row
	_movsd	XMM_TMP2, xmm4
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+0*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm5		;; carry *= two-to-phi
	addpd	xmm4, [ecx+0*16]	;; Add in FFT data
	movapd	[ecx+0*16], xmm4	;; Save FFT word
	movapd	[esi+0*32+16], xmm6	;; Reset carry

	mov	al, [edi+1]		;; Load big vs. little flag
	movhpd	xmm1, [esi+1*32]	;; Load high word of carry XMM reg
	subpd	xmm1, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+1*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm1		;; carry *= two-to-phi
	_movsd	xmm1, [esi+1*32+8]	;; Load carry for next row
	addpd	xmm4, [ebp+1*16]	;; Add in FFT data
	movapd	[ebp+1*16], xmm4	;; Save FFT word
	movapd	[esi+1*32], xmm6	;; Reset carry

	movlpd	xmm5, XMM_TMP2+8	;; Load saved carry for dest #2
	movhpd	xmm5, [esi+1*32+16]	;; Load high word of carry XMM reg
	subpd	xmm5, xmm6
	_movsd	xmm4, [esi+1*32+24]	;; Load carry for next row
	_movsd	XMM_TMP2+8, xmm4
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+1*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm5		;; carry *= two-to-phi
	addpd	xmm4, [ecx+1*16]	;; Add in FFT data
	movapd	[ecx+1*16], xmm4	;; Save FFT word
	movapd	[esi+1*32+16], xmm6	;; Reset carry

	mov	al, [edi+2]		;; Load big vs. little flag
	movhpd	xmm2, [esi+2*32]	;; Load high word of carry XMM reg
	subpd	xmm2, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+2*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm2		;; carry *= two-to-phi
	_movsd	xmm2, [esi+2*32+8]	;; Load carry for next row
	addpd	xmm4, [ebp+2*16]	;; Add in FFT data
	movapd	[ebp+2*16], xmm4	;; Save FFT word
	movapd	[esi+2*32], xmm6	;; Reset carry

	movlpd	xmm5, XMM_TMP3		;; Load saved carry for dest #2
	movhpd	xmm5, [esi+2*32+16]	;; Load high word of carry XMM reg
	subpd	xmm5, xmm6
	_movsd	xmm4, [esi+2*32+24]	;; Load carry for next row
	_movsd	XMM_TMP3, xmm4
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+2*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm5		;; carry *= two-to-phi
	addpd	xmm4, [ecx+2*16]	;; Add in FFT data
	movapd	[ecx+2*16], xmm4	;; Save FFT word
	movapd	[esi+2*32+16], xmm6	;; Reset carry

	mov	al, [edi+3]		;; Load big vs. little flag
	movhpd	xmm3, [esi+3*32]	;; Load high word of carry XMM reg
	subpd	xmm3, xmm6
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+3*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm3		;; carry *= two-to-phi
	_movsd	xmm3, [esi+3*32+8]	;; Load carry for next row
	addpd	xmm4, [ebp+3*16]	;; Add in FFT data
	movapd	[ebp+3*16], xmm4	;; Save FFT word
	movapd	[esi+3*32], xmm6	;; Reset carry

	movlpd	xmm5, XMM_TMP3+8	;; Load saved carry for dest #2
	movhpd	xmm5, [esi+3*32+16]	;; Load high word of carry XMM reg
	subpd	xmm5, xmm6
	_movsd	xmm4, [esi+3*32+24]	;; Load carry for next row
	_movsd	XMM_TMP3+8, xmm4
	movapd	xmm4, [ebx+16]		;; col two-to-phi
	mulpd	xmm4, XMM_TTP_FUDGE[eax];; mul by fudge two-to-phi
	mulpd	xmm4, [edx+3*32+16]	;; mul by grp two-to-phi
	mulpd	xmm4, xmm5		;; carry *= two-to-phi
	addpd	xmm4, [ecx+3*16]	;; Add in FFT data
	movapd	[ecx+3*16], xmm4	;; Save FFT word
	movapd	[esi+3*32+16], xmm6	;; Reset carry
	ENDM


; *************** no-array proth mod macro ******************
; This macro aids in computing the FFT value mod k*2^n+/-1.
; The upper part of the FFT is divided by k for later addition
; (or subtraction) into the lower part of the FFT.
; st(5) = BIGVAL
; st(4) = limit_high
; st(3) = prothshift
; st(2) = 1/k
; st(1) = k
; st(0) = carry
; esi = source
; edi = destination (the proth scrath area)

prothmod_upper_prep_0d MACRO donelabel
	mov	edi, DWORD PTR _PROTHVALS+11*8 ;; Address of scratch area
	fldz
	fst	QWORD PTR [edi+0*8]	;; pad scratch area
	fst	QWORD PTR [edi+1*8]	;; pad scratch area
	fst	QWORD PTR [edi+2*8]	;; pad scratch area
	fst	QWORD PTR [edi+3*8]	;; pad scratch area
	fst	QWORD PTR [edi+4*8]	;; pad scratch area
	fst	QWORD PTR [edi+5*8]	;; pad scratch area
	fst	QWORD PTR [edi+6*8]	;; pad scratch area
	fst	QWORD PTR [edi+7*8]	;; pad scratch area
	fst	QWORD PTR [edi+8*8]	;; pad scratch area
	fst	QWORD PTR [edi+9*8]	;; pad scratch area
	fst	QWORD PTR [edi+10*8]	;; pad scratch area
	fstp	QWORD PTR [edi+11*8]	;; pad scratch area
	lea	edi, [edi+12*8]
	fld	BIGVAL
	fld	limit_high
	fld	_PROTHVALS+2*8		;; st(3) = prothshift
	fld	_PROTHVALS+1*8		;; st(2) = 1/k
	fld	_PROTHVALS+0*8		;; st(1) = k
	fldz				;; st(0) = initial carry
	add	esi, DWORD PTR _PROTHVALS+3*8 ;; Point to last FFT word
	mov	edx, DWORD PTR _PROTHVALS+4*8 ;; Count of upper FFT words
	ENDM

prothmod_upper_0d MACRO d1, d2, d4, donelabel
	LOCAL	p1, p2, p3, p4, p5, p6, p7, p8

	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi]		;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+0*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p1		;; no
	fstp	QWORD PTR [esi]		;; save remainder
	lea	edi, [edi+0*8]
	JMP_X	donelabel

p1:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d1]	;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d1]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+1*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p2		;; no
	fstp	QWORD PTR [esi-d1]	;; save remainder
	lea	edi, [edi+1*8]
	JMP_X	donelabel

p2:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d2]	;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d2]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+2*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p3		;; no
	fstp	QWORD PTR [esi-d2]	;; save remainder
	lea	edi, [edi+2*8]
	JMP_X	donelabel

p3:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d2-d1]	;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d2-d1]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+3*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p4		;; no
	fstp	QWORD PTR [esi-d2-d1]	;; save remainder
	lea	edi, [edi+3*8]
	JMP_X	donelabel

p4:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d4]	;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d4]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+4*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p5		;; no
	fstp	QWORD PTR [esi-d4]	;; save remainder
	lea	edi, [edi+4*8]
	JMP_X	donelabel

p5:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d4-d1]	;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d4-d1]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+5*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p6		;; no
	fstp	QWORD PTR [esi-d4-d1]	;; save remainder
	lea	edi, [edi+5*8]
	JMP_X	donelabel

p6:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d4-d2]	;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d4-d2]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+6*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p7		;; no
	fstp	QWORD PTR [esi-d4-d2]	;; save remainder
	lea	edi, [edi+6*8]
	JMP_X	donelabel

p7:	fmul	st, st(4)		;; carry * limit_high
	fadd	QWORD PTR [esi-d4-d2-d1];; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear source fft value
	fstp	QWORD PTR [esi-d4-d2-d1]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+7*8]	;; save shifted quotient
	dec	edx			;; done yet?
	jnz	short p8		;; no
	fstp	QWORD PTR [esi-d4-d2-d1];; save remainder
	lea	edi, [edi+7*8]
	JMP_X	donelabel
p8:
	ENDM

prothmod_lower_prep_0d MACRO
	fcompp				;; Pop 5 values
	fcompp
	fcomp	st(0)
	mov	esi, _SRCARG		;; Address of first number
	mov	edx, DWORD PTR _PROTHVALS+5*8 ;; Count of lower FFT 8 word sets
	_movsd	xmm1, XMM_BIGVAL	;; Initial carry is zero
	_movsd	xmm5, XMM_LIMIT_BIGMAX+16 ;; Load maximum * BIGVAL - BIGVAL
	_movsd	xmm6, XMM_LIMIT_BIGMAX_NEG+16;; Load -(maximum*BIGVAL-BIGVAL)
	_movsd	xmm7, XMM_LIMIT_INVERSE+16 ;; Load limit_inverse_high
	ENDM


; *************** no-array proth mod macro ******************
; This macro aids in computing the FFT value mod k*2^n+/-1.
; The upper part of the FFT is divided by k for later addition
; (or subtraction) into the lower part of the FFT.
; xmm1 = carry
; xmm5 = limit_bigmax_high
; xmm6 = - limit_bigmax_high
; xmm7 = limit_inverse_high
; esi = source
; edi = source #2 (the proth scrath area)

prothmod_lower_0d MACRO d1, d2, d4
	_movsd	xmm0, [esi]		;; Load value
	addsd	xmm0, [edi-0*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi], xmm0		;; Save new value

	_movsd	xmm0, [esi+d1]		;; Load value
	addsd	xmm0, [edi-1*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d1], xmm0		;; Save new value

	_movsd	xmm0, [esi+d2]		;; Load value
	addsd	xmm0, [edi-2*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d2], xmm0		;; Save new value

	_movsd	xmm0, [esi+d2+d1]	;; Load value
	addsd	xmm0, [edi-3*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d2+d1], xmm0	;; Save new value

	_movsd	xmm0, [esi+d4]		;; Load value
	addsd	xmm0, [edi-4*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d4], xmm0		;; Save new value

	_movsd	xmm0, [esi+d4+d1]	;; Load value
	addsd	xmm0, [edi-5*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d4+d1], xmm0	;; Save new value

	_movsd	xmm0, [esi+d4+d2]	;; Load value
	addsd	xmm0, [edi-6*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d4+d2], xmm0	;; Save new value

	_movsd	xmm0, [esi+d4+d2+d1]	;; Load value
	addsd	xmm0, [edi-7*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d4+d2+d1], xmm0	;; Save new value
	ENDM

; *************** no-array proth mod macro ******************
; The final step in computing the FFT value mod k*2^n+/-1.
; This is just like the above macros except that it redoes
; the final 5 values to handle carries that occured.

prothmod_final_0d MACRO d1, d2, d4
	fld	BIGVAL
	fld	limit_high
	fld	_PROTHVALS+2*8		;; st(3) = prothshift
	fld	_PROTHVALS+1*8		;; st(2) = 1/k
	fld	_PROTHVALS+0*8		;; st(1) = k
	mov	esi, _SRCARG
	add	esi, DWORD PTR _PROTHVALS+6*8 ;; Point to 5th upper FFT word
	fld	QWORD PTR [esi]		;; Load 5th upper fft value
	fldz				;; Clear 5th upper fft value
	fstp	QWORD PTR [esi]

	fmul	st, st(4)		;; carry * limit_high
	mov	esi, _SRCARG
	add	esi, DWORD PTR _PROTHVALS+7*8 ;; Point to 4th upper FFT word
	fadd	QWORD PTR [esi]		;; add in 4th upper fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear 4th upper fft value
	fstp	QWORD PTR [esi]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+0*8]	;; save shifted quotient

	fmul	st, st(4)		;; carry * limit_high
	mov	esi, _SRCARG
	add	esi, DWORD PTR _PROTHVALS+8*8 ;; Point to 3rd upper FFT word
	fadd	QWORD PTR [esi]		;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fldz				;; Clear 3rd upper fft value
	fstp	QWORD PTR [esi]
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+1*8]	;; save shifted quotient

	fmul	st, st(4)		;; carry * limit_high
	mov	edx, _SRCARG
	add	edx, DWORD PTR _PROTHVALS+9*8 ;; Point to 2nd upper FFT word
	fadd	QWORD PTR [edx]		;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+2*8]	;; save shifted quotient

	fmul	st, st(4)		;; carry * limit_high
	mov	esi, _SRCARG
	add	esi, DWORD PTR _PROTHVALS+10*8 ;; Point to 1st upper FFT word
	fadd	QWORD PTR [esi]		;; add in fft value
	fld	st(2)			;; Load 1/k
	fmul	st, st(1)		;; mul by 1/k
	fadd	st, st(6)		;; round quotient to an integer
	fsub	st, st(6)		;; round quotient to an integer
	fld	st(2)
	fmul	st, st(1)		;; mul by k
	fsubp	st(2), st		;; remainder = next carry
	fmul	st, st(4)		;; shift quotient for later
	fstp	QWORD PTR [edi+3*8]	;; save shifted quotient
	fstp	QWORD PTR [edi+4*8]	;; save remainder

					;; Split the remainder
	_movsd	xmm0, [edi+4*8]
	addsd	xmm0, XMM_BIGVAL	;; Add in BIGVAL
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi], xmm0		;; Lower bits in 1st upper FFT word
	subsd	xmm1, XMM_BIGVAL	;; Subtract out BIGVAL
	_movsd	[edx], xmm1		;; Upper bits in 2nd upper FFT word

	fcompp				;; Pop 5 values
	fcompp
	fcomp	st(0)
	mov	esi, _SRCARG		;; Reload source pointer
	_movsd	xmm1, XMM_BIGVAL	;; Zero initial carry

	_movsd	xmm0, [esi]		;; Load value
	addsd	xmm0, [edi+3*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi], xmm0		;; Save new value

	_movsd	xmm0, [esi+d1]		;; Load value
	addsd	xmm0, [edi+2*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d1], xmm0		;; Save new value

	_movsd	xmm0, [esi+d2]		;; Load value
	addsd	xmm0, [edi+1*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d2], xmm0		;; Save new value

	_movsd	xmm0, [esi+d2+d1]	;; Load value
	addsd	xmm0, [edi+0*8]		;; Add in second value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d2+d1], xmm0	;; Save new value

	_movsd	xmm0, [esi+d4]		;; Load value
	addsd	xmm0, xmm1		;; x = value + carry
	_movsd	xmm1, xmm5		;; Load maximum * BIGVAL - BIGVAL
	addsd	xmm1, xmm0		;; y = top bits of x
	_movsd	xmm2, xmm6		;; Load - (maximum * BIGVAL - BIGVAL)
	addsd	xmm2, xmm1		;; z = y - (maximum * BIGVAL - BIGVAL)
	mulsd	xmm1, xmm7		;; next carry = shifted y
	subsd	xmm0, xmm2		;; new value = x - z
	_movsd	[esi+d4], xmm0		;; Save new value

	subsd	xmm1, XMM_BIGVAL
	addsd	xmm1, [esi+d4+d1]	;; Add value
	_movsd	[esi+d4+d1], xmm1	;; Save new value
	ENDM

;;
;; Macro to copy and possibly zero 4 or 8 doubles
;;

xcopyzero MACRO numvals
	xcopyz	0, xmm0, [esi]		;; Load and copy first doubles
	movapd	[edi], xmm0		;; Save first doubles
	xcopyz	1, xmm1, [esi+16]	;; Load and copy second doubles
	movapd	[edi+16], xmm1		;; Save second doubles
	IF numvals EQ 8
	xcopyz	2, xmm2, [esi+32]	;; Load and copy third doubles
	movapd	[edi+32], xmm2		;; Save third doubles
	xcopyz	3, xmm3, [esi+48]	;; Load and copy fourth doubles
	movapd	[edi+48], xmm3		;; Save fourth doubles
	ENDIF
	ENDM

xcopyz MACRO col, xmmreg, mem
	LOCAL	z_two, zdone
	cmp	ecx, _COPYZERO+col*8+4	;; Check higher pointer
	jl	short z_two		;; Jump if zeroing both
	movapd	xmmreg, mem		;; Load the doubles
	cmp	ecx, _COPYZERO+col*8	;; Check lower pointer
	jge	short zdone		;; Jump if no zeroing
	subsd	xmmreg, xmmreg		;; Clear just one double
	jmp	short zdone
z_two:	subpd	xmmreg, xmmreg
zdone:
	ENDM


