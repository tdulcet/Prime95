; Copyright 2001-2002 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros perform the medium-sized 2 pass FFTs using SSE2 instructions.
;

; ********************************************************
; ********************************************************
; ********************  FFT MACROS  **********************
; ********************************************************
; ********************************************************

; WARNING, WARNING, WARNING:  This file was copied from xfft3.mac.
; Rather than recomment everything, all memory layouts should just be
; divided by 8!!!!


;; Perform a 40K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft5K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 4 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c2b:	x1cl_half_eight_reals_unfft_2 esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*2*blkdst-blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 8 five_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 40 data values

c1b:	x5cl_five_reals_last_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 40 data values

b0b:
	sub	eax, eax		;; 1 iteration of 2
b1b:	x5cl_five_reals_first_fft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 16K-39K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-blkdst];; Restore source pointer

;; Work on next 4 sets of 20 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	sub	eax, eax		;; 1 iteration of 2
d1b:	x5cl_five_reals_first_fft esi, 5*64, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*5*64]	;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x1cl_half_eight_reals_fft_2 esi, 5*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*5*64+64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3b:	x4cl_four_complex_fft esi, 5*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 48K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft6K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 5 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c2b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K

;; Do 16 six_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 24 data values

	mov	al, 2			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 4 iterations each processing 24 data values

b0b:
	mov	eax, 2			;; 2 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-47K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

b2b:	x2cl_eight_reals_fft_2 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-2*blkdst];; Restore source pointer

;; Work on next 4 sets of 24 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 2			;; 2 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 6*64, 2*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*6*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x2cl_eight_reals_fft_2 esi, 6*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*6*64+2*64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3b:	x4cl_four_complex_fft esi, 6*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 56K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft7K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3a, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 6 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c2b:	x1cl_half_eight_reals_unfft_2 esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*2*blkdst-blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 16 seven_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 56 data values

c1b:	x7cl_seven_reals_last_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+5*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 56 data values

b0b:
	sub	eax, eax
b1b:	x7cl_seven_reals_first_fft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-55K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3a:	x2cl_four_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b3a

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-3*blkdst];; Restore source pointer

;; Work on next 4 sets of 28 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	sub	eax, eax		;; 1 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 7*64, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*7*64]	;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x1cl_half_eight_reals_fft_2 esi, 7*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*7*64+64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3a:	x2cl_four_complex_fft esi, 7*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary

	lea	esi, [esi-2*7*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
d3b:	x4cl_four_complex_fft esi, 7*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM




;; Perform a 64K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft8K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 7 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c2b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K

;; Do 16 eight_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 8 iterations each processing 16 data values

b0b:
	mov	eax, 4			;; 4 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+6*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-63K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b2b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-4*blkdst];; Restore source pointer

;; Work on next 4 sets of 32 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 8*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*8*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos1		;; Load sin/cos pointer
d2b:	x4cl_eight_reals_fft_2 esi, 8*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*8*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
d3b:	x4cl_four_complex_fft esi, 8*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM






;; Perform a 80K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft10K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 9 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 36 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*4*blkdst-2*blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 32 five_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 40 data values

	mov	al, 2			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 32 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 40 data values

b0b:
	mov	eax, 2			;; 2 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+3*blkdst]
	prefetcht1 [esi-128+5*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	prefetcht1 [esi-128+9*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 8 data values

	mov	al, 2			;; 2 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-2*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 32 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*2*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 40 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 2			;; 2 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 10*64, 2*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 10*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 10*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-2*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 10*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*10*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d5b:	x2cl_two_complex_fft esi, 10*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 96K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft12K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 11 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 22 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

c2b:	x4cl_eight_reals_unfft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*4*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 32 six_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 24 data values

	mov	al, 4			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 32 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 8 iterations each processing 24 data values

b0b:
	mov	eax, 4			;; 4 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+5*blkdst]
	prefetcht1 [esi-128+9*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-4*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 40 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 10 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*2*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 48 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 12*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 12*64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*64+4*64]	;; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 12*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-4*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 12*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*12*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
d5b:	x2cl_two_complex_fft esi, 12*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 112K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft14K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 13 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 52 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 6 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*4*blkdst-2*blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 32 seven_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 56 data values

	mov	al, 2			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+10*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 32 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 56 data values

b0b:
	mov	eax, 2			;; 2 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 8 data values

	mov	al, 2			;; 2 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-6*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-111K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 48 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*2*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 56 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 2			;; 2 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 14*64, 2*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 14*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3a:	x2cl_four_complex_fft esi, 14*64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-2*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 14*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-6*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 14*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*14*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
d5b:	x2cl_two_complex_fft esi, 14*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 128K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft16K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 15 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 60 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

c2b:	x4cl_eight_reals_unfft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 6 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*4*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K

;; Do 32 eight_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	mov	al, 4			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 16 iterations each processing 16 data values

b0b:
	mov	eax, 8			;; 8 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+12*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-8*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 56 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 14 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*2*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 64 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 16*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 16*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 16*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-8*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 16*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*16*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
d5b:	x2cl_two_complex_fft esi, 16*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 160K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft20K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 19 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 72 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*8*blkdst-4*blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 64 five_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 40 data values

	mov	al, 4			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 64 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 40 data values

b0b:
	mov	eax, 4			;; 4 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+5*blkdst]
	prefetcht1 [esi-128+9*blkdst]
	prefetcht1 [esi-128+13*blkdst]
	prefetcht1 [esi-128+17*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-159K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 8 data values

	mov	al, 4			;; 4 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-4*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-159K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 80 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 20*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 20*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 20*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-4*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 20*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*20*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d5b:	x4cl_four_complex_fft esi, 20*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM



;; Perform a 192K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft24K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 23 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 44 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; 2 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 64 six_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 24 data values

	mov	al, 8			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 64 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 16 iterations each processing 24 data values

b0b:
	mov	eax, 8			;; 8 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+9*blkdst]
	prefetcht1 [esi-128+17*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	al, 4			;; 4 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-8*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 40 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 10 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 96 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 24*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 24*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 24*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-8*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 24*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*24*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
d5b:	x4cl_four_complex_fft esi, 24*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM



;; Perform a 224K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft28K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 27 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 52 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*8*blkdst-4*blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 64 seven_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 56 data values

	mov	al, 4			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+20*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 64 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 56 data values

b0b:
	mov	eax, 4			;; 4 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+10*blkdst]
	prefetcht1 [esi-128+14*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+22*blkdst]
	prefetcht1 [esi-128+26*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 8 data values

	mov	al, 4			;; 4 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-12*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 48 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 112 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 28*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 28*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3a:	x2cl_four_complex_fft esi, 28*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 28*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-12*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 28*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*28*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
d5b:	x4cl_four_complex_fft esi, 28*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM






;; Perform a 256K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft32K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 31 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 60 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; 2 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K

;; Do 64 eight_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	mov	al, 8			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 32 iterations each processing 16 data values

b0b:
	mov	eax, 16			;; 16 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+20*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-16*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 56 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 14 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 128 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 32*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 32*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 32*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-16*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 32*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*32*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
d5b:	x4cl_four_complex_fft esi, 32*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM







;; Perform a 320K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft40K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 39 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 76 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 38 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 19			;; 19 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-20*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 72 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 36 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*4*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 16 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

	mov	al, 4			;; 4 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*16*blkdst-8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 128 five_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 40 data values

	mov	al, 8			;; 8 iterations of 2
c1b:	x5cl_five_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 128 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 40 data values

b0b:
	mov	eax, 8			;; 8 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+10*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+26*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-319K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 8 data values

	mov	al, 8			;; 8 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-8*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*8*blkdst]	;; Restore source pointer

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 72 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-10*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 160 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 40*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 40*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 40*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-8*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 40*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 40*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-5*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 40*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*40*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2
d7b:	x4cl_four_complex_fft esi, 40*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM



;; Perform a 384K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft48K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 47 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 92 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 46 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 23			;; 23 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-24*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 88 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 44 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*4*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft_2 macros
;; Do 16 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	mov	al, 4			;; 4 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*16*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 128 six_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 24 data values

	mov	al, 16			;; 16 iterations of 2
c1b:	x3cl_six_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 128 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 32 iterations each processing 24 data values

b0b:
	mov	eax, 16			;; 16 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, and
;; 128K-383K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 16 data values

	mov	al, 8			;; 8 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-16*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 80 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*8*blkdst]	;; Restore source pointer

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 88 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-12*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 192 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 48*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 48*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-8*64+16*64]	;; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 48*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-16*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 48*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 48*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-6*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 48*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*48*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2
d7b:	x4cl_four_complex_fft esi, 48*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM



;; Perform a 448K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft56K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 55 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 108 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 54 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 27			;; 27 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-28*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 104 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 52 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*4*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 16 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

	mov	al, 4			;; 4 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*16*blkdst-8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 128 seven_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 56 data values

	mov	al, 8			;; 8 iterations of 2
c1b:	x7cl_seven_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+40*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 128 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 56 data values

b0b:
	mov	eax, 8			;; 8 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+10*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+26*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+42*blkdst]
	prefetcht1 [esi-128+50*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-447K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 8 data values

	mov	al, 8			;; 8 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 16 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-24*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 96 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 48 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*8*blkdst]	;; Restore source pointer

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 104 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-14*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 224 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 56*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 56*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3a:	x2cl_four_complex_fft esi, 56*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-8*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 56*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-24*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 56*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 56*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-7*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 56*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*56*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2
d7b:	x4cl_four_complex_fft esi, 56*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM



;; Perform a 512K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft64K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 63 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 124 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 62 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 31			;; 31 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-32*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 120 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 60 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*4*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft_2 macros
;; Do 16 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	mov	al, 4			;; 4 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*16*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K

;; Do 128 eight_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values

	mov	al, 16			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 64 iterations each processing 16 data values

b0b:
	mov	eax, 32			;; 32 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+36*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-32*blkdst];; Restore source pointer

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 112 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 56 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*8*blkdst]	;; Restore source pointer

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 120 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-16*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 256 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 32			;; 32 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 64*64, 32*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 64*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-8*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 64*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-32*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 64*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 64*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-8*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 64*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*64*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2
d7b:	x4cl_four_complex_fft esi, 64*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM





;; Perform a 640K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft80K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 79 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 156 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 78 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 39			;; 39 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-40*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 144 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 36 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...

;; Do 32 eight_reals_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

	mov	al, 8			;; 8 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+8		;; 2 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*32*blkdst-16*blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K

;; Do 256 five_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 40 data values

	mov	al, 16			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	prefetcht1 [esi-128+clm*128+64*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K

;; Do 256 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 40 data values

b0b:
	mov	eax, 16			;; 16 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+50*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-639K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 8 data values

	mov	al, 16			;; 16 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-16*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-639K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*16*blkdst]	;; Restore source pointer

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-619K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 152 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 38 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 19			;; 19 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-20*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 320 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 80*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 80*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 80*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-16*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 80*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 80*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-5*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 80*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*80*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 19			;; 19 iterations of 2
d7b:	x4cl_four_complex_fft esi, 80*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 768K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft96K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 95 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 188 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 94 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 47			;; 47 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-48*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 176 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 44 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	30K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	mov	al, 8			;; 8 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+8		;; 2 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*32*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	30K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K

;; Do 256 six_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 24 data values

	mov	al, 32			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+64*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K

;; Do 256 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 64 iterations each processing 24 data values

b0b:
	mov	eax, 32			;; 32 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-255K is semi-real data, and
;; 256K-767K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

	mov	al, 16			;; 16 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-32*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-767K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 160 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*16*blkdst]	;; Restore source pointer

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-767K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 184 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 46 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 23			;; 23 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-24*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 384 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 32			;; 32 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 96*64, 32*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 96*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 96*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-32*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 96*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 96*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-6*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 96*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*96*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 23			;; 23 iterations of 2
d7b:	x4cl_four_complex_fft esi, 96*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 896K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft112K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 111 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 220 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 110 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 55			;; 55 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-56*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 208 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 52 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...

;; Do 32 eight_reals_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

	mov	al, 8			;; 8 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 192 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 48 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+8		;; 3 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*32*blkdst-16*blkdst];; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K

;; Do 256 seven_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 56 data values

	mov	al, 16			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	prefetcht1 [esi-128+clm*128+64*blkdst]
	prefetcht1 [esi-128+clm*128+80*blkdst]
	prefetcht1 [esi-128+clm*128+96*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K

;; Do 256 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 56 data values

b0b:
	mov	eax, 16			;; 16 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+50*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	prefetcht1 [esi-128+82*blkdst]
	prefetcht1 [esi-128+98*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-895K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 8 data values

	mov	al, 16			;; 16 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	add	cl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-48*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-895K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 192 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 48 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*16*blkdst]	;; Restore source pointer

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-895K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 208 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 54 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 27			;; 27 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-28*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 448 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 112*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 112*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3a:	x2cl_four_complex_fft esi, 112*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 112*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-48*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 112*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 112*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-7*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 112*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*112*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 27			;; 27 iterations of 2
d7b:	x4cl_four_complex_fft esi, 112*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM


;; Perform a 1M-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft128K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump is FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/8/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_8_levels_real and 127 pass2_8_levels_complex

pass2:
	CALL_Y	xpass2_8_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_2

;; Do the inverse FFT

	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/8/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 252 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 63			;; 63 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-64*2*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 240 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 60 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*8*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	mov	al, 8			;; 8 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 192 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 48 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+8		;; 3 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*32*blkdst]	;; Restore source pointer

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K

;; Do 256 eight_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values

	mov	al, 32			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+64*blkdst]
	prefetcht1 [esi-128+clm*128+96*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer

;; Normalize these values

	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 256 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 128 iterations each processing 16 data values

b0b:
	mov	eax, 64			;; 64 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+68*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+32*blkdst]
	prefetcht1 [esi-128+clm*128+48*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-64*blkdst];; Restore source pointer

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 224 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 56 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*16*blkdst]	;; Restore source pointer

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b6b

;; Do 248 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 62 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 31			;; 31 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-32*4*blkdst]	;; Restore source pointer

;; Work on next 4 sets of 512 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512/8*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	CALL_X	gw_split_carries_2

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_2	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 64			;; 64 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 128*64, 64*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 128*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 128*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-64*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 128*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 128*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-8*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 128*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*128*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 31			;; 31 iterations of 2
d7b:	x4cl_four_complex_fft esi, 128*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_2
	ENDM
