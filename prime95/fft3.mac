; Copyright 1998-2003 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros perform the large 3 pass FFTs.  Rather than doing three
; passes sequentially, we do part of pass 0 then part of pass 1, etc.
; We do this so that the pass 1 data can come from the L2 cache rather
; than main memory.
;
; NOTE:  The prefetching done for lengths below 256K was not effective.
; We could write special pass1_6_levels and pass1_7_levels that does
; prefetching the next batch for an estimated 5% performance boost.


;; Sometimes, prefetching makes matters worse on the Athlon's 256KB L2 cache.
;; Thus, the PFETCH512 ifdef is used to turn prefetching off in the unfft
;; stage of the larger FFTs.  We could turn it on for a 512KB L2 cache.


; ********************************************************
; ********************************************************
; ********************  FFT MACROS  **********************
; ********************************************************
; ********************************************************

;; Perform a 80K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft80K MACRO type
	LOCAL	b1b, b2b, c1b, c2b

;; Each pass 0/1 combination processes 640 values.  There are 128
;; sets of 640 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 5 values

	mov	cl, 16			;; V - 16 iterations of 8
b2b:

;; Do 1 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp five_reals_first_fft, dist16K, 2*dist16K, 4*dist16K

;; Point to next set of 5 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 5 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_6a_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 640 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-5*dist16K+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 159 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 640 values.  There are 128
;; sets of 640 values to work on.

	IF type EQ 4
end80K:	lea	esi, [esi-5*dist16K]	;; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 5 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_6a_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-5*dist16K]	;; V - Restore src ptr

;; In pass 0, we work on 128 sets of 5 values

	mov	cl, 16			;; U - 16 iterations of 8
c2b:

;; Do 1 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp five_reals_last_unfft, dist16K, 2*dist16K, 4*dist16K

;; Point to next set of 5 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 640 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 96K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft96K MACRO type
	LOCAL	b1b, b2a, b2b, c1b, c2b

;; Each pass 0/1 combination processes 768 values.  There are 128
;; sets of 768 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 6 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+256]		;; Read from this page (loads the TLB)
	ENDIF
b2b:

;; Do 1 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp six_reals_first_fft, dist16K, 2*dist16K, 4*dist16K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	prefetcht0 [ebp+4*dist128]
	ENDIF

;; Point to next set of 6 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+dist16K]	;; Next prefetch pointer
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 6 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 768 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-6*dist16K+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 191 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 768 values.  There are 128
;; sets of 768 values to work on.

	IF type EQ 4
end96K:	lea	esi, [esi-6*dist16K]	;; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 6 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-6*dist16K]	;; V - Restore src ptr

;; In pass 0, we work on 128 sets of 6 values

	mov	cl, 16			;; U - 16 iterations of 8
c2b:

;; Do 1 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp six_reals_last_unfft, dist16K, 2*dist16K, 4*dist16K

;; Point to next set of 6 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 768 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 112K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft112K MACRO type
	LOCAL	b1b, b2b, c1b, c2b

;; Each pass 0/1 combination processes 896 values.  There are 128
;; sets of 896 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 7 values

	mov	cl, 16			;; V - 16 iterations of 8
b2b:

;; Do 1 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp seven_reals_first_fft, dist16K, 2*dist16K, 4*dist16K

;; Point to next set of 7 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 7 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_6a_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 896 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-7*dist16K+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 223 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 896 values.  There are 128
;; sets of 896 values to work on.

	IF type EQ 4
end112K:lea	esi, [esi-7*dist16K]	;; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 7 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_6a_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-7*dist16K]	;; V - Restore src ptr

;; In pass 0, we work on 128 sets of 7 values

	mov	cl, 16			;; U - 16 iterations of 8
c2b:

;; Do 1 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp seven_reals_last_unfft, dist16K, 2*dist16K, 4*dist16K

;; Point to next set of 7 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 896 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 128K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft128K MACRO type
	LOCAL	b1b, b2a, b2b, c1b, c2b

;; Each pass 0/1 combination processes 1024 values.  There are 128
;; sets of 1024 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 8 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+256]		;; Read from this page (loads the TLB)
	ENDIF
b2b:

;; Do 1 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp eight_reals_first_fft, dist16K, 2*dist16K, 4*dist16K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	prefetcht0 [ebp+4*dist128]
	ENDIF

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+dist16K]	;; Next prefetch pointer
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 8 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 1024 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 255 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 1024 values.  There are 128
;; sets of 1024 values to work on.

	IF type EQ 4
end128K:lea	esi, [esi-8*dist16K]	;; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 8 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-8*dist16K]	;; U - Restore source pointer

;; In pass 0, we work on 128 sets of 8 values

	mov	cl, 16			;; U - 16 iterations of 8
c2b:

;; Do 1 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp eight_reals_last_unfft, dist16K, 2*dist16K, 4*dist16K

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 1024 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 128K-element FFT using mod 2^N+1 arithmetic.  This is done
;; in three passes.  Pass 0 does 2 levels, working on every 16384th element.
;; Pass 1 does 6 levels, working on every 256th element.  Pass 2 uses common
;; code to perform the last 8 levels of the FFT.

fft128Kp MACRO type
	LOCAL	b1b, b2b, c1b, c2b

;; Each pass 0/1 combination processes 1024 values.  There are 128
;; sets of 1024 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
	mov	edi, plus1_premults	;; V - Address of the multipliers
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 8 values

	mov	cl, 16			;; V - 16 iterations of 8
b2b:

;; Do 1 four_complex_first_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp four_complex_first_fft, dist16K, 2*dist16K, 4*dist16K
	lea	edi, [edi+PMD]		;; V - Next multipliers

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 8 sets of 128 values to work on.

	mov	ecx, 8*256+4		;; V - 4 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_6_levels_fftp	;;UV - Do 6 levels of the FFT
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 1024 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 256 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123p
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4p
	ENDIF

;; Each pass 0/1 combination processes 1024 values.  There are 128
;; sets of 1024 values to work on.

	IF type EQ 4
end128Kp:lea	esi, [esi-8*dist16K]	;; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
	mov	edi, plus1_premults	;; U - Address of the multipliers
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 8 sets of 128 values to work on.

	mov	ecx, 8*256+4		;; V - 4 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_6_levels_unfftp	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-8*dist16K]	;; U - Restore source pointer
	pop	edi			;; V - Restore premultiplier address

;; In pass 0, we work on 128 sets of 8 values

	mov	cl, 16			;; U - 16 iterations of 8
c2b:

;; Do 1 four_complex_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 16K
;;	do 1 iteration

	disp four_complex_last_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	edi, [edi+PMD]		;; V - Next multipliers

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 1024 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 160K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft160K MACRO type
	LOCAL	b1b, b2b, c1b, c2b

;; Each pass 0/1 combination processes 1280 values.  There are 128
;; sets of 1280 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 5 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2b:

;; Do 1 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp five_reals_first_fft, 2*dist16K, 4*dist16K, dist128K

;; Point to next set of 5 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 5 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_7a_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 1280 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-2*dist16K-dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 319 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 1280 values.  There are 128
;; sets of 1280 values to work on.

	IF type EQ 4
end160K:lea	esi, [esi-2*dist16K-dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 5 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_7a_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-2*dist16K-dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 5 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp five_reals_last_unfft, 2*dist16K, 4*dist16K, dist128K

;; Point to next set of 5 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 1280 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 192K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft192K MACRO type
	LOCAL	b1b, b2a, b2b, c1b, c2b

;; Each pass 0/1 combination processes 1536 values.  There are 128
;; sets of 1536 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 6 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	ENDIF
b2b:

;; Do 1 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp six_reals_first_fft, 2*dist16K, 4*dist16K, dist128K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	prefetcht0 [ebp+dist128K]
	lea	esi, [esi+dist128]
	disp six_reals_first_fft, 2*dist16K, 4*dist16K, dist128K
	prefetcht0 [ebp+4*dist16K]
	ENDIF

;; Point to next set of 6 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist16K+4*dist128]
	ENDIF
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 6 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 1536 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-4*dist16K-dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 383 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 1536 values.  There are 128
;; sets of 1536 values to work on.

	IF type EQ 4
end192K:lea	esi, [esi-4*dist16K-dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 6 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+2	;; V - 2 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-4*dist16K-dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 6 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp six_reals_last_unfft, 2*dist16K, 4*dist16K, dist128K

;; Point to next set of 6 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 1536 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 224K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft224K MACRO type
	LOCAL	b1b, b2b, c1b, c2b

;; Each pass 0/1 combination processes 1792 values.  There are 128
;; sets of 1792 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 7 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2b:

;; Do 1 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp seven_reals_first_fft, 2*dist16K, 4*dist16K, dist128K

;; Point to next set of 7 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 7 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_7a_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 1792 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-6*dist16K-dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 447 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 1792 values.  There are 128
;; sets of 1792 values to work on.

	IF type EQ 4
end224K:lea	esi, [esi-6*dist16K-dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 7 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_7a_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-6*dist16K-dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 7 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp seven_reals_last_unfft, 2*dist16K, 4*dist16K, dist128K

;; Point to next set of 7 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 1792 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 256K-element FFT.  This is done in three passes.  Pass 0
;; does 3 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft256K MACRO type
	LOCAL	b1b, b2a, b2b, c1b, c2b

;; Each pass 0/1 combination processes 2048 values.  There are 128
;; sets of 2048 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 8 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi+dist1K]	;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	ENDIF
b2b:

;; Do 1 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp eight_reals_first_fft, 2*dist16K, 4*dist16K, dist128K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	prefetcht0 [ebp+4*dist128]
	ENDIF

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 8 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 2048 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 511 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 2048 values.  There are 128
;; sets of 2048 values to work on.

	IF type EQ 4
end256K:lea	esi, [esi-8*dist16K-dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 8 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+3	;; V - 3 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 8 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp eight_reals_last_unfft, 2*dist16K, 4*dist16K, dist128K

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 2048 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 256K-element FFT using mod 2^N+1 arithmetic.  This is done
;; in three passes.  Pass 0 does 2 levels, working on every 32768th element.
;; Pass 1 does 7 levels, working on every 256th element.  Pass 2 uses common
;; code to perform the last 8 levels of the FFT.

fft256Kp MACRO type
	LOCAL	b1b, b2b, c1b, c2b

;; Each pass 0/1 combination processes 2048 values.  There are 128
;; sets of 2048 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
	mov	edi, plus1_premults	;; V - Address of the multipliers
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 8 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2b:

;; Do 1 four_complex_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp four_complex_first_fft, 2*dist16K, 4*dist16K, dist128K
	lea	edi, [edi+PMD]		;; V - Next multipliers

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 8 sets of 256 values to work on.

	mov	ecx, 8*256+4		;; V - 4 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_7_levels_fftp	;;UV - Do 7 levels of the FFT
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 2048 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 512 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123p
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4p
	ENDIF

;; Each pass 0/1 combination processes 2048 values.  There are 128
;; sets of 2048 values to work on.

	IF type EQ 4
end256Kp:lea	esi, [esi-8*dist16K-dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
	mov	edi, plus1_premults	;; U - Address of the multipliers
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 8 sets of 256 values to work on.

	mov	ecx, 8*256+4		;; V - 4 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_7_levels_unfftp	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-dist128K];; U - Restore source pointer
	pop	edi			;; V - Restore premultiplier address

;; In pass 0, we work on 256 sets of 8 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 four_complex_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 1 * 32K
;;	do 1 iteration

	disp four_complex_last_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	edi, [edi+PMD]		;; V - Next multipliers

;; Point to next set of 8 values

	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 2048 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 320K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft320K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, c1b, c2b, c3b, c4b, c5b

;; Each pass 0/1 combination processes 2560 values.  There are 128
;; sets of 2560 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 20 values.  To optimize
;; four_reals_fft we work on eight different sets of 20 at a time.

	mov	cl, 16			;; V - 16 iterations
b2a:
	IFDEF	PFETCH
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi+dist1K]	;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	ENDIF
b2b:

;; Do 4 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	mov	al, 2			;; U - 4 iterations
b3b:	disp five_reals_first_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist16K]
	ENDIF
	add	al, 256/8		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+4*dist128]
	ENDIF
	add	ah, 256/2		;; U - Test loop counter
	jnc	b3b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b3b			;; V - Iterate if necessary

;; Do 1 four_reals_fft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;; However, for better pipelining we merge two four_reals_unfft operations
;; into a single two_four_reals_unfft macro that operates on two
;; independent sets of 4 data values.  We can do this since we are
;; operating on 8 different sets of 20 values at once.

	lea	esi, [esi-4*dist16K]	;; U - Load source pointer
b4b:	disp two_four_reals_fft, dist128, dist16K, 2*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 2 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 2 iterations

	lea	esi, [esi-8*dist128+4*dist16K];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 2			;; V - 2 iterations
b5b:	disp four_complex_fft, dist16K, 2*dist16K, (dist128K-4*dist16K)
	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist16K+4*dist128]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b5b			;; V - Iterate if necessary

;; Point to next eight sets of 20 values

	lea	esi, [esi-4*dist16K-2*dist128K+dist1K];; U - Next src pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 20 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+9	;; V - 9 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 2560 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-4*dist16K-2*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 639 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 2560 values.  There are 128
;; sets of 2560 values to work on.

	IF type EQ 4
end320K:lea	esi, [esi-4*dist16K-2*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 20 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+9	;; V - 9 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-4*dist16K-2*dist128K];; U - Restore source pointer

;; In pass 0, we work on 128 sets of 20 values.  To optimize
;; four_reals_unfft we work on eight different sets of 20 at a time.

	mov	cl, 16			;; V - 16 iterations
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	lea	ebp, [esi+ebp+2*dist128K]
	ENDIF
c2b:

;; Do 1 four_reals_unfft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K

c4b:	disp two_four_reals_unfft, dist128, dist16K, 2*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 2 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 2 iterations

	lea	esi, [esi-8*dist128+4*dist16K];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, 2			;; V - 2 iterations
c5b:	disp four_complex_unfft, dist16K, 2*dist16K, (dist128K-4*dist16K)
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/4		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist16K]
	add	ah, 256/2		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c5b			;; V - Iterate if necessary
	IFDEF PFETCH
	lea	ebp, [ebp-4*dist16K-2*dist128K]
	ENDIF

;; Do 4 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	lea	esi, [esi-4*dist16K-2*dist128K];; U - Load source pointer
	mov	eax, 4			;; V - 4 iterations
c3b:	disp five_reals_last_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist16K]
	add	ah, 256/4		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF PFETCH
	add	eax, 80000000h		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ebp, [ebp-8*dist16K+dist128K]
	sub	al, 2			;; Test loop counter
	ELSE
	dec	al			;; V - Test loop counter
	ENDIF
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next eight sets of 20 values

	lea	esi, [esi-4*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-2*dist128K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 2560 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


;; Perform a 384K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft384K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, c1b, c2b, c3b, c4b

;; Each pass 0/1 combination processes 3072 values.  There are 128
;; sets of 3072 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 24 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume fetching dist 512 away
	and	ch, ch			;; Test middle loop counter
	jz	short b2b		;; Jump if assumption was correct
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	ENDIF
b2b:

;; Do 4 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	mov	al, 2			;; U - 4 iterations
b3b:	disp six_reals_first_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+4*dist16K]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b3b			;; V - ITerate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b3b			;; V - Iterate if necessary

;; Do 1 eight_reals_fft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi-4*dist16K]	;; U - Load source pointer
	disp eight_reals_fft_2, dist16K, 2*dist16K, 4*dist16K

;; Do 2 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 2 iterations

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
b4b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist16K]
	ENDIF
	add	al, 256/2		;; U - Test loop counter
	jnc	b4b			;; V - Iterate if necessary

;; Point to next set of 24 values

	lea	esi, [esi-3*dist128K+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-2*dist16K-3*dist128K+dist16K];; Next prefetch pointer
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ch, 256/2		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 24 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+11	;; V - 11 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 3072 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-2*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 767 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 3072 values.  There are 128
;; sets of 3072 values to work on.

	IF type EQ 4
end384K:lea	esi, [esi-8*dist16K-2*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 24 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+11	;; V - 11 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-2*dist128K];; U - Restore source pointer

;; In pass 0, we work on 128 sets of 24 values

	mov	cl, 16			;; V - 16 iterations of 8
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K

	disp eight_reals_unfft_2, dist16K, 2*dist16K, 4*dist16K
	IFDEF PFETCH
	prefetch64 [ebp]
	ENDIF

;; Do 2 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 2 iterations

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
c4b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/2		;; U - Test loop counter
	jnc	c4b			;; V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp+dist128K]
	ENDIF

;; Do 4 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	lea	esi, [esi-3*dist128K]	;; U - Load source pointer
c3b:	disp six_reals_last_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp+2*dist128K]
	ENDIF

;; Point to next set of 24 values

	lea	esi, [esi-4*dist16K+dist128];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 3072 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


;; Perform a 448K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft448K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, c1b, c2b, c3b, c4b, c5b

;; Each pass 0/1 combination processes 3584 values.  There are 128
;; sets of 3584 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 28 values.  To optimize
;; four_reals_fft we work on eight different sets of 28 at a time.

	mov	cl, 16			;; V - 16 iterations
b2a:
	IFDEF	PFETCH
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi+dist1K]	;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	ENDIF
b2b:

;; Do 4 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	mov	eax, 4			;; U - 4 iterations
b3b:	disp seven_reals_first_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+4*dist128]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128+dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist16K+dist128K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist128K+4*dist16K]
	ENDIF

;; Do 1 four_reals_fft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;; However, for better pipelining we merge two four_reals_fft operations
;; into a single two_four_reals_fft macro that operates on two
;; independent sets of 4 data values.  We can do this since we are
;; operating on 8 different sets of 28 values at once.

	lea	esi, [esi-4*dist16K]	;; U - Load source pointer
b4b:	disp two_four_reals_fft, dist128, dist16K, 2*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 3 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 3 iterations

	lea	esi, [esi-8*dist128+4*dist16K];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations
b5b:	disp four_complex_fft, dist16K, 2*dist16K, (dist128K-4*dist16K)
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+4*dist128]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128+dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist16K+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b5b			;; V - Iterate if necessary

;; Point to next eight sets of 28 values

	lea	esi, [esi-4*dist16K-3*dist128K+dist1K];; U - Next src pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 28 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+13	;; V - 13 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 3584 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-4*dist16K-3*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 895 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 3584 values.  There are 128
;; sets of 3584 values to work on.

	IF type EQ 4
end448K:lea	esi, [esi-4*dist16K-3*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 28 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+13	;; V - 13 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-4*dist16K-3*dist128K];; U - Restore source pointer

;; In pass 0, we work on 128 sets of 28 values.  To optimize
;; four_reals_unfft we work on eight different sets of 28 at a time.

	mov	cl, 16			;; V - 16 iterations
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	lea	ebp, [esi+ebp+4*dist16K]
	ENDIF
c2b:

;; Do 1 four_reals_unfft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K

c4b:	disp two_four_reals_unfft, dist128, dist16K, 2*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 3 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 3 iterations

	lea	esi, [esi-8*dist128+4*dist16K];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, 3			;; V - 3 iterations
c5b:	disp four_complex_unfft, dist16K, 2*dist16K, (dist128K-4*dist16K)
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist16K]
	add	ah, 256/4		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	lea	ebp, [ebp-4*dist16K+dist128K]
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c5b			;; V - Iterate if necessary
	IFDEF PFETCH
	lea	ebp, [ebp-3*dist128K-4*dist16K]
	ENDIF

;; Do 4 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	lea	esi, [esi-4*dist16K-3*dist128K];; U - Load source pointer
	mov	eax, 4			;; V - 4 iterations
c3b:	disp seven_reals_last_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist16K]
	add	ah, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	lea	ebp, [ebp-4*dist16K+dist128K]
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	dec	al			;; V - Test loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next eight sets of 28 values

	lea	esi, [esi-4*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-4*dist128K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 3584 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 512K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft512K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, c1b, c2b, c3b, c4b

;; Each pass 0/1 combination processes 4096 values.  There are 128
;; sets of 4096 values to work on.

	IF type NE 4
	clear_timers
	start_timer 19
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 32 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume fetching dist 512 away
	and	ch, ch			;; Test middle loop counter
	jz	short b2b		;; Jump if assumption was correct
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	ENDIF
b2b:

;; Do 4 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	start_timer 10
	mov	al, 4			;; U - 4 iterations
b3b:	disp eight_reals_first_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist16K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	b3b			;;*V - Iterate if necessary
	end_timer 10

;; Do 1 eight_reals_fft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K

	start_timer 11
	lea	esi, [esi-4*dist16K]	;; U - Load source pointer
	disp eight_reals_fft_2, dist16K, 2*dist16K, 4*dist16K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist16K]
	ENDIF

;; Do 3 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 3 iterations

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations
b4b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist16K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b4b			;; V - Iterate if necessary
	end_timer 11

;; Point to next set of 32 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K];; Next prefetch pointer
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ch, 256/2		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 32 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+15	;; V - 15 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do 6 levels of the FFT

;; Point to next set of 4096 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-3*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	end_timer 19
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 1023 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 4096 values.  There are 128
;; sets of 4096 values to work on.

	IF type EQ 4
end512K:start_timer 29
	lea	esi, [esi-8*dist16K-3*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 32 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+15	;; V - 15 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-3*dist128K];; U - Restore source pointer

;; In pass 0, we work on 128 sets of 32 values

	mov	cl, 16			;; V - 16 iterations of 8
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K

	start_timer 25
	disp eight_reals_unfft_2, dist16K, 2*dist16K, 4*dist16K
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 3 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 16K
;;	do 3 iterations

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	eax, 3			;; V - 3 iterations
c4b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c4b			;; V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	end_timer 25

;; Do 4 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	start_timer 26
	lea	esi, [esi-4*dist128K]	;; U - Load source pointer
c3b:	disp eight_reals_last_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	end_timer 26

;; Point to next set of 32 values

	lea	esi, [esi-4*dist16K+dist128];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-4*dist128K+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 4096 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	end_timer 29
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 512K-element FFT using mod 2^N+1 arithmetic.  This is done
;; in three passes.  Pass 0 does 4 levels, working on every 16384th element.
;; Pass 1 does 6 levels, working on every 256th element.  Pass 2 uses common
;; code to perform the last 8 levels of the FFT.

fft512Kp MACRO type
	LOCAL	b1b, b2b, b3b, b4b, c1b, c2b, c3b, c4b

;; Each pass 0/1 combination processes 4096 values.  There are 128
;; sets of 4096 values to work on.

	IF type NE 4
	mov	eax, 16			;; U - 16 iterations of 8
	mov	edi, plus1_premults	;; V - Address of the multipliers
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 32 values

	mov	cl, 16			;; V - 16 iterations of 8
b2b:

;; Do 4 four_complex_first_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	mov	al, 4			;; U - 4 iterations
b3b:	disp four_complex_first_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	jnz	b3b			;; V - Iterate if necessary

;; Do 4 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 1 * 16K
;;	do 4 iterations

	push	edi			;; U - Save premultiplier address
	lea	esi, [esi-4*dist16K]	;; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
b4b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test loop counter
	jnc	b4b			;; V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 32 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 32 sets of 128 values to work on.

	mov	ecx, 8*256+16		;; V - 16 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_6_levels_fftp	;;UV - Do 6 levels of the FFT
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 4096 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-3*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1024 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123p
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4p
	ENDIF

;; Each pass 0/1 combination processes 4096 values.  There are 128
;; sets of 4096 values to work on.

	IF type EQ 4
end512Kp:lea	esi, [esi-8*dist16K-3*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
	mov	edi, plus1_premults	;; U - Address of the multipliers
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 32 sets of 128 values to work on.

	mov	ecx, 8*256+16		;; V - 16 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_6_levels_unfftp	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-3*dist128K];; U - Restore source pointer
	pop	edi			;; V - Restore premultiplier address

;; In pass 0, we work on 128 sets of 32 values

	mov	cl, 16			;; V - 16 iterations of 8
c2b:

;; Do 4 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 1 * 16K
;;	do 4 iterations

	push	edi			;; U - Save premultiplier address
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations
c4b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c4b			;; V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Do 4 four_complex_last_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations

	lea	esi, [esi-4*dist128K]	;; U - Load source pointer
c3b:	disp four_complex_last_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next multipliers
	add	al, 256/4		;; U - Test loop counter
	jnc	c3b			;; V - Iterate if necessary

;; Point to next set of 32 values

	lea	esi, [esi-4*dist16K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 4096 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 640K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft640K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, c1b, c2b, c3b, c4b, c5b

;; Each pass 0/1 combination processes 5120 values.  There are 128
;; sets of 5120 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 20 values.  To optimize
;; four_reals_fft we work on eight different sets of 20 at a time.

	mov	cl, 16			;; V - 16 iterations of 2
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+dist16K]	;; Assume next block is 16K away
	test	cl, 256/2		;; Is it?
	jz	short b2b		;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	test	cl, 3Eh			;; Test for last block of values
	jz	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-dist16K+dist1K] ;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	ENDIF
b2b:

;; Do 4 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	mov	al, 4			;; U - 4 iterations
b3b:	disp five_reals_first_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+4*dist128]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128+2*dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+2*dist16K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	b3b			;;*V - Iterate if necessary

;; Do 1 four_reals_fft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;; However, for better pipelining we merge two four_reals_fft operations
;; into a single two_four_reals_fft macro that operates on two
;; independent sets of 4 data values.  We can do this since we are
;; operating on 8 different sets of 20 values at once.

	lea	esi, [esi-8*dist16K]	;; U - Load source pointer
b4b:	disp two_four_reals_fft, dist128, 2*dist16K, 4*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 2 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 2 iterations

	lea	esi, [esi-8*dist128+dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; V - 2 iterations
b5b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+2*dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+2*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp-8*dist16K+4*dist128]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b5b			;; V - Iterate if necessary

;; Point to next eight sets of 20 values

	lea	esi, [esi-5*dist128K+dist16K];; U - Next source pointer
	add	cl, 256/2		;; V - Test inner loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 20 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+9	;; V - 9 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 5120 values

	pop	eax			;; U - Restore source pointer
	lea	esi, [esi-8*dist16K-4*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 1279 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 5120 values.  There are 128
;; sets of 5120 values to work on.

	IF type EQ 4
end640K:lea	esi, [esi-8*dist16K-4*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 20 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+9	;; V - 9 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-4*dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 20 values.  To optimize
;; four_reals_unfft we work on eight different sets of 20 at a time.

	mov	cl, 16			;; U - 16 iterations of 2
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 four_reals_unfft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K

c4b:	disp two_four_reals_unfft, dist128, 2*dist16K, 4*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 2 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 2 iterations

	lea	esi, [esi-8*dist128+dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	eax, 2			;; V - 2 iterations
c5b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/4		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist16K]
	add	ah, 256/2		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+2*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c5b			;; V - Iterate if necessary
	IFDEF PFETCH
	lea	ebp, [ebp-4*2*dist16K+dist128K]
	ENDIF

;; Do 4 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	lea	esi, [esi-5*dist128K]	;; U - Load source pointer
	mov	al, 4			;; V - 4 iterations
c3b:	disp five_reals_last_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist16K]
	add	ah, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+2*dist16K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-4*2*dist16K+dist128K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next eight sets of 20 values

	lea	esi, [esi-8*dist16K+dist16K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-5*dist128K+dist16K]
	ENDIF
	add	cl, 256/2		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-2*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 5120 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 768K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft768K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, c1b, c2b, c3b, c4b

;; Each pass 0/1 combination processes 6144 values.  There are 128
;; sets of 6144 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 24 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume next block is 512 away
	test	ecx, 80000000h		;; Is it?
	jz	short b2b		;; Yes, no TLB priming needed
	lea	ebp, [esi-4*dist128+dist16K];; Assume next block is 16K away
	test	ch, 256/2		;; Is it?
	jz	short b2b		;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	ENDIF
b2b:

;; Do 4 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	mov	al, 4			;; U - 4 iterations
b3b:	disp six_reals_first_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b3b			;; V - Iterate if necessary

;; Do 1 eight_reals_fft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi-8*dist16K]	;; U - Load source pointer
	disp eight_reals_fft_2, 2*dist16K, 4*dist16K, dist128K

;; Do 2 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 2 iterations

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
b4b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	al, 256/2		;; U - Test loop counter
	jnc	b4b			;; V - Iterate if necessary

;; Point to next set of 24 values

	lea	esi, [esi-6*dist128K+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-6*dist128K+2*dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ecx, 80000000h		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 24 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+11	;; V - 11 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 6144 values

	pop	eax			;; U - Restore source pointer
	lea	esi, [esi-8*dist16K-5*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 1535 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 6144 values.  There are 128
;; sets of 6144 values to work on.

	IF type EQ 4
end768K:lea	esi, [esi-8*dist16K-5*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 24 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+11	;; V - 11 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-5*dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 24 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K

	disp eight_reals_unfft_2, 2*dist16K, 4*dist16K, dist128K

;; Do 2 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 2 iterations

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
c4b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/2		;; U - Test loop counter
	jnc	c4b			;; V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist128K]
	ENDIF

;; Do 4 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	lea	esi, [esi-6*dist128K]	;; U - Load source pointer
c3b:	disp six_reals_last_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist128K]
	add	ah, 256/2		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF

;; Point to next set of 24 values

	lea	esi, [esi-8*dist16K+dist128];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-6*dist128K+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-2*dist128K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 6144 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 896K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft896K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, c1b, c2b, c3b, c4b, c5b

;; Each pass 0/1 combination processes 7168 values.  There are 128
;; sets of 7168 values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 28 values.  To optimize
;; four_reals_fft we work on eight different sets of 28 at a time.

	mov	cl, 16			;; V - 16 iterations of 2
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+dist16K]	;; Assume next block is 16K away
	test	cl, 256/2		;; Is it?
	jz	short b2b		;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	test	cl, 3Eh			;; Test for last block of values
	jz	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-dist16K+dist1K] ;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	ENDIF
b2b:

;; Do 4 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	mov	al, 4			;; U - 4 iterations
b3b:	disp seven_reals_first_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+4*dist128]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128+2*dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+2*dist16K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	b3b			;;*V - Iterate if necessary

;; Do 1 four_reals_fft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;; However, for better pipelining we merge two four_reals_unfft operations
;; into a single two_four_reals_unfft macro that operates on two
;; independent sets of 4 data values.  We can do this since we are
;; operating on 8 different sets of 28 values at once.

	lea	esi, [esi-8*dist16K]	;; U - Load source pointer
b4b:	disp two_four_reals_fft, dist128, 2*dist16K, 4*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 3 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 3 iterations

	lea	esi, [esi-8*dist128+dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations
b5b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+4*dist128]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128+2*dist16K]
	ENDIF
	add	ah, 256/4		;; V - Test loop counter
	jnc	b5b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+2*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b5b			;; V - Iterate if necessary

;; Point to next eight sets of 28 values

	lea	esi, [esi-7*dist128K+dist16K];; U - Next source pointer
	add	cl, 256/2		;; V - Test inner loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 28 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+13	;; V - 13 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 7168 values

	pop	eax			;; U - Restore source pointer
	lea	esi, [esi-8*dist16K-6*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 1791 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 7168 values.  There are 128
;; sets of 7168 values to work on.

	IF type EQ 4
end896K:lea	esi, [esi-8*dist16K-6*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 28 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+13	;; V - 13 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-6*dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 28 values.  To optimize
;; four_reals_unfft we work on eight different sets of 28 at a time.

	mov	cl, 16			;; U - 16 iterations of 2
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 four_reals_unfft operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K

c4b:	disp two_four_reals_unfft, dist128, 2*dist16K, 4*dist16K
	lea	esi, [esi+2*dist128]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 3 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 3 iterations

	lea	esi, [esi-8*dist128+dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	eax, 3			;; V - 3 iterations
c5b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist16K]
	add	ah, 256/4		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c5b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+2*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF PFETCH
	lea	ebp, [ebp-4*2*dist16K+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	c5b			;; V - Iterate if necessary

;; Do 4 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	lea	esi, [esi-7*dist128K]	;; U - Load source pointer
	mov	eax, 4			;; V - 4 iterations
c3b:	disp seven_reals_last_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+dist128]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist16K]
	add	ah, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+2*dist16K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-4*2*dist16K+dist128K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next eight sets of 28 values

	lea	esi, [esi-8*dist16K+dist16K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-7*dist128K+dist16K]
	ENDIF
	add	cl, 256/2		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-2*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 7168 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 1024K-element FFT.  This is done in three passes.  Pass 0
;; does 5 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft1024K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, c1b, c2b, c3b, c4b

;; Each pass 0/1 combination processes 8192 values.  There are 128
;; sets of 8192 values to work on.

	IF type NE 4
	clear_timers
	start_timer 19
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 32 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume next block is 512 away
	test	ecx, 80000000h		;; Is it?
	jz	short b2b		;; Yes, no TLB priming needed
	lea	ebp, [esi-4*dist128+dist16K];; Assume next block is 16K away
	and	ch, ch	 		;; Is it?
	jz	short b2b		;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K] ;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	ENDIF
b2b:

;; Do 4 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	start_timer 10
	mov	al, 4			;; U - 4 iterations
b3b:	disp eight_reals_first_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; V - Test loop counter
	jnz	b3b			;;*V - Iterate if necessary
	end_timer 10

;; Do 1 eight_reals_fft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K

	start_timer 11
	lea	esi, [esi-8*dist16K]	;; U - Load source pointer
	disp eight_reals_fft_2, 2*dist16K, 4*dist16K, dist128K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 3 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 3 iterations

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations
b4b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; U - Test loop counter
	jnz	b4b			;; V - Iterate if necessary
	end_timer 11

;; Point to next set of 32 values

	lea	esi, [esi-8*dist128K+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+2*dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ecx, 80000000h		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 32 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+15	;; V - 15 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 8192 values

	pop	eax			;; U - Restore source pointer
	lea	esi, [esi-8*dist16K-7*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	end_timer 19
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 2047 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 8192 values.  There are 128
;; sets of 8192 values to work on.

	IF type EQ 4
end1024K:start_timer 29
	lea	esi, [esi-8*dist16K-7*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 32 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+15	;; V - 15 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-7*dist128K];; U - Restore source pointer

;; In pass 0, we work on 256 sets of 32 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_2 operations (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K

	start_timer 26
	disp eight_reals_unfft_2, 2*dist16K, 4*dist16K, dist128K
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist128K]
	ENDIF

;; Do 3 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 1 * 32K
;;	do 3 iterations

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	eax, 3			;; V - 3 iterations
c4b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c4b			;; V - Iterate if necessary
	end_timer 26
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist128K]
	ENDIF

;; Do 4 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	start_timer 27
	lea	esi, [esi-8*dist128K]	;; U - Load source pointer
c3b:	disp eight_reals_last_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+2*dist128K]
	add	ah, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	end_timer 27

;; Point to next set of 32 values

	lea	esi, [esi-8*dist16K+dist128];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist128K+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist16K+dist128K]
	ENDIF
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-2*dist128K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 8192 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	end_timer 29
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 1024K-element FFT using mod 2^N+1 arithmetic.  This is done
;; in three passes.  Pass 0 does 4 levels, working on every 32768th element.
;; Pass 1 does 7 levels, working on every 256th element.  Pass 2 uses common
;; code to perform the last 8 levels of the FFT.

fft1024Kp MACRO type
	LOCAL	b1b, b2b, b3b, b4b, c1b, c2b, c3b, c4b

;; Each pass 0/1 combination processes 8192 values.  There are 128
;; sets of 8192 values to work on.

	IF type NE 4
	mov	eax, 16			;; U - 16 iterations of 8
	mov	edi, plus1_premults	;; V - Address of the multipliers
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 32 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2b:

;; Do 4 four_complex_first_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	mov	al, 4			;; U - 4 iterations
b3b:	disp four_complex_first_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	jnz	b3b			;; V - Iterate if necessary

;; Do 4 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 1 * 32K
;;	do 4 iterations

	push	edi			;; U - Save premultiplier address
	lea	esi, [esi-8*dist16K]	;; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
b4b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test loop counter
	jnc	b4b			;; V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 32 values

	lea	esi, [esi-8*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 32 sets of 256 values to work on.

	mov	ecx, 8*256+16		;; V - 16 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_7_levels_fftp	;;UV - Do 7 levels of the FFT
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 8192 values

	pop	eax			;; U - Restore source pointer
	lea	esi, [esi-8*dist16K-7*dist128K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 2048 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123p
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4p
	ENDIF

;; Each pass 0/1 combination processes 8192 values.  There are 128
;; sets of 8192 values to work on.

	IF type EQ 4
end1024Kp:lea	esi, [esi-8*dist16K-7*dist128K];; U - Restore source pointer
	mov	eax, 16			;; V - 16 iterations of 8
	mov	edi, plus1_premults	;; U - Address of the multipliers
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 32 sets of 256 values to work on.

	mov	ecx, 8*256+16		;; V - 16 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_7_levels_unfftp	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-7*dist128K];; U - Restore source pointer
	pop	edi			;; V - Restore premultiplier address

;; In pass 0, we work on 256 sets of 32 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 4 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 1 * 32K
;;	do 4 iterations

	push	edi			;; U - Save premultiplier address
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations
c4b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	jnz	c4b			;; V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Do 4 four_complex_last_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations

	lea	esi, [esi-8*dist128K]	;; U - Load source pointer
c3b:	disp four_complex_last_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next multipliers
	add	al, 256/4		;; U - Test loop counter
	jnc	c3b			;; V - Iterate if necessary

;; Point to next set of 32 values

	lea	esi, [esi-8*dist16K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 8192 values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 1280K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft1280K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5a, b5b, b6b
	LOCAL	c1b, c2b, c3b, c4b, c5a, c5b, c6a, c6b

;; Each pass 0/1 combination processes 10K values.  There are 128
;; sets of 10K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 80 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume fetching dist 512 away
	and	ch, ch			;; Test middle loop counter
	jz	short b2b		;; Jump if assumption was correct
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	ENDIF
b2b:

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	mov	eax, 2			;; U - 2 iterations of 8
b3b:	disp five_reals_first_fft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/4		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

	lea	esi, [esi-2*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 8 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 2 iterations of 4

	lea	esi, [esi-2*dist16K+2*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	ENDIF
b5a:	disp four_complex_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5a			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K+4*dist128K];; U - Next src pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp+dist128K]
	lea	ebp, [ebp-dist1M+4*dist16K]
	ENDIF
b5b:	disp four_complex_fft, 4*dist16K, dist128K, (dist1M-6*dist128K)
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	lea	esi, [esi-4*dist16K-6*dist128K];; U - Load source pointer
	disp eight_reals_fft_1, dist16K, 2*dist16K, 4*dist16K

;; Do 9 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
;;	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/8*256+2	;; U - 7 iterations, then 2 iterations
b6b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	ah, 256/8		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	mov	ah, 6*256/8		;; V - Load inner loop counter
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF
	dec	al			;; U - Test outer loop counter
	jnz	b6b			;; V - Iterate if necessary

;; Point to next set of 80 values

	lea	esi, [esi+6*dist128K-2*dist1M+dist128];; U - Next src pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+6*dist128K-2*dist1M-4*dist16K+dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ch, 256/2		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 80 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+39	;; V - 39 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do the last 6 levels

;; Point to next set of 10K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-1*dist128K-dist1M+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 2559 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 10K values.  There are 128
;; sets of 10K values to work on.

	IF type EQ 4
end1280K:lea	esi, [esi-8*dist16K-1*dist128K-dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 80 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+39	;; V - 39 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT

;; In pass 0, we work on 128 sets of 80 values

	mov	cl, 16			;; U - 16 iterations of 8
	lea	esi, [esi-8*dist16K-1*dist128K-dist1M];; V - Restore src ptr
	IFDEF PFETCH512
	mov	ebp, pass1blkdst
	lea	ebp, [ebp+esi+dist1M]
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	disp eight_reals_unfft_1, dist16K, 2*dist16K, 4*dist16K

;; Do 9 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/8*256+2	;; U - 7 iterations, then 2 iterations
c6a:
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
c6b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	ah, 256/8		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	mov	ah, 6*256/8		;; V - Load inner loop counter
	dec	al			;; U - Test outer loop counter
	jnz	c6a			;; V - Iterate if necessary
	IFDEF PFETCH512
	lea	ebp, [ebp-2*dist128K-dist1M]
	ENDIF

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

	lea	esi, [esi+6*dist128K-2*dist1M];; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 8 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 2 iterations of 4

	lea	esi, [esi-2*dist16K+2*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
c5a:	disp four_complex_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5a			;; V - Iterate if necessary
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	lea	esi, [esi-4*dist16K+4*dist128K];; U - Next src pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	mov	al, 4			;; 4 iterations
c5b:	disp four_complex_unfft, 4*dist16K, dist128K, (dist1M-6*dist128K)
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH512
	add	al, 256/2		;; Test inner loop counter
	jnc	c5b			;; Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	sub	al, 2			;; Test inner loop counter
	ELSE
	dec	al			;; Test inner loop counter
	ENDIF
	jnz	c5b			;; Iterate if necessary

;; Do 16 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	lea	esi, [esi-4*dist16K-6*dist128K];; U - Load source pointer
	mov	eax, 2			;; V - 2 iterations of 8
c3b:	disp five_reals_last_unfft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH512
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 80 values

	lea	esi, [esi-2*dist128K+dist128];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist128K+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 10K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


;; Perform a 1536K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft1536K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, c1b, c2b, c3b, c4b, c5b, c6b

;; Each pass 0/1 combination processes 12K values.  There are 128
;; sets of 12K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 96 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume fetching dist 512 away
	and	ch, ch			;; Test middle loop counter
	jz	short b2b		;; Jump if assumption was correct
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	ENDIF
b2b:

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	mov	eax, 2			;; U - 2 iterations of 8
b3b:	disp six_reals_first_fft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/4		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 16K
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi-2*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 2*dist16K, 4*dist16K, dist128K
	dispc two_two_complex_fft_2, 2*dist16K, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 8 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 2 iterations of 4

	lea	esi, [esi-2*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 4
b5b:
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	disp four_complex_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K-4*dist128K+dist1M];; U - Next src pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist128K+4*dist16K]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K-dist1M+4*dist16K+dist128K]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+4*dist128K-2*dist1M];; U - Load source pointer
	disp eight_reals_fft_1, dist16K, 2*dist16K, 4*dist16K

;; Do 11 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
;;	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/8*256+2	;; U - 7 iterations, then 4 iterations
b6b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	ah, 256/8		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	mov	ah, 4*256/8		;; V - Load inner loop counter
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K]
	ENDIF
	dec	al			;; U - Test outer loop counter
	jnz	b6b			;; V - Iterate if necessary

;; Point to next set of 96 values

	lea	esi, [esi+4*dist128K-2*dist1M+dist128];; U - Next src pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+4*dist128K-4*dist16K+dist16K];; Next prefetch pointer
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ch, 256/2		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 96 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+47	;; V - 47 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do the last 6 levels

;; Point to next set of 12K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-3*dist128K-dist1M+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 3071 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 12K values.  There are 128
;; sets of 12K values to work on.

	IF type EQ 4
end1536K:lea	esi, [esi-8*dist16K-3*dist128K-dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 96 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+47	;; V - 47 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT

;; In pass 0, we work on 128 sets of 96 values

	mov	cl, 16			;; U - 16 iterations of 8
	lea	esi, [esi-8*dist16K-3*dist128K-dist1M];; V - Restore src ptr
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	disp eight_reals_unfft_1, dist16K, 2*dist16K, 4*dist16K
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 11 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/4+2		;; U - 7 iterations, then 4 iterations
c6b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	ah, 256/2		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	mov	ah, 256/2		;; V - Load inner loop counter
	dec	al			;; U - Test outer loop counter
	jnz	c6b			;; V - Iterate if necessary

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 16K
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi+4*dist128K-2*dist1M];; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 2*dist16K, 4*dist16K, dist128K
	dispc two_two_complex_unfft_2, 2*dist16K, 4*dist16K, dist128K,2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 8 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 2 iterations of 4

	lea	esi, [esi-2*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 4
c5b:	disp four_complex_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K-4*dist128K+dist1M];; U - Next src pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 16 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	lea	esi, [esi+4*dist128K-2*dist1M];; U - Load source pointer
	mov	eax, 2			;; V - 2 iterations of 8
c3b:	disp six_reals_last_unfft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 96 values

	lea	esi, [esi-2*dist128K+dist128];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-4*dist128K-dist1M+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 12K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 1792K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft1792K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5a, b5b, b6b
	LOCAL	c1b, c2b, c3b, c4b, c5a, c5b, c6b

;; Each pass 0/1 combination processes 14K values.  There are 128
;; sets of 14K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 112 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume fetching dist 512 away
	and	ch, ch			;; Test middle loop counter
	jz	short b2b		;; Jump if assumption was correct
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	mov	al, [ebp+dist1M+4*dist128K+256]
	mov	al, [ebp+dist1M+5*dist128K+256]
	ENDIF
b2b:

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	mov	eax, 2			;; U - 2 iterations of 8
b3b:	disp seven_reals_first_fft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/4		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

	lea	esi, [esi-2*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 12 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 3 iterations of 4

	lea	esi, [esi-2*dist16K+2*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iters - OUT OF ORDER!
b5a:	disp four_complex_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b5a			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b5a			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5a			;; V - Iterate if necessary
	ENDIF
	lea	esi, [esi-4*dist16K+dist1M];; U - Next src pointer
	lea	edi, [edi+2*SCD]	;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	jnz	b5a			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1M+4*dist128K];; U - Next src pointer
	lea	edi, [edi-4*SCD+SCD]	;; V - Next sine/cosine pointer
b5b:	disp four_complex_fft, 4*dist16K, dist128K, (dist1M-6*dist128K)
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	ENDIF
	lea	edi, [edi+2*SCD]	;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-6*dist128K-dist1M+4*dist16K]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi-4*dist16K-6*dist128K];; U - Load source pointer
	disp eight_reals_fft_1, dist16K, 2*dist16K, 4*dist16K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 13 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
;;	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/8*256+2	;; U - 7 iterations, then 6 iterations
b6b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	ah, 256/8		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	mov	ah, 2*256/8		;; V - Load inner loop counter
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF
	dec	al			;; U - Test outer loop counter
	jnz	b6b			;; V - Iterate if necessary

;; Point to next set of 112 values

	lea	esi, [esi+2*dist128K-2*dist1M+dist128];; U - Next src pointer
	IFDEF	PFETCH
	lea	ebp, [ebp+2*dist128K-2*dist1M-4*dist16K+dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ch, 256/2		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 112 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+55	;; V - 55 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do the last 6 levels

;; Point to next set of 14K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-5*dist128K-dist1M+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 3583 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 14K values.  There are 128
;; sets of 14K values to work on.

	IF type EQ 4
end1792K:lea	esi, [esi-8*dist16K-5*dist128K-dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 112 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+55	;; V - 55 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT

;; In pass 0, we work on 128 sets of 112 values

	mov	cl, 16			;; U - 16 iterations of 8
	lea	esi, [esi-8*dist16K-5*dist128K-dist1M];; V - Restore src ptr
	IFDEF PFETCH512
	mov	ebp, pass1blkdst
	lea	ebp, [ebp+esi+dist1M]
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	disp eight_reals_unfft_1, dist16K, 2*dist16K, 4*dist16K
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 13 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/8*256+2	;; U - 7 iterations, then 6 iterations
c6b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	ah, 256/8		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	mov	ah, 2*256/8		;; V - Load inner loop counter
	dec	al			;; U - Test outer loop counter
	jnz	c6b			;; V - Iterate if necessary

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

	lea	esi, [esi+2*dist128K-2*dist1M];; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 12 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 3 iterations of 4

	lea	esi, [esi-2*dist16K+2*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iters - OUT OF ORDER!
c5a:	disp four_complex_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5a			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K+dist1M];; U - Next src pointer
	lea	edi, [edi+2*SCD]	;; V - Next sine/cosine pointer
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; U - Test outer loop counter
	jnz	c5a			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1M+4*dist128K];; U - Next src pointer
	lea	edi, [edi-4*SCD+SCD]	;; V - Next sine/cosine pointer
c5b:	disp four_complex_unfft, 4*dist16K, dist128K, (dist1M-6*dist128K)
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K-6*dist128K-dist1M]
	ENDIF

;; Do 16 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	lea	esi, [esi-4*dist16K-6*dist128K];; U - Load source pointer
	mov	eax, 2			;; V - 2 iterations of 8
c3b:	disp seven_reals_last_unfft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH512
	add	al, 256/2		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 112 values

	lea	esi, [esi-2*dist128K+dist128];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist128K+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 14K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 2048K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 16384th element.  Pass 1 does 6 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft2048K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, c1b, c2b, c3b, c4b, c5b, c6b

;; Each pass 0/1 combination processes 16K values.  There are 128
;; sets of 16K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 128 values

	mov	ecx, 16			;; V - 16 iterations of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume fetching dist 512 away
	and	ch, ch			;; Test middle loop counter
	jz	short b2b		;; Jump if assumption was correct
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	short b2b		;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	mov	al, [ebp+dist1M+4*dist128K+256]
	mov	al, [ebp+dist1M+5*dist128K+256]
	mov	al, [ebp+dist1M+6*dist128K+256]
	mov	al, [ebp+dist1M+7*dist128K+256]
	ENDIF
b2b:

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	mov	eax, 2			;; U - 2 iterations of 8
b3b:	disp eight_reals_first_fft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/4		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+4*dist16K]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 16K
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi-2*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 2*dist16K, 4*dist16K, dist128K
	dispc two_two_complex_fft_2, 2*dist16K, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 12 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 3 iterations of 4

	lea	esi, [esi-2*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	eax, 256/2*256+2	;; U - 2 iter of 1 or 2 iters of 4
b5b:	disp four_complex_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	eax, 80000000h		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	ENDIF
	lea	esi, [esi-4*dist16K+4*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	ah, 256/2		;; V - Test middle loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; U - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K-4*dist16K+dist1M]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi-2*dist1M]	;; U - Load source pointer
	disp eight_reals_fft_1, dist16K, 2*dist16K, 4*dist16K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 15 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	al, 256/8+2		;; U - 2 iterations of 7 or 8
b6b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+4*dist16K]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	b6b			;;*V - Iterate if necessary

;; Point to next set of 128 values

	lea	esi, [esi-2*dist1M+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K-dist1M+dist16K];; Next prefetch pointer
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ch, 256/2		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 128 sets of 128 values to work on.

	mov	ecx, 256/4*256+8*256+63	;; V - 63 iters of 2 complex sections
	CALLP	pass1_6_levels_fft	;;UV - Do the last 6 levels

;; Point to next set of 16K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-7*dist128K-dist1M+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 4095 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 32K values.  There are 128
;; sets of 32K values to work on.

	IF type EQ 4
end2048K:lea	esi, [esi-8*dist16K-7*dist128K-dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 128 sets of 256 values to work on.

	mov	ecx, 256/4*256+8*256+63	;; V - 63 iters of 2 complex sections
	CALLP	pass1_6_levels_unfft	;;UV - Do 6 levels of the inverse FFT

;; In pass 0, we work on 128 sets of 128 values

	mov	cl, 16			;; U - 16 iterations of 8
	lea	esi, [esi-8*dist16K-7*dist128K-dist1M];; V - Restore src ptr
	IFDEF PFETCH
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 16K

	disp eight_reals_unfft_1, dist16K, 2*dist16K, 4*dist16K

;; Do 15 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi+dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	eax, 256/4+2		;; U - 2 iterations of 7 or 8
c6b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	ah, 256/2		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c6b			;;*V - Iterate if necessary

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 16K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 16K
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi-2*dist1M]	;; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 2*dist16K, 4*dist16K, dist128K
	dispc two_two_complex_unfft_2, 2*dist16K, 4*dist16K, dist128K,2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 12 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 16K
;;	do 3 iterations of 4

	lea	esi, [esi-2*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	eax, 256/2*256+2	;; U - 2 iter of 1 or 2 iters of 4
c5b:	disp four_complex_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K+4*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF PFETCH
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	ah, 256/2		;; V - Test middle loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; U - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 16 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	lea	esi, [esi-2*dist1M]	;; U - Load source pointer
	mov	eax, 2			;; V - 2 iterations of 8
c3b:	disp eight_reals_last_unfft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	IFDEF PFETCH
	add	al, 256/2		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/8		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 128 values

	lea	esi, [esi-2*dist128K+dist128];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist128K-dist1M+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	IFDEF PFETCH
	lea	ebp, [ebp-8*dist16K+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 16K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 2048K-element FFT using mod 2^N+1 arithmetic.  This is done
;; in three passes.  Pass 0 does 6 levels, working on every 16384th element.
;; Pass 1 does 6 levels, working on every 256th element.  Pass 2 uses common
;; code to perform the last 8 levels of the FFT.

fft2048Kp MACRO type
	LOCAL	b1b, b2b, b3b, b5b, b6b, c1b, c2b, c3b, c5b, c6b

;; Each pass 0/1 combination processes 16K values.  There are 128
;; sets of 16K values to work on.

	IF type NE 4
	mov	eax, 16			;; U - 16 iterations of 8
	mov	edi, plus1_premults	;; V - Address of the multipliers
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 128 sets of 128 values

	mov	cl, 16			;; V - 16 iterations of 8
b2b:

;; Do 16 four_complex_first_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	mov	al, 2			;; U - 2 iterations of 8
b3b:	disp four_complex_first_fft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next multipliers
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b3b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary

;; Do 16 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations of 4

	push	edi			;; U - Save premultiplier address
	lea	esi, [esi-2*dist128K]	;; V - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	eax, 2			;; V - 2 iterations of 2 iters of 4
b5b:	disp four_complex_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K+4*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	ah, 256/2		;; V - Test middle loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; U - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary

;; Do 16 four_complex_fft macros (FFT levels 5,6)
;;	distance between fft data elements is 1 * 16K

	lea	esi, [esi-2*dist1M]	;; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 8
b6b:	disp four_complex_fft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b6b			;;*V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 128 values

	lea	esi, [esi-2*dist1M+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 128 sets of 128 values to work on.

	mov	ecx, 8*256+64		;; V - 64 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_6_levels_fftp	;;UV - Do the last 6 levels
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 16K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-7*dist128K-dist1M+dist1];; V - Next src ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 4096 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123p
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4p
	ENDIF

;; Each pass 0/1 combination processes 32K values.  There are 128
;; sets of 32K values to work on.

	IF type EQ 4
end2048Kp:lea	esi, [esi-8*dist16K-7*dist128K-dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
	mov	edi, plus1_premults	;; U - Address of the multipliers
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 128 sets of 256 values to work on.

	mov	ecx, 8*256+64		;; V - 64 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_6_levels_unfftp	;;UV - Do 6 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-7*dist128K-dist1M];; U - Restore src ptr
	pop	edi			;; V - Restore premultiplier address

;; In pass 0, we work on 128 sets of 128 values

	mov	cl, 16			;; U - 16 iterations of 8
c2b:

;; Do 16 four_complex_unfft macros (FFT levels 5,6)
;;	distance between fft data elements is 1 * 16K

	push	edi			;; U - Save premultiplier address
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 8
c6b:	disp four_complex_unfft, dist16K, 2*dist16K, 4*dist16K
	lea	esi, [esi+dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c6b			;;*V - Iterate if necessary

;; Do 16 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 4 * 16K
;;	do 4 iterations of 4

	lea	esi, [esi-2*dist1M]	;; U - Next source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	eax, 2			;; U - 2 iterations of 2 iters of 4
c5b:	disp four_complex_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist16K+4*dist128K];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	ah, 256/2		;; V - Test middle loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; U - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Do 16 four_complex_last_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 16 * 16K
;;	do 16 iterations

	lea	esi, [esi-2*dist1M]	;; U - Load source pointer
	mov	al, 2			;; V - 2 iterations of 8
c3b:	disp four_complex_last_unfft, 2*dist128K, 4*dist128K, dist1M
	lea	esi, [esi+dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next sine/cosine pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c3b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 128 values

	lea	esi, [esi-2*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 16K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V- Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 2560K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft2560K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, b6c, b6d
	LOCAL	c1b, c2b, c3b, c4b, c5b, c6b, c6c

;; Each pass 0/1 combination processes 20K values.  There are 128
;; sets of 20K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 80 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume next block is 512 away
	test	ecx, 80000000h		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	lea	ebp, [esi-4*dist128+dist16K];; Assume next block is 16K away
	test	ch, 256/2		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	b2b			;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	mov	al, [ebp+dist1M+4*dist128K+256]
	mov	al, [ebp+dist1M+5*dist128K+256]
	mov	al, [ebp+dist1M+6*dist128K+256]
	mov	al, [ebp+dist1M+7*dist128K+256]
	mov	al, [ebp+2*dist1M+0*dist128K+256]
	mov	al, [ebp+2*dist1M+1*dist128K+256]
	mov	al, [ebp+2*dist1M+2*dist128K+256]
	mov	al, [ebp+2*dist1M+3*dist128K+256]
	ENDIF
b2b:

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	mov	eax, 4			;; U - 4 iterations of 4
b3b:	disp five_reals_first_fft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

	lea	esi, [esi-4*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 8 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 2 iterations of 4

	lea	esi, [esi-4*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 4
b5b:
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	disp four_complex_fft, dist128K, 2*dist128K, (dist1M-4*dist128K)
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi-4*dist128K-2*dist1M];; U - Load source pointer
	disp eight_reals_fft_1, 2*dist16K, 4*dist16K, dist128K

;; Do 9 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
;;	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/4*256+9	;; U - 9 iterations (3, 4, 2 iters)
b6b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	test	al, 1			;; Prefetch on 4 of the 9 iterations
	jnz	short b6c
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
b6c:	dec	al			;; U - Test total loop counter
	jz	short b6d		;; V - Jump if done
	add	ah, 256/4		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	jmp	b6b			;; V - Iterate if necessary
b6d:

;; Point to next set of 80 values

	lea	esi, [esi-4*dist128K-2*dist1M+dist128];; U - Next src ptr
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist128K-2*dist1M+2*dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ecx, 80000000h		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 80 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+39	;; V - 39 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 20K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-3*dist128K-2*dist1M+dist1];; V - Next ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 5119 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 20K values.  There are 128
;; sets of 20K values to work on.

	IF type EQ 4
end2560K:lea	esi, [esi-8*dist16K-3*dist128K-2*dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 80 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+39	;; V - 39 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-3*dist128K-2*dist1M];; U - Restore src ptr

;; In pass 0, we work on 256 sets of 80 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	disp eight_reals_unfft_1, 2*dist16K, 4*dist16K, dist128K

;; Do 9 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/4*256+9	;; U - 9 iterations
c6b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test total loop counter
	jz	short c6c		;; V - Jump if done
	add	ah, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	jmp	c6b			;; V - Iterate if necessary
c6c:

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

	lea	esi, [esi-4*dist128K-2*dist1M];; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 8 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 2 iterations of 4

	lea	esi, [esi-4*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 4
c5b:	disp four_complex_unfft, dist128K, 2*dist128K, (dist1M-4*dist128K)
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary

;; Do 16 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	lea	esi, [esi-4*dist128K-2*dist1M];; U - Load source pointer
	mov	al, 4			;; V - 4 iterations of 4
c3b:	disp five_reals_last_unfft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 80 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 20K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 3072K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft3072K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, c1b, c2b, c3b, c4b, c5b, c6b

;; Each pass 0/1 combination processes 24K values.  There are 128
;; sets of 24K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 96 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume next block is 512 away
	test	ecx, 80000000h		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	lea	ebp, [esi-4*dist128+dist16K];; Assume next block is 16K away
	test	ch, 256/2		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	b2b			;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K];; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	mov	al, [ebp+dist1M+4*dist128K+256]
	mov	al, [ebp+dist1M+5*dist128K+256]
	mov	al, [ebp+dist1M+6*dist128K+256]
	mov	al, [ebp+dist1M+7*dist128K+256]
	mov	al, [ebp+2*dist1M+0*dist128K+256]
	mov	al, [ebp+2*dist1M+1*dist128K+256]
	mov	al, [ebp+2*dist1M+2*dist128K+256]
	mov	al, [ebp+2*dist1M+3*dist128K+256]
	mov	al, [ebp+2*dist1M+4*dist128K+256]
	mov	al, [ebp+2*dist1M+5*dist128K+256]
	mov	al, [ebp+2*dist1M+6*dist128K+256]
	mov	al, [ebp+2*dist1M+7*dist128K+256]
	ENDIF
b2b:

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	mov	eax, 4			;; U - 4 iterations of 4
b3b:	disp six_reals_first_fft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 32K
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi-4*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 4*dist16K, dist128K, 2*dist128K
	dispc two_two_complex_fft_2, 4*dist16K, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 8 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 2 iterations of 4

	lea	esi, [esi-4*dist16K+dist1M];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 4
b5b:
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	disp four_complex_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi-3*dist1M]	;; U - Load source pointer
	disp eight_reals_fft_1, 2*dist16K, 4*dist16K, dist128K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	prefetcht0 [ebp+dist128K]
	lea	ebp, [ebp+2*dist128K]
	ENDIF

;; Do 11 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
;;	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	al, 256/4+3		;; U - 3 iterations of 3 or 4
b6b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	prefetcht0 [ebp+dist128K]
	lea	ebp, [ebp+2*dist128K]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	b6b			;;*V - Iterate if necessary

;; Point to next set of 96 values

	lea	esi, [esi-3*dist1M+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K-2*dist1M+2*dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ecx, 80000000h		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 96 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+47	;; V - 47 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 24K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-7*dist128K-2*dist1M+dist1];; V - Next ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 6143 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 24K values.  There are 128
;; sets of 24K values to work on.

	IF type EQ 4
end3072K:lea	esi, [esi-8*dist16K-7*dist128K-2*dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 96 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+47	;; V - 47 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-7*dist128K-2*dist1M];; U - Restore src ptr

;; In pass 0, we work on 256 sets of 96 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	disp eight_reals_unfft_1, 2*dist16K, 4*dist16K, dist128K

;; Do 11 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	al, 256/4+3		;; U - 3 iterations of 3 or 4
c6b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c6b			;;*V - Iterate if necessary

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

;; Do 4 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 32K
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations
;; Do nothing (FFT level 4)
;; This will turn these 8 complex values into 16 real values.

	lea	esi, [esi-3*dist1M]	;; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 4*dist16K, dist128K, 2*dist128K
	dispc two_two_complex_unfft_2, 4*dist16K,dist128K,2*dist128K,4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 8 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 2 iterations of 4

	lea	esi, [esi-4*dist16K+dist1M];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 2			;; U - 2 iterations of 4
c5b:	disp four_complex_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary

;; Do 16 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	lea	esi, [esi-3*dist1M]	;; U - Load source pointer
	mov	al, 4			;; V - 4 iterations of 4
c3b:	disp six_reals_last_unfft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 96 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 24K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 3584K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft3584K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, b6c, b6d
	LOCAL	c1b, c2b, c3b, c4b, c5b, c6b, c6c

;; Each pass 0/1 combination processes 28K values.  There are 128
;; sets of 28K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 112 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume next block is 512 away
	test	ecx, 80000000h		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	lea	ebp, [esi-4*dist128+dist16K];; Assume next block is 16K away
	and	ch, ch	 		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	b2b			;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K] ;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	mov	al, [ebp+dist1M+4*dist128K+256]
	mov	al, [ebp+dist1M+5*dist128K+256]
	mov	al, [ebp+dist1M+6*dist128K+256]
	mov	al, [ebp+dist1M+7*dist128K+256]
	mov	al, [ebp+2*dist1M+0*dist128K+256]
	mov	al, [ebp+2*dist1M+1*dist128K+256]
	mov	al, [ebp+2*dist1M+2*dist128K+256]
	mov	al, [ebp+2*dist1M+3*dist128K+256]
	mov	al, [ebp+2*dist1M+4*dist128K+256]
	mov	al, [ebp+2*dist1M+5*dist128K+256]
	mov	al, [ebp+2*dist1M+6*dist128K+256]
	mov	al, [ebp+2*dist1M+7*dist128K+256]
	mov	al, [ebp+3*dist1M+0*dist128K+256]
	mov	al, [ebp+3*dist1M+1*dist128K+256]
	mov	al, [ebp+3*dist1M+2*dist128K+256]
	mov	al, [ebp+3*dist1M+3*dist128K+256]
	ENDIF
b2b:

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	mov	al, 4			;; U - 4 iterations of 4
b3b:	disp seven_reals_first_fft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-2*dist128K+dist1M]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist1M+4*dist128K]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

	lea	esi, [esi-4*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 12 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 3 iterations of 4

	lea	esi, [esi-4*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 3			;; U - 3 iterations of 4
b5b:
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	disp four_complex_fft, dist128K, 2*dist128K, (dist1M-4*dist128K)
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-4*dist128K+dist1M]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-3*dist1M-4*dist128K+2*dist128K]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi-4*dist128K-3*dist1M];; U - Load source pointer
	disp eight_reals_fft_1, 2*dist16K, 4*dist16K, dist128K
	IFDEF	PFETCH
	prefetcht0 [ebp+3*dist1M+dist128K]
	ENDIF

;; Do 13 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
;;	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/4*256+13	;; U - 13 iterations
b6b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	test	al, 1			;; Prefetch on 7 of the 13 iterations
	jz	short b6c
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
b6c:	dec	al			;; U - Test total loop counter
	jz	short b6d		;; V - Jump if done
	add	ah, 256/4		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-2*dist128K+dist1M]
	ENDIF
	jmp	b6b			;; V - Iterate if necessary
b6d:

;; Point to next set of 112 values

	lea	esi, [esi-4*dist128K-3*dist1M+dist128];; U - Next src ptr
	IFDEF	PFETCH
	lea	ebp, [ebp-dist128K-3*dist1M-2*dist128K+2*dist16K]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ecx, 80000000h		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 112 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+55	;; V - 55 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 28K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-3*dist128K-3*dist1M+dist1];; V - Next ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 7167 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 28K values.  There are 128
;; sets of 28K values to work on.

	IF type EQ 4
end3584K:lea	esi, [esi-8*dist16K-3*dist128K-3*dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 112 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+55	;; V - 55 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-3*dist128K-3*dist1M];; U - Restore src ptr

;; In pass 0, we work on 256 sets of 112 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	disp eight_reals_unfft_1, 2*dist16K, 4*dist16K, dist128K

;; Do 13 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, 256/4*256+13	;; U - 13 iterations
c6b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test total loop counter
	jz	short c6c		;; V - Jump if done
	add	ah, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	jmp	c6b			;; V - Iterate if necessary
c6c:

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

	lea	esi, [esi-4*dist128K-3*dist1M];; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 4*dist16K, dist128K, 2*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary

;; Do 12 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 3 iterations of 4

	lea	esi, [esi-4*dist16K+4*dist128K];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	al, 3			;; U - 3 iterations of 4
c5b:	disp four_complex_unfft, dist128K, 2*dist128K, (dist1M-4*dist128K)
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary

;; Do 16 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	lea	esi, [esi-4*dist128K-3*dist1M];; U - Load source pointer
	mov	al, 4			;; V - 4 iterations of 4
c3b:	disp seven_reals_last_unfft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 112 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 28K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 4096K-element FFT.  This is done in three passes.  Pass 0
;; does 7 levels, working on every 32768th element.  Pass 1 does 7 levels,
;; working on every 256th element.  Pass 2 uses common code to perform the
;; last 8 levels of the FFT.

fft4096K MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, c1b, c2b, c3b, c4b, c5b, c6b

;; Each pass 0/1 combination processes 32K values.  There are 128
;; sets of 32K values to work on.

	IF type NE 4
	IFDEF	PFETCH
	push	ebp
	ENDIF
	mov	eax, 16			;; U - 16 iterations of 8
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 128 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2a:
	IFDEF	PFETCH
	lea	ebp, [esi+4*dist128]	;; Assume next block is 512 away
	test	ecx, 80000000h		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	lea	ebp, [esi-4*dist128+dist16K];; Assume next block is 16K away
	and	ch, ch	 		;; Is it?
	jz	b2b			;; Yes, no TLB priming needed
	mov	ebp, esi		;; Assume no prefetching
	cmp	cl, 1			;; Test for last block of values
	je	b2b			;; It is last block, no prefetching
	lea	ebp, [esi-4*dist128-dist16K+dist1K] ;; Next block is 1K away
	mov	al, [ebp+0*dist128K+256];; Read from this page (loads the TLB)
	mov	al, [ebp+1*dist128K+256]
	mov	al, [ebp+2*dist128K+256]
	mov	al, [ebp+3*dist128K+256]
	mov	al, [ebp+4*dist128K+256]
	mov	al, [ebp+5*dist128K+256]
	mov	al, [ebp+6*dist128K+256]
	mov	al, [ebp+7*dist128K+256]
	mov	al, [ebp+dist1M+0*dist128K+256]
	mov	al, [ebp+dist1M+1*dist128K+256]
	mov	al, [ebp+dist1M+2*dist128K+256]
	mov	al, [ebp+dist1M+3*dist128K+256]
	mov	al, [ebp+dist1M+4*dist128K+256]
	mov	al, [ebp+dist1M+5*dist128K+256]
	mov	al, [ebp+dist1M+6*dist128K+256]
	mov	al, [ebp+dist1M+7*dist128K+256]
	mov	al, [ebp+2*dist1M+0*dist128K+256]
	mov	al, [ebp+2*dist1M+1*dist128K+256]
	mov	al, [ebp+2*dist1M+2*dist128K+256]
	mov	al, [ebp+2*dist1M+3*dist128K+256]
	mov	al, [ebp+2*dist1M+4*dist128K+256]
	mov	al, [ebp+2*dist1M+5*dist128K+256]
	mov	al, [ebp+2*dist1M+6*dist128K+256]
	mov	al, [ebp+2*dist1M+7*dist128K+256]
	mov	al, [ebp+3*dist1M+0*dist128K+256]
	mov	al, [ebp+3*dist1M+1*dist128K+256]
	mov	al, [ebp+3*dist1M+2*dist128K+256]
	mov	al, [ebp+3*dist1M+3*dist128K+256]
	mov	al, [ebp+3*dist1M+4*dist128K+256]
	mov	al, [ebp+3*dist1M+5*dist128K+256]
	mov	al, [ebp+3*dist1M+6*dist128K+256]
	mov	al, [ebp+3*dist1M+7*dist128K+256]
	ENDIF
b2b:

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	mov	eax, 4			;; U - 4 iterations of 4
b3b:	disp eight_reals_first_fft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+2*dist16K]
	ENDIF

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 32K
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi-4*dist128K]	;; U - Next source pointer
b4b:	disp eight_reals_funny_fft, 4*dist16K, dist128K, 2*dist128K
	dispc two_two_complex_fft_2, 4*dist16K, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	al, 256/2		;; V - Test loop counter
	jnc	b4b			;;*V - Iterate if necessary

;; Do 12 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 3 iterations of 4

	lea	esi, [esi-4*dist16K+dist1M];; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	al, 3			;; U - 3 iterations of 4
b5b:	disp four_complex_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF	PFETCH
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist128K+2*dist16K]
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi-4*dist1M]	;; U - Load source pointer
	disp eight_reals_fft_1, 2*dist16K, 4*dist16K, dist128K
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 15 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	al, 256/4+4		;; U - 4 iterations of 3 or 4
b6b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF	PFETCH
	prefetcht0 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	add	al, 256/4		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	IFDEF	PFETCH
	add	ah, 256/2		;; U - Test outer loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	ebp, [ebp-8*dist128K+2*dist16K]
	add	eax, 80000000h		;; U - Test outer loop counter
	jnc	b6b			;; V - Iterate if necessary
	ELSE
	dec	al			;; V - Test outer loop counter
	jnz	b6b			;;*V - Iterate if necessary
	ENDIF

;; Point to next set of 128 values

	lea	esi, [esi-4*dist1M+dist128];; U - Next source pointer
	IFDEF	PFETCH
	lea	ebp, [ebp-8*dist16K+dist1M]
	add	cl, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	add	ecx, 80000000h		;; Test middle loop counter
	jnc	b2a			;; Iterate if necessary
	ELSE
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 128 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+63	;; V - 63 iters of 2 complex sections
	CALLP	pass1_7_levels_fft	;;UV - Do 7 levels of the FFT

;; Point to next set of 32K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-7*dist128K-3*dist1M+dist1];; V - Next ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 1 pass2_eight_levels_real and 8191 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4
	ENDIF

;; Each pass 0/1 combination processes 32K values.  There are 128
;; sets of 32K values to work on.

	IF type EQ 4
end4096K:lea	esi, [esi-8*dist16K-7*dist128K-3*dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
c1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 1 there are 128 sets of 256 values to work on.

	mov	ecx, 256/2*256+8*256+63	;; V - 63 iters of 2 complex sections
	CALLP	pass1_7_levels_unfft	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-7*dist128K-3*dist1M];; U - Restore src ptr

;; In pass 0, we work on 256 sets of 128 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
	IFDEF PFETCH512
	mov	ebp, pass1blkdst
	add	ebp, esi
	ENDIF
c2b:

;; Do 1 eight_reals_unfft_1 macros (FFT level 7)
;;	distance between fft data elements is 1 * 32K

	disp eight_reals_unfft_1, 2*dist16K, 4*dist16K, dist128K

;; Do 15 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi+2*dist128K]	;; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	al, 256/4+4		;; U - 4 iterations of 3 or 4
c6b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	c6b			;;*V - Iterate if necessary

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * 32K
;;	do 2 iterations

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.
;; Do 4 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 4 * 32K
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.
;;	do 2 iterations

	lea	esi, [esi-4*dist1M]	;; U - Next source pointer
c4b:	disp eight_reals_funny_unfft, 4*dist16K, dist128K, 2*dist128K
	dispc two_two_complex_unfft_2, 4*dist16K,dist128K,2*dist128K,4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	jnc	c4b			;;*V - Iterate if necessary
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF

;; Do 12 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * 32K
;;	do 3 iterations of 4

	lea	esi, [esi-4*dist16K+dist1M];; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	mov	al, 3			;; U - 3 iterations of 4
c5b:	disp four_complex_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	IFDEF PFETCH512
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	ENDIF
	dec	al			;; V - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist128K+dist1M]
	ENDIF

;; Do 16 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	lea	esi, [esi-4*dist1M]	;; U - Load source pointer
	mov	eax, 4			;; V - 4 iterations of 4
c3b:	disp eight_reals_last_unfft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	IFDEF PFETCH512
	add	al, 256/2		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	prefetch64 [ebp]
	lea	ebp, [ebp+dist128K]
	add	ah, 256/2		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ELSE
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c3b			;;*V - Iterate if necessary
	ENDIF
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 128 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist128K-dist1M+dist16K]
	ENDIF
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-8*dist16K+2*dist1M]
	ENDIF
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	IFDEF PFETCH512
	lea	ebp, [ebp-4*dist1M+dist1K]
	ENDIF
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 32K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;; Perform a 4096K-element FFT using mod 2^N+1 arithmetic.  This is done
;; in three passes.  Pass 0 does 6 levels, working on every 32768th element.
;; Pass 1 does 7 levels, working on every 256th element.  Pass 2 uses common
;; code to perform the last 8 levels of the FFT.

fft4096Kp MACRO type
	LOCAL	b1b, b2b, b3b, b5b, b6b, c1b, c2b, c3b, c5b, c6b

;; Each pass 0/1 combination processes 32K values.  There are 128
;; sets of 32K values to work on.

	IF type NE 4
	mov	eax, 16			;; U - 16 iterations of 8
	mov	edi, plus1_premults	;; V - Address of the multipliers
b1b:	push	eax			;; U - Save loop counter
	set_pass1blkdst

;; In pass 0, we work on 256 sets of 128 values

	mov	ecx, 16			;; V - 16 iterations of 2 of 8
b2b:

;; Do 16 four_complex_first_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	mov	al, 4			;; U - 4 iterations of 4
b3b:	disp four_complex_first_fft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next multipliers
	add	al, 256/4		;; U - Test inner loop counter
	jnc	b3b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b3b			;;*V - Iterate if necessary

;; Do 16 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations of 4

	push	edi			;; U - Save premultiplier address
	lea	esi, [esi-4*dist128K]	;; V - Next source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 4
b5b:	disp four_complex_fft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	b5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	b5b			;; V - Iterate if necessary

;; Do 16 four_complex_fft macros (FFT levels 5,6)
;;	distance between fft data elements is 1 * 32K

	lea	esi, [esi-4*dist1M]	;; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 4			;; U - 4 iterations of 4
b6b:	disp four_complex_fft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	b6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b6b			;;*V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 128 values

	lea	esi, [esi-4*dist1M+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1K]	;; U - Restore source pointer

;; In pass 1 there are 128 sets of 256 values to work on.

	mov	ecx, 8*256+64		;; V - 64 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_7_levels_fftp	;;UV - Do 7 levels of the FFT
	pop	edi			;; V - Restore premultiplier address

;; Point to next set of 32K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-8*dist16K-7*dist128K-3*dist1M+dist1];; V - Next ptr
	add	al, 256/8		;; U - Test inner loop counter
	jnc	b1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist8]	;; U - Restore source pointer
	IFDEF	PFETCH
	pop	ebp
	ENDIF
	ENDIF

;; Do the last eight FFT levels
;;	do 8192 pass2_eight_levels_complex

	IF	type NE 4
	JMPP	pass2_8_levels_type_123p
	ENDIF
	IF	type EQ 4
	CALLP	pass2_8_levels_type_4p
	ENDIF

;; Each pass 0/1 combination processes 32K values.  There are 128
;; sets of 32K values to work on.

	IF type EQ 4
end4096Kp:lea	esi, [esi-8*dist16K-7*dist128K-3*dist1M];; U - Restore src ptr
	mov	eax, 16			;; V - 16 iterations of 8
	mov	edi, plus1_premults	;; U - Address of the multipliers
c1b:	push	eax			;; U - Save loop counter

;; In pass 1 there are 128 sets of 256 values to work on.

	mov	ecx, 8*256+64		;; V - 64 iters of 2 complex sections
	push	edi			;; U - Save premultiplier address
	CALLP	pass1_7_levels_unfftp	;;UV - Do 7 levels of the inverse FFT
	lea	esi, [esi-8*dist16K-7*dist128K-3*dist1M];; U - Restore src ptr
	pop	edi			;; V - Restore premultiplier address

;; In pass 0, we work on 256 sets of 128 values

	mov	ecx, 16			;; U - 16 iterations of 2 of 8
c2b:

;; Do 16 four_complex_unfft macros (FFT levels 5,6)
;;	distance between fft data elements is 1 * 32K

	push	edi			;; U - Save premultiplier address
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 4			;; U - 4 iterations of 4
c6b:	disp four_complex_unfft, 2*dist16K, 4*dist16K, dist128K
	lea	esi, [esi+2*dist128K]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	c6b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist128K+dist1M];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c6b			;;*V - Iterate if necessary

;; Do 16 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 4 * 32K
;;	do 4 iterations of 4

	lea	esi, [esi-4*dist1M]	;; U - Next source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 4			;; U - 4 iterations of 4
c5b:	disp four_complex_unfft, dist128K, 2*dist128K, 4*dist128K
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	jnc	c5b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist1M];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	jnz	c5b			;; V - Iterate if necessary
	pop	edi			;; V - Restore premultiplier address

;; Do 16 four_complex_last_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 16 * 32K
;;	do 16 iterations

	lea	esi, [esi-4*dist1M]	;; U - Load source pointer
	mov	al, 4			;; V - 4 iterations of 4
c3b:	disp four_complex_last_unfft, 4*dist128K, dist1M, 2*dist1M
	lea	esi, [esi+2*dist16K]	;; U - Next source pointer
	lea	edi, [edi+PMD]		;; V - Next sine/cosine pointer
	add	al, 256/4		;; U - Test inner loop counter
	jnc	c3b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist16K+dist128K];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c3b			;;*V - Iterate if necessary

;; Point to next set of 128 values

	lea	esi, [esi-4*dist128K+dist128];; U - Next source pointer
	add	cl, 256/8		;; V - Test inner loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist128+dist16K];; U - Next source pointer
	add	ch, 256/2		;; V - Test middle loop counter
	jnc	c2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist16K+dist1K];; U - Next source pointer
	dec	cl			;; V - Test outer loop counter
	jnz	c2b			;;*V - Iterate if necessary

;; Point to next set of 32K values

	pop	eax			;; U - Restore loop counter
	lea	esi, [esi-16*dist1K+dist1];; V - Next source pointer
	add	al, 256/8		;; U - Test inner loop counter
	jnc	c1b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+dist8];; U - Next source pointer
	dec	al			;; V - Test outer loop counter
	jnz	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

;;
;; Utility macros
;;

set_pass1blkdst MACRO
	LOCAL xxx
	IFDEF PFETCH
	mov	ecx, dist1
	cmp	al, 7*256/8
	jb	xxx
	mov	ecx, dist1-8*dist1+dist8
xxx:	mov	pass1blkdst, ecx
	ENDIF
	ENDM
