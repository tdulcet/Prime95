; Copyright 2001-2002 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros perform the large 2 pass FFTs using SSE2 instructions.
;

; ********************************************************
; ********************************************************
; ********************  FFT MACROS  **********************
; ********************************************************
; ********************************************************

; Note:  All memory layouts are for 64 byte L1 cache lines.  The high
; order XMM words are not shown (they are 1K higher than the low
; order XMM word.  Since the L2 cache reads 128 byte cache lines, two
; 64 byte cache lines are processed at a time.  The second 64 byte
; cache line contains a completely independent set of data.


;; Perform a 40K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft40K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 4 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 18
c2b:	x1cl_half_eight_reals_unfft_2 esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*2*blkdst-blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 8 five_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 40 data values

start_timer 19
c1b:	x5cl_five_reals_last_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 40 data values

b0b:
start_timer 21
	sub	eax, eax		;; 1 iteration of 2
b1b:	x5cl_five_reals_first_fft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 16K-39K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 22
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-blkdst];; Restore source pointer
end_timer 22

;; Work on next 4 sets of 20 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	sub	eax, eax		;; 1 iteration of 2
d1b:	x5cl_five_reals_first_fft esi, 5*64, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*5*64]	;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x1cl_half_eight_reals_fft_2 esi, 5*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*5*64+64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3b:	x4cl_four_complex_fft esi, 5*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 48K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft48K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 5 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 18
c2b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*2*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K

;; Do 16 six_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 24 data values

start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 4 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 2			;; 2 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-47K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 22
b2b:	x2cl_eight_reals_fft_2 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-2*blkdst];; Restore source pointer
end_timer 22

;; Work on next 4 sets of 24 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 2			;; 2 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 6*64, 2*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*6*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x2cl_eight_reals_fft_2 esi, 6*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*6*64+2*64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3b:	x4cl_four_complex_fft esi, 6*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 56K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft56K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3a, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 6 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 18
c2b:	x1cl_half_eight_reals_unfft_2 esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*2*blkdst-blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 16 seven_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 56 data values

start_timer 19
c1b:	x7cl_seven_reals_last_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+5*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 56 data values

b0b:
start_timer 21
	sub	eax, eax
b1b:	x7cl_seven_reals_first_fft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-55K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 22
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3a:	x2cl_four_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b3a

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-3*blkdst];; Restore source pointer
end_timer 22

;; Work on next 4 sets of 28 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	sub	eax, eax		;; 1 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 7*64, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*7*64]	;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x1cl_half_eight_reals_fft_2 esi, 7*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*7*64+64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3a:	x2cl_four_complex_fft esi, 7*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary

	lea	esi, [esi-2*7*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
d3b:	x4cl_four_complex_fft esi, 7*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 64K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft64K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 7 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 18
c2b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	c2b

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*2*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K

;; Do 16 eight_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 8 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+6*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-63K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 22
	mov	edi, sincos1		;; Load sin/cos pointer
b2b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-4*blkdst];; Restore source pointer
end_timer 22

;; Work on next 4 sets of 32 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 8*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*8*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos1		;; Load sin/cos pointer
d2b:	x4cl_eight_reals_fft_2 esi, 8*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*8*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
d3b:	x4cl_four_complex_fft esi, 8*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 80K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft80K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 9 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 36 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

start_timer 18
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*4*blkdst-2*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 32 five_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 40 data values

start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 32 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 40 data values

b0b:
start_timer 21
	mov	eax, 2			;; 2 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+3*blkdst]
	prefetcht1 [esi-128+5*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	prefetcht1 [esi-128+9*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 8 data values

start_timer 22
	mov	al, 2			;; 2 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-2*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 32 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*2*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 40 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 2			;; 2 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 10*64, 2*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 10*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 10*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-2*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 10*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*10*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d5b:	x2cl_two_complex_fft esi, 10*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 96K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft96K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 11 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 22 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

start_timer 18
c2b:	x4cl_eight_reals_unfft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*4*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 32 six_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 24 data values

start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 32 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 8 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+5*blkdst]
	prefetcht1 [esi-128+9*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 16 data values

start_timer 22
	mov	al, 2			;; 2 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-4*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 40 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 10 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*2*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 48 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 12*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 12*64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*64+4*64]	;; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 12*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-4*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 12*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*12*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
d5b:	x2cl_two_complex_fft esi, 12*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 112K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft112K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 13 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 52 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

start_timer 18
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 6 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*4*blkdst-2*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 32 seven_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 56 data values

start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+10*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 32 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 56 data values

b0b:
start_timer 21
	mov	eax, 2			;; 2 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 8 data values

start_timer 22
	mov	al, 2			;; 2 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-6*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-111K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 48 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*2*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 56 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 2			;; 2 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 14*64, 2*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 14*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3a:	x2cl_four_complex_fft esi, 14*64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-2*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 14*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-6*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 14*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*14*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
d5b:	x2cl_two_complex_fft esi, 14*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 128K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft128K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 15 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 60 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

start_timer 18
c2b:	x4cl_eight_reals_unfft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c2b

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 6 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*4*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K

;; Do 32 eight_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 16 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+12*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

start_timer 22
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-8*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 56 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 14 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*2*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 64 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 16*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 16*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-2*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 16*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-8*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 16*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*16*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
d5b:	x2cl_two_complex_fft esi, 16*64, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 160K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft160K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 19 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 72 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*8*blkdst-4*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 64 five_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 40 data values

start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 64 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 40 data values

b0b:
start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+5*blkdst]
	prefetcht1 [esi-128+9*blkdst]
	prefetcht1 [esi-128+13*blkdst]
	prefetcht1 [esi-128+17*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-159K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 8 data values

start_timer 22
	mov	al, 4			;; 4 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-4*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-159K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 80 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 20*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 20*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 20*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-4*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 20*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*20*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d5b:	x4cl_four_complex_fft esi, 20*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 192K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft192K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 23 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 44 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*8*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 64 six_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 24 data values

start_timer 19
	mov	al, 8			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 64 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 16 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+blkdst]
	prefetcht1 [esi-128+9*blkdst]
	prefetcht1 [esi-128+17*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

start_timer 22
	mov	al, 4			;; 4 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-8*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 40 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 10 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 96 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 24*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 24*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 24*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-8*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 24*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*24*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
d5b:	x4cl_four_complex_fft esi, 24*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 224K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft224K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 27 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 52 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*8*blkdst-4*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 64 seven_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 56 data values

start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+20*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 64 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 56 data values

b0b:
start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+10*blkdst]
	prefetcht1 [esi-128+14*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+22*blkdst]
	prefetcht1 [esi-128+26*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 8 data values

start_timer 22
	mov	al, 4			;; 4 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	add	cl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-12*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 48 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 112 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 4			;; 4 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 28*64, 4*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 28*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3a:	x2cl_four_complex_fft esi, 28*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 28*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-12*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 28*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*28*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
d5b:	x4cl_four_complex_fft esi, 28*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 256K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft256K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 31 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm		;; Load loop counter
c0b:

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 60 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+6*blkdst]
	add	cl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*8*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K

;; Do 64 eight_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 19
	mov	al, 8			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+16*blkdst]
	prefetcht1 [esi-128+clm*128+24*blkdst]
	add	cl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 32 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 16			;; 16 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+20*blkdst]
	add	cl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 22
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+4*blkdst]
	prefetcht1 [esi-128+clm*128+8*blkdst]
	prefetcht1 [esi-128+clm*128+12*blkdst]
	add	cl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-16*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	add	cl, 256/clm
	jnc	b4b

;; Do 56 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 14 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm*128]
	prefetcht1 [esi-128+clm*128+blkdst]
	prefetcht1 [esi-128+clm*128+2*blkdst]
	prefetcht1 [esi-128+clm*128+3*blkdst]
	add	cl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 128 values

no_fft:	lea	esi, [esi+clm*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 32*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 32*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 32*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-16*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 32*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary

	lea	esi, [esi-2*32*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
d5b:	x4cl_four_complex_fft esi, 32*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d5b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 320K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft320K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm320K	;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 39 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm320K	;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm320K	;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 76 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 38 macros each processing 16 data values

	lea	esi, [esi-2*clm320K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 19			;; 19 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm320K
	jnc	c7b
	lea	esi, [esi-2*clm320K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-20*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+2*blkdst]
	add	cl, 256/clm320K
	jnc	c4b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 72 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 36 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+2*blkdst]
	add	cl, 256/clm320K
	jnc	c5b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*4*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 16 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+4*blkdst]
	add	cl, 256/clm320K
	jnc	c2b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+4*blkdst]
	prefetcht1 [esi-128+clm320K*128+8*blkdst]
	prefetcht1 [esi-128+clm320K*128+12*blkdst]
	add	cl, 256/clm320K
	jnc	c3b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*16*blkdst-8*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 128 five_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 40 data values

start_timer 19
	mov	al, 8			;; 8 iterations of 2
c1b:	x5cl_five_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+8*blkdst]
	prefetcht1 [esi-128+clm320K*128+16*blkdst]
	prefetcht1 [esi-128+clm320K*128+24*blkdst]
	prefetcht1 [esi-128+clm320K*128+32*blkdst]
	add	cl, 256/clm320K
	jnc	c1b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 128 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 40 data values

b0b:
start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+10*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+26*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	add	cl, 256/clm320K
	jnc	b1b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-319K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 8 data values

start_timer 22
	mov	al, 8			;; 8 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	add	cl, 256/clm320K
	jnc	b2b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+8*blkdst]
	prefetcht1 [esi-128+clm320K*128+16*blkdst]
	prefetcht1 [esi-128+clm320K*128+24*blkdst]
	add	cl, 256/clm320K
	jnc	b3b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-8*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+4*blkdst]
	add	cl, 256/clm320K
	jnc	b4b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+4*blkdst]
	add	cl, 256/clm320K
	jnc	b5b
	lea	esi, [esi-2*clm320K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*8*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm320K
	jnc	b6b

;; Do 72 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 32 data values

	lea	esi, [esi-2*clm320K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm320K*128]
	prefetcht1 [esi-128+clm320K*128+blkdst]
	prefetcht1 [esi-128+clm320K*128+2*blkdst]
	prefetcht1 [esi-128+clm320K*128+3*blkdst]
	add	cl, 256/clm320K
	jnc	b7b
	lea	esi, [esi-2*clm320K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-10*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 160 values

no_fft:	lea	esi, [esi+clm320K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 40*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 40*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 40*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-8*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 40*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 40*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-5*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 40*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*40*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2
d7b:	x4cl_four_complex_fft esi, 40*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 384K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft384K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm384K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 47 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm384K		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm384K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 92 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 46 macros each processing 16 data values

	lea	esi, [esi-2*clm384K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 23			;; 23 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm384K
	jnc	c7b
	lea	esi, [esi-2*clm384K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-24*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+2*blkdst]
	add	cl, 256/clm384K
	jnc	c4b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 88 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 44 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+2*blkdst]
	add	cl, 256/clm384K
	jnc	c5b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*4*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft_2 macros
;; Do 16 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+4*blkdst]
	prefetcht1 [esi-128+clm384K*128+8*blkdst]
	prefetcht1 [esi-128+clm384K*128+12*blkdst]
	add	cl, 256/clm384K
	jnc	c2b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+4*blkdst]
	prefetcht1 [esi-128+clm384K*128+8*blkdst]
	prefetcht1 [esi-128+clm384K*128+12*blkdst]
	add	cl, 256/clm384K
	jnc	c3b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*16*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 128 six_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 24 data values

start_timer 19
	mov	al, 16			;; 16 iterations of 2
c1b:	x3cl_six_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+16*blkdst]
	prefetcht1 [esi-128+clm384K*128+32*blkdst]
	add	cl, 256/clm384K
	jnc	c1b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 128 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 32 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 16			;; 16 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	add	cl, 256/clm384K
	jnc	b1b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, and
;; 128K-383K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 16 data values

start_timer 22
	mov	al, 8			;; 8 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+8*blkdst]
	add	cl, 256/clm384K
	jnc	b2b
	lea	esi, [esi-2*clm384K*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+8*blkdst]
	prefetcht1 [esi-128+clm384K*128+16*blkdst]
	prefetcht1 [esi-128+clm384K*128+24*blkdst]
	add	cl, 256/clm384K
	jnc	b3b
	lea	esi, [esi-2*clm384K*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-16*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+4*blkdst]
	add	cl, 256/clm384K
	jnc	b4b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 80 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+4*blkdst]
	add	cl, 256/clm384K
	jnc	b5b
	lea	esi, [esi-2*clm384K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*8*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm384K
	jnc	b6b

;; Do 88 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 32 data values

	lea	esi, [esi-2*clm384K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm384K*128]
	prefetcht1 [esi-128+clm384K*128+blkdst]
	prefetcht1 [esi-128+clm384K*128+2*blkdst]
	prefetcht1 [esi-128+clm384K*128+3*blkdst]
	add	cl, 256/clm384K
	jnc	b7b
	lea	esi, [esi-2*clm384K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-12*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 192 values

no_fft:	lea	esi, [esi+clm384K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 48*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 48*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-8*64+16*64]	;; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 48*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-16*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 48*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 48*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-6*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 48*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*48*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2
d7b:	x4cl_four_complex_fft esi, 48*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 448K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft448K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm448K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 55 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm448K		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm448K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 108 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 54 macros each processing 16 data values

	lea	esi, [esi-2*clm448K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 27			;; 27 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm448K
	jnc	c7b
	lea	esi, [esi-2*clm448K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-28*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+2*blkdst]
	add	cl, 256/clm448K
	jnc	c4b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 104 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 52 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+2*blkdst]
	add	cl, 256/clm448K
	jnc	c5b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*4*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 16 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+4*blkdst]
	add	cl, 256/clm448K
	jnc	c2b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+4*blkdst]
	prefetcht1 [esi-128+clm448K*128+8*blkdst]
	prefetcht1 [esi-128+clm448K*128+12*blkdst]
	add	cl, 256/clm448K
	jnc	c3b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*16*blkdst-8*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 128 seven_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 56 data values

start_timer 19
	mov	al, 8			;; 8 iterations of 2
c1b:	x7cl_seven_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+8*blkdst]
	prefetcht1 [esi-128+clm448K*128+16*blkdst]
	prefetcht1 [esi-128+clm448K*128+24*blkdst]
	prefetcht1 [esi-128+clm448K*128+32*blkdst]
	prefetcht1 [esi-128+clm448K*128+40*blkdst]
	prefetcht1 [esi-128+clm448K*128+48*blkdst]
	add	cl, 256/clm448K
	jnc	c1b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 128 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 56 data values

b0b:
start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+10*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+26*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+42*blkdst]
	prefetcht1 [esi-128+50*blkdst]
	add	cl, 256/clm448K
	jnc	b1b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-447K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 8 data values

start_timer 22
	mov	al, 8			;; 8 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	add	cl, 256/clm448K
	jnc	b2b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 16 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+8*blkdst]
	add	cl, 256/clm448K
	jnc	b3a
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+8*blkdst]
	prefetcht1 [esi-128+clm448K*128+16*blkdst]
	prefetcht1 [esi-128+clm448K*128+24*blkdst]
	add	cl, 256/clm448K
	jnc	b3b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-24*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+4*blkdst]
	add	cl, 256/clm448K
	jnc	b4b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 96 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 48 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+4*blkdst]
	add	cl, 256/clm448K
	jnc	b5b
	lea	esi, [esi-2*clm448K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*8*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm448K
	jnc	b6b

;; Do 104 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 32 data values

	lea	esi, [esi-2*clm448K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm448K*128]
	prefetcht1 [esi-128+clm448K*128+blkdst]
	prefetcht1 [esi-128+clm448K*128+2*blkdst]
	prefetcht1 [esi-128+clm448K*128+3*blkdst]
	add	cl, 256/clm448K
	jnc	b7b
	lea	esi, [esi-2*clm448K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-14*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 224 values

no_fft:	lea	esi, [esi+clm448K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 8			;; 8 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 56*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 56*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3a:	x2cl_four_complex_fft esi, 56*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-8*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 56*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-24*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 56*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 56*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-7*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 56*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*56*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2
d7b:	x4cl_four_complex_fft esi, 56*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 512K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft512K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm512K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 63 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm512K		;; Load loop counter
c0b:

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm512K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 124 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 62 macros each processing 16 data values

	lea	esi, [esi-2*clm512K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 31			;; 31 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm512K
	jnc	c7b
	lea	esi, [esi-2*clm512K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-32*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+2*blkdst]
	add	cl, 256/clm512K
	jnc	c4b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 120 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 60 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+2*blkdst]
	add	cl, 256/clm512K
	jnc	c5b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*4*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft_2 macros
;; Do 16 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+4*blkdst]
	prefetcht1 [esi-128+clm512K*128+8*blkdst]
	prefetcht1 [esi-128+clm512K*128+12*blkdst]
	add	cl, 256/clm512K
	jnc	c2b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+4*blkdst]
	prefetcht1 [esi-128+clm512K*128+8*blkdst]
	prefetcht1 [esi-128+clm512K*128+12*blkdst]
	add	cl, 256/clm512K
	jnc	c3b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*16*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K

;; Do 128 eight_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values

start_timer 19
	mov	al, 16			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+16*blkdst]
	prefetcht1 [esi-128+clm512K*128+32*blkdst]
	prefetcht1 [esi-128+clm512K*128+48*blkdst]
	add	cl, 256/clm512K
	jnc	c1b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 64 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 32			;; 32 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+36*blkdst]
	add	cl, 256/clm512K
	jnc	b1b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

start_timer 22
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+8*blkdst]
	prefetcht1 [esi-128+clm512K*128+16*blkdst]
	prefetcht1 [esi-128+clm512K*128+24*blkdst]
	add	cl, 256/clm512K
	jnc	b2b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+8*blkdst]
	prefetcht1 [esi-128+clm512K*128+16*blkdst]
	prefetcht1 [esi-128+clm512K*128+24*blkdst]
	add	cl, 256/clm512K
	jnc	b3b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-32*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+4*blkdst]
	add	cl, 256/clm512K
	jnc	b4b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 112 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 56 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+4*blkdst]
	add	cl, 256/clm512K
	jnc	b5b
	lea	esi, [esi-2*clm512K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*8*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm512K
	jnc	b6b

;; Do 120 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 32 data values

	lea	esi, [esi-2*clm512K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm512K*128]
	prefetcht1 [esi-128+clm512K*128+blkdst]
	prefetcht1 [esi-128+clm512K*128+2*blkdst]
	prefetcht1 [esi-128+clm512K*128+3*blkdst]
	add	cl, 256/clm512K
	jnc	b7b
	lea	esi, [esi-2*clm512K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-16*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 256 values

no_fft:	lea	esi, [esi+clm512K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 32			;; 32 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 64*64, 32*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 64*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-8*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 64*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-32*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 64*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 64*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-8*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 64*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*64*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2
d7b:	x4cl_four_complex_fft esi, 64*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 640K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft640K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm640K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 79 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm640K		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm640K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 156 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 78 macros each processing 16 data values

	lea	esi, [esi-2*clm640K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 39			;; 39 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm640K
	jnc	c7b
	lea	esi, [esi-2*clm640K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-40*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+2*blkdst]
	prefetcht1 [esi-128+clm640K*128+4*blkdst]
	prefetcht1 [esi-128+clm640K*128+6*blkdst]
	add	cl, 256/clm640K
	jnc	c4b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 144 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 36 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+2*blkdst]
	prefetcht1 [esi-128+clm640K*128+4*blkdst]
	prefetcht1 [esi-128+clm640K*128+6*blkdst]
	add	cl, 256/clm640K
	jnc	c5b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...

;; Do 32 eight_reals_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

start_timer 18
	mov	al, 8			;; 8 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+8*blkdst]
	add	cl, 256/clm640K
	jnc	c2b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+8		;; 2 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+8*blkdst]
	prefetcht1 [esi-128+clm640K*128+16*blkdst]
	prefetcht1 [esi-128+clm640K*128+24*blkdst]
	add	cl, 256/clm640K
	jnc	c3b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*32*blkdst-16*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K

;; Do 256 five_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 40 data values

start_timer 19
	mov	al, 16			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+16*blkdst]
	prefetcht1 [esi-128+clm640K*128+32*blkdst]
	prefetcht1 [esi-128+clm640K*128+48*blkdst]
	prefetcht1 [esi-128+clm640K*128+64*blkdst]
	add	cl, 256/clm640K
	jnc	c1b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K

;; Do 256 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 40 data values

b0b:
start_timer 21
	mov	eax, 16			;; 16 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+50*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	add	cl, 256/clm640K
	jnc	b1b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-639K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 8 data values

start_timer 22
	mov	al, 16			;; 16 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	add	cl, 256/clm640K
	jnc	b2b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+16*blkdst]
	prefetcht1 [esi-128+clm640K*128+32*blkdst]
	prefetcht1 [esi-128+clm640K*128+48*blkdst]
	add	cl, 256/clm640K
	jnc	b3b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-16*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-639K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+4*blkdst]
	prefetcht1 [esi-128+clm640K*128+8*blkdst]
	prefetcht1 [esi-128+clm640K*128+12*blkdst]
	add	cl, 256/clm640K
	jnc	b4b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+4*blkdst]
	prefetcht1 [esi-128+clm640K*128+8*blkdst]
	prefetcht1 [esi-128+clm640K*128+12*blkdst]
	add	cl, 256/clm640K
	jnc	b5b
	lea	esi, [esi-2*clm640K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-619K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm640K
	jnc	b6b

;; Do 152 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 38 macros each processing 32 data values

	lea	esi, [esi-2*clm640K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 19			;; 19 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm640K*128]
	prefetcht1 [esi-128+clm640K*128+blkdst]
	prefetcht1 [esi-128+clm640K*128+2*blkdst]
	prefetcht1 [esi-128+clm640K*128+3*blkdst]
	add	cl, 256/clm640K
	jnc	b7b
	lea	esi, [esi-2*clm640K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-20*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 320 values

no_fft:	lea	esi, [esi+clm640K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 80*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 80*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 80*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-16*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 80*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 80*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-5*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 80*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*80*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 19			;; 19 iterations of 2
d7b:	x4cl_four_complex_fft esi, 80*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 768K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft768K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm768K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 95 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm768K		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm768K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 188 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 94 macros each processing 16 data values

	lea	esi, [esi-2*clm768K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 47			;; 47 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm768K
	jnc	c7b
	lea	esi, [esi-2*clm768K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-48*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+2*blkdst]
	prefetcht1 [esi-128+clm768K*128+4*blkdst]
	prefetcht1 [esi-128+clm768K*128+6*blkdst]
	add	cl, 256/clm768K
	jnc	c4b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 176 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 44 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+2*blkdst]
	prefetcht1 [esi-128+clm768K*128+4*blkdst]
	prefetcht1 [esi-128+clm768K*128+6*blkdst]
	add	cl, 256/clm768K
	jnc	c5b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	30K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 18
	mov	al, 8			;; 8 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+8*blkdst]
	prefetcht1 [esi-128+clm768K*128+16*blkdst]
	prefetcht1 [esi-128+clm768K*128+24*blkdst]
	add	cl, 256/clm768K
	jnc	c2b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+8		;; 2 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+8*blkdst]
	prefetcht1 [esi-128+clm768K*128+16*blkdst]
	prefetcht1 [esi-128+clm768K*128+24*blkdst]
	add	cl, 256/clm768K
	jnc	c3b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*32*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	30K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K

;; Do 256 six_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 24 data values

start_timer 19
	mov	al, 32			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+32*blkdst]
	prefetcht1 [esi-128+clm768K*128+64*blkdst]
	add	cl, 256/clm768K
	jnc	c1b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K

;; Do 256 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 64 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 32			;; 32 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	add	cl, 256/clm768K
	jnc	b1b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-255K is semi-real data, and
;; 256K-767K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

start_timer 22
	mov	al, 16			;; 16 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+16*blkdst]
	add	cl, 256/clm768K
	jnc	b2b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+16*blkdst]
	prefetcht1 [esi-128+clm768K*128+32*blkdst]
	prefetcht1 [esi-128+clm768K*128+48*blkdst]
	add	cl, 256/clm768K
	jnc	b3b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-32*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-767K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+4*blkdst]
	prefetcht1 [esi-128+clm768K*128+8*blkdst]
	prefetcht1 [esi-128+clm768K*128+12*blkdst]
	add	cl, 256/clm768K
	jnc	b4b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 160 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+4*blkdst]
	prefetcht1 [esi-128+clm768K*128+8*blkdst]
	prefetcht1 [esi-128+clm768K*128+12*blkdst]
	add	cl, 256/clm768K
	jnc	b5b
	lea	esi, [esi-2*clm768K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-767K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm768K
	jnc	b6b

;; Do 184 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 46 macros each processing 32 data values

	lea	esi, [esi-2*clm768K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 23			;; 23 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm768K*128]
	prefetcht1 [esi-128+clm768K*128+blkdst]
	prefetcht1 [esi-128+clm768K*128+2*blkdst]
	prefetcht1 [esi-128+clm768K*128+3*blkdst]
	add	cl, 256/clm768K
	jnc	b7b
	lea	esi, [esi-2*clm768K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-24*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 384 values

no_fft:	lea	esi, [esi+clm768K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 32			;; 32 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 96*64, 32*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 96*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 96*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-32*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 96*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 96*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-6*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 96*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*96*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 23			;; 23 iterations of 2
d7b:	x4cl_four_complex_fft esi, 96*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 896K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft896K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm896K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 111 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm896K		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm896K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 220 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 110 macros each processing 16 data values

	lea	esi, [esi-2*clm896K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 55			;; 55 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm896K
	jnc	c7b
	lea	esi, [esi-2*clm896K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-56*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+2*blkdst]
	prefetcht1 [esi-128+clm896K*128+4*blkdst]
	prefetcht1 [esi-128+clm896K*128+6*blkdst]
	add	cl, 256/clm896K
	jnc	c4b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 208 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 52 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+2*blkdst]
	prefetcht1 [esi-128+clm896K*128+4*blkdst]
	prefetcht1 [esi-128+clm896K*128+6*blkdst]
	add	cl, 256/clm896K
	jnc	c5b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...

;; Do 32 eight_reals_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

start_timer 18
	mov	al, 8			;; 8 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+8*blkdst]
	add	cl, 256/clm896K
	jnc	c2b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 192 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 48 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+8		;; 3 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+8*blkdst]
	prefetcht1 [esi-128+clm896K*128+16*blkdst]
	prefetcht1 [esi-128+clm896K*128+24*blkdst]
	add	cl, 256/clm896K
	jnc	c3b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*32*blkdst-16*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K

;; Do 256 seven_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 56 data values

start_timer 19
	mov	al, 16			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+16*blkdst]
	prefetcht1 [esi-128+clm896K*128+32*blkdst]
	prefetcht1 [esi-128+clm896K*128+48*blkdst]
	prefetcht1 [esi-128+clm896K*128+64*blkdst]
	prefetcht1 [esi-128+clm896K*128+80*blkdst]
	prefetcht1 [esi-128+clm896K*128+96*blkdst]
	add	cl, 256/clm896K
	jnc	c1b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K

;; Do 256 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 56 data values

b0b:
start_timer 21
	mov	eax, 16			;; 16 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+18*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+50*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	prefetcht1 [esi-128+82*blkdst]
	prefetcht1 [esi-128+98*blkdst]
	add	cl, 256/clm896K
	jnc	b1b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-895K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 8 data values

start_timer 22
	mov	al, 16			;; 16 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	add	cl, 256/clm896K
	jnc	b2b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+16*blkdst]
	add	cl, 256/clm896K
	jnc	b3a
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+16*blkdst]
	prefetcht1 [esi-128+clm896K*128+32*blkdst]
	prefetcht1 [esi-128+clm896K*128+48*blkdst]
	add	cl, 256/clm896K
	jnc	b3b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-48*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-895K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+4*blkdst]
	prefetcht1 [esi-128+clm896K*128+8*blkdst]
	prefetcht1 [esi-128+clm896K*128+12*blkdst]
	add	cl, 256/clm896K
	jnc	b4b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 192 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 48 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+4*blkdst]
	prefetcht1 [esi-128+clm896K*128+8*blkdst]
	prefetcht1 [esi-128+clm896K*128+12*blkdst]
	add	cl, 256/clm896K
	jnc	b5b
	lea	esi, [esi-2*clm896K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-895K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm896K
	jnc	b6b

;; Do 208 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 54 macros each processing 32 data values

	lea	esi, [esi-2*clm896K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 27			;; 27 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm896K*128]
	prefetcht1 [esi-128+clm896K*128+blkdst]
	prefetcht1 [esi-128+clm896K*128+2*blkdst]
	prefetcht1 [esi-128+clm896K*128+3*blkdst]
	add	cl, 256/clm896K
	jnc	b7b
	lea	esi, [esi-2*clm896K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-28*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 448 values

no_fft:	lea	esi, [esi+clm896K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 16			;; 16 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 112*64, 16*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 112*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3a:	x2cl_four_complex_fft esi, 112*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 112*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-48*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 112*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 112*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-7*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 112*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*112*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 27			;; 27 iterations of 2
d7b:	x4cl_four_complex_fft esi, 112*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 1M-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft1024K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm1024K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 127 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm1024K		;; Load loop counter
c0b:

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm1024K		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 252 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 16 data values

	lea	esi, [esi-2*clm1024K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 63			;; 63 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	add	cl, 256/clm1024K
	jnc	c7b
	lea	esi, [esi-2*clm1024K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-64*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+2*blkdst]
	prefetcht1 [esi-128+clm1024K*128+4*blkdst]
	prefetcht1 [esi-128+clm1024K*128+6*blkdst]
	add	cl, 256/clm1024K
	jnc	c4b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 240 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 60 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+2*blkdst]
	prefetcht1 [esi-128+clm1024K*128+4*blkdst]
	prefetcht1 [esi-128+clm1024K*128+6*blkdst]
	add	cl, 256/clm1024K
	jnc	c5b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 18
	mov	al, 8			;; 8 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+8*blkdst]
	prefetcht1 [esi-128+clm1024K*128+16*blkdst]
	prefetcht1 [esi-128+clm1024K*128+24*blkdst]
	add	cl, 256/clm1024K
	jnc	c2b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 192 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 48 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+8		;; 3 iterations of 8 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+8*blkdst]
	prefetcht1 [esi-128+clm1024K*128+16*blkdst]
	prefetcht1 [esi-128+clm1024K*128+24*blkdst]
	add	cl, 256/clm1024K
	jnc	c3b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*32*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K

;; Do 256 eight_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values

start_timer 19
	mov	al, 32			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+32*blkdst]
	prefetcht1 [esi-128+clm1024K*128+64*blkdst]
	prefetcht1 [esi-128+clm1024K*128+96*blkdst]
	add	cl, 256/clm1024K
	jnc	c1b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 256 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 128 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 64			;; 64 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+68*blkdst]
	add	cl, 256/clm1024K
	jnc	b1b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

start_timer 22
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+16*blkdst]
	prefetcht1 [esi-128+clm1024K*128+32*blkdst]
	prefetcht1 [esi-128+clm1024K*128+48*blkdst]
	add	cl, 256/clm1024K
	jnc	b2b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+16*blkdst]
	prefetcht1 [esi-128+clm1024K*128+32*blkdst]
	prefetcht1 [esi-128+clm1024K*128+48*blkdst]
	add	cl, 256/clm1024K
	jnc	b3b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst-64*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+4*blkdst]
	prefetcht1 [esi-128+clm1024K*128+8*blkdst]
	prefetcht1 [esi-128+clm1024K*128+12*blkdst]
	add	cl, 256/clm1024K
	jnc	b4b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 224 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 56 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+4*blkdst]
	prefetcht1 [esi-128+clm1024K*128+8*blkdst]
	prefetcht1 [esi-128+clm1024K*128+12*blkdst]
	add	cl, 256/clm1024K
	jnc	b5b
	lea	esi, [esi-2*clm1024K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	add	cl, 256/clm1024K
	jnc	b6b

;; Do 248 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 62 macros each processing 32 data values

	lea	esi, [esi-2*clm1024K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 31			;; 31 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1024K*128]
	prefetcht1 [esi-128+clm1024K*128+blkdst]
	prefetcht1 [esi-128+clm1024K*128+2*blkdst]
	prefetcht1 [esi-128+clm1024K*128+3*blkdst]
	add	cl, 256/clm1024K
	jnc	b7b
	lea	esi, [esi-2*clm1024K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-32*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 512 values

no_fft:	lea	esi, [esi+clm1024K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 64			;; 64 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 128*64, 64*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 128*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations of 2
d3b:	x4cl_four_complex_fft esi, 128*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-64*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 128*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
d5b:	x4cl_four_complex_fft esi, 128*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-8*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 128*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary

	lea	esi, [esi-2*128*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 31			;; 31 iterations of 2
d7b:	x4cl_four_complex_fft esi, 128*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d7b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 1280K-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft1280K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm1280K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 159 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm1280K		;; Load loop counter
c0b:

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm1280K		;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 316 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 158 macros each processing 16 data values

	lea	esi, [esi-2*clm1280K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 79			;; 79 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-80*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+2*blkdst]
	prefetcht1 [esi-128+clm1280K*128+4*blkdst]
	prefetcht1 [esi-128+clm1280K*128+6*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 304 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 76 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 19*256+2		;; 19 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+2*blkdst]
	prefetcht1 [esi-128+clm1280K*128+4*blkdst]
	prefetcht1 [esi-128+clm1280K*128+6*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-20*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+8*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 304 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 152 macros each processing 16 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 9*256+8		;; 9 iterations of 8 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+8*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*16*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	768K
;;	...

;; Do 64 eight_reals_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 16 data values

start_timer 18
	mov	al, 16			;; 16 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+16*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 256 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 2*256+16		;; 2 iterations of 16 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+16*blkdst]
	prefetcht1 [esi-128+clm1280K*128+32*blkdst]
	prefetcht1 [esi-128+clm1280K*128+48*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*64*blkdst-32*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	768K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	512K	768K	1024K
;;	258K
;;	...
;;	510K

;; Do 512 five_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 40 data values

start_timer 19
	mov	al, 32			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+32*blkdst]
	prefetcht1 [esi-128+clm1280K*128+64*blkdst]
	prefetcht1 [esi-128+clm1280K*128+96*blkdst]
	prefetcht1 [esi-128+clm1280K*128+128*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	512K	768K	1024K
;;	258K
;;	...
;;	510K

;; Do 512 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 40 data values

b0b:
start_timer 21
	mov	eax, 32			;; 32 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+36*blkdst]
	prefetcht1 [esi-128+68*blkdst]
	prefetcht1 [esi-128+100*blkdst]
	prefetcht1 [esi-128+132*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-1279K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	512K	768K	1024K
;;	258K
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 8 data values

start_timer 22
	mov	al, 32			;; 32 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+32*blkdst]
	prefetcht1 [esi-128+clm1280K*128+64*blkdst]
	prefetcht1 [esi-128+clm1280K*128+96*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst-32*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-1279K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+16*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 256 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 128 macros each processing 16 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+16		;; 4 iterations of 16 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+16*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*32*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+4*blkdst]
	prefetcht1 [esi-128+clm1280K*128+8*blkdst]
	prefetcht1 [esi-128+clm1280K*128+12*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 288 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 72 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 9*256+4		;; 9 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+4*blkdst]
	prefetcht1 [esi-128+clm1280K*128+8*blkdst]
	prefetcht1 [esi-128+clm1280K*128+12*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-10*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b8b
	ENDIF

;; Do 312 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 78 macros each processing 32 data values

	lea	esi, [esi-2*clm1280K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 39			;; 39 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1280K*128]
	prefetcht1 [esi-128+clm1280K*128+blkdst]
	prefetcht1 [esi-128+clm1280K*128+2*blkdst]
	prefetcht1 [esi-128+clm1280K*128+3*blkdst]
	IF clm1280K NE 1
	add	cl, 256/clm1280K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm1280K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-40*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 640 values

no_fft:	lea	esi, [esi+clm1280K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 32			;; 32 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 160*64, 32*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 32			;; 32 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 160*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
d3b:	x4cl_four_complex_fft esi, 160*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-32*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 160*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+16		;; 4 iterations of 16 iters of 2
d5b:	x2cl_two_complex_fft esi, 160*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-5*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 160*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 9*256+4		;; 9 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 160*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-10*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 160*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*160*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 39			;; 39 iterations of 2
d9b:	x4cl_four_complex_fft esi, 160*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 2M-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft1536K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm1536K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 191 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm1536K		;; Load loop counter
c0b:

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm1536K		;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 380 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 190 macros each processing 16 data values

	lea	esi, [esi-2*clm1536K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 95			;; 95 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-96*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+2*blkdst]
	prefetcht1 [esi-128+clm1536K*128+4*blkdst]
	prefetcht1 [esi-128+clm1536K*128+6*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 368 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 92 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 23*256+2		;; 23 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+2*blkdst]
	prefetcht1 [esi-128+clm1536K*128+4*blkdst]
	prefetcht1 [esi-128+clm1536K*128+6*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-24*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+8*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 352 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 176 macros each processing 16 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 11*256+8		;; 11 iterations of 8 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+8*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*16*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...

;; Do 64 eight_reals_unfft_2 macros
;; Do 64 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values

start_timer 18
	mov	al, 16			;; 16 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+16*blkdst]
	prefetcht1 [esi-128+clm1536K*128+32*blkdst]
	prefetcht1 [esi-128+clm1536K*128+48*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 256 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 2*256+16		;; 2 iterations of 16 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+16*blkdst]
	prefetcht1 [esi-128+clm1536K*128+32*blkdst]
	prefetcht1 [esi-128+clm1536K*128+48*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*64*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K

;; Do 512 six_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 128 macros each processing 24 data values

start_timer 19
	mov	al, 64			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+64*blkdst]
	prefetcht1 [esi-128+clm1536K*128+128*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K

;; Do 512 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 128 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 64			;; 64 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+68*blkdst]
	prefetcht1 [esi-128+132*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-511K is semi-real data, 512K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 16 data values

start_timer 22
	mov	al, 32			;; 32 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+32*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+64*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+32*blkdst]
	prefetcht1 [esi-128+clm1536K*128+64*blkdst]
	prefetcht1 [esi-128+clm1536K*128+96*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst-64*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+16*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 320 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 160 macros each processing 16 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+16		;; 5 iterations of 16 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+16*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*32*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+4*blkdst]
	prefetcht1 [esi-128+clm1536K*128+8*blkdst]
	prefetcht1 [esi-128+clm1536K*128+12*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 352 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 88 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 11*256+4		;; 11 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+4*blkdst]
	prefetcht1 [esi-128+clm1536K*128+8*blkdst]
	prefetcht1 [esi-128+clm1536K*128+12*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-12*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b8b
	ENDIF

;; Do 504 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 32 data values

	lea	esi, [esi-2*clm1536K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 47			;; 47 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1536K*128]
	prefetcht1 [esi-128+clm1536K*128+blkdst]
	prefetcht1 [esi-128+clm1536K*128+2*blkdst]
	prefetcht1 [esi-128+clm1536K*128+3*blkdst]
	IF clm1536K NE 1
	add	cl, 256/clm1536K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm1536K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-48*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 768 values

no_fft:	lea	esi, [esi+clm1536K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 64			;; 64 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 192*64, 64*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 32			;; 32 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 192*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-32*64+64*64]	;; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
d3b:	x4cl_four_complex_fft esi, 192*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-64*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 192*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+16		;; 5 iterations of 16 iters of 2
d5b:	x2cl_two_complex_fft esi, 192*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-6*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 192*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 11*256+4		;; 11 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 192*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-12*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 192*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*192*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 47			;; 47 iterations of 2
d9b:	x4cl_four_complex_fft esi, 192*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 1792K-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft1792K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm1792K		;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 223 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm1792K		;; Load loop counter
c0b:

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm1792K		;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 444 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 222 macros each processing 16 data values

	lea	esi, [esi-2*clm1792K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 111		;; 111 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-112*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+2*blkdst]
	prefetcht1 [esi-128+clm1792K*128+4*blkdst]
	prefetcht1 [esi-128+clm1792K*128+6*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 432 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 108 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 27*256+2		;; 27 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+2*blkdst]
	prefetcht1 [esi-128+clm1792K*128+4*blkdst]
	prefetcht1 [esi-128+clm1792K*128+6*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-28*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+8*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 416 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 208 macros each processing 16 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 13*256+8		;; 13 iterations of 8 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+8*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*16*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	...

;; Do 64 eight_reals_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 16 data values

start_timer 18
	mov	al, 16			;; 16 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+16*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 384 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 96 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 3*256+16		;; 3 iterations of 16 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+16*blkdst]
	prefetcht1 [esi-128+clm1792K*128+32*blkdst]
	prefetcht1 [esi-128+clm1792K*128+48*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*64*blkdst-32*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;	768K	1024K	1280K	1536K
;;	770K
;;	...
;;	1022K

;; Do 512 seven_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 56 data values

start_timer 19
	mov	al, 32			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+32*blkdst]
	prefetcht1 [esi-128+clm1792K*128+64*blkdst]
	prefetcht1 [esi-128+clm1792K*128+96*blkdst]
	prefetcht1 [esi-128+clm1792K*128+128*blkdst]
	prefetcht1 [esi-128+clm1792K*128+160*blkdst]
	prefetcht1 [esi-128+clm1792K*128+192*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;	768K	1024K	1280K	1536K
;;	770K
;;	...
;;	1022K

;; Do 512 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 56 data values

b0b:
start_timer 21
	mov	eax, 32			;; 32 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+2*blkdst]
	prefetcht1 [esi-128+34*blkdst]
	prefetcht1 [esi-128+66*blkdst]
	prefetcht1 [esi-128+98*blkdst]
	prefetcht1 [esi-128+130*blkdst]
	prefetcht1 [esi-128+162*blkdst]
	prefetcht1 [esi-128+194*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-511K is semi-real data, 512K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;	768K	1024K	1280K	1536K
;;	770K
;;	...
;;	1022K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 8 data values

start_timer 22
	mov	al, 32			;; 32 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+32*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b3a
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 32			;; 32 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+32*blkdst]
	prefetcht1 [esi-128+clm1792K*128+64*blkdst]
	prefetcht1 [esi-128+clm1792K*128+96*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst-96*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+16*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 384 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 192 macros each processing 16 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+16		;; 9 iterations of 16 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+16*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*32*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+4*blkdst]
	prefetcht1 [esi-128+clm1792K*128+8*blkdst]
	prefetcht1 [esi-128+clm1792K*128+12*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 416 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 104 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 13*256+4		;; 13 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+4*blkdst]
	prefetcht1 [esi-128+clm1792K*128+8*blkdst]
	prefetcht1 [esi-128+clm1792K*128+12*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-14*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b8b
	ENDIF

;; Do 440 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 110 macros each processing 32 data values

	lea	esi, [esi-2*clm1792K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 55			;; 55 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm1792K*128]
	prefetcht1 [esi-128+clm1792K*128+blkdst]
	prefetcht1 [esi-128+clm1792K*128+2*blkdst]
	prefetcht1 [esi-128+clm1792K*128+3*blkdst]
	IF clm1792K NE 1
	add	cl, 256/clm1792K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm1792K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-56*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 896 values

no_fft:	lea	esi, [esi+clm1792K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	al, 32			;; 32 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 224*64, 32*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 32			;; 32 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 224*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
d3a:	x2cl_four_complex_fft esi, 224*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-32*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 32			;; 32 iterations of 2
d3b:	x4cl_four_complex_fft esi, 224*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-96*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 224*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+16		;; 6 iterations of 16 iters of 2
d5b:	x2cl_two_complex_fft esi, 224*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-7*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 224*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 13*256+4		;; 13 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 224*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-14*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 224*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*224*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 55			;; 55 iterations of 2
d9b:	x4cl_four_complex_fft esi, 224*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 2M-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft2048K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm2048K	;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 255 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm2048K	;; Load loop counter
c0b:

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm2048K	;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 508 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 254 macros each processing 16 data values

	lea	esi, [esi-2*clm2048K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 127		;; 127 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-128*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+2*blkdst]
	prefetcht1 [esi-128+clm2048K*128+4*blkdst]
	prefetcht1 [esi-128+clm2048K*128+6*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 492 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 124 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 31*256+2		;; 31 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+2*blkdst]
	prefetcht1 [esi-128+clm2048K*128+4*blkdst]
	prefetcht1 [esi-128+clm2048K*128+6*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-32*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+8*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 480 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 240 macros each processing 16 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 15*256+8		;; 15 iterations of 8 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+8*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*16*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...

;; Do 64 eight_reals_unfft_2 macros
;; Do 64 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values

start_timer 18
	mov	al, 16			;; 16 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+16*blkdst]
	prefetcht1 [esi-128+clm2048K*128+32*blkdst]
	prefetcht1 [esi-128+clm2048K*128+48*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 384 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 96 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 3*256+16		;; 3 iterations of 16 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+16*blkdst]
	prefetcht1 [esi-128+clm2048K*128+32*blkdst]
	prefetcht1 [esi-128+clm2048K*128+48*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*64*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K

;; Do 512 eight_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 128 macros each processing 32 data values

start_timer 19
	mov	al, 64			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 64*blkdst, 128*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+64*blkdst]
	prefetcht1 [esi-128+clm2048K*128+128*blkdst]
	prefetcht1 [esi-128+clm2048K*128+256*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K	...
;;	1024K	...
;;	...

;; Do 512 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 256 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 128*256		;; 128 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 128*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+132*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-128*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-511K is semi-real data, 512K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K	...
;;	1024K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 nop_two_two_complex_fft_2 macros
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

start_timer 22
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+32*blkdst]
	prefetcht1 [esi-128+clm2048K*128+64*blkdst]
	prefetcht1 [esi-128+clm2048K*128+96*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 32			;; 32 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+32*blkdst]
	prefetcht1 [esi-128+clm2048K*128+64*blkdst]
	prefetcht1 [esi-128+clm2048K*128+96*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst-128*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+16*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 448 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 224 macros each processing 16 data values

	lea	esi, [esi-16*blkdst+32*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+16		;; 7 iterations of 16 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+16*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*32*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+4*blkdst]
	prefetcht1 [esi-128+clm2048K*128+8*blkdst]
	prefetcht1 [esi-128+clm2048K*128+12*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 480 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 120 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 15*256+4		;; 15 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+4*blkdst]
	prefetcht1 [esi-128+clm2048K*128+8*blkdst]
	prefetcht1 [esi-128+clm2048K*128+12*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-16*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm2048K	;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 504 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 32 data values

	lea	esi, [esi-2*clm2048K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 63			;; 63 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2048K*128]
	prefetcht1 [esi-128+clm2048K*128+blkdst]
	prefetcht1 [esi-128+clm2048K*128+2*blkdst]
	prefetcht1 [esi-128+clm2048K*128+3*blkdst]
	IF clm2048K NE 1
	add	cl, 256/clm2048K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm2048K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-64*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 1024 values

no_fft:	lea	esi, [esi+clm2048K*128]		;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 128*256		;; 128 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 256*64, 128*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-128*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 256*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-32*64+128*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 32			;; 32 iterations of 2
d3b:	x4cl_four_complex_fft esi, 256*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-128*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 256*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+16		;; 7 iterations of 16 iters of 2
d5b:	x2cl_two_complex_fft esi, 256*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-8*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 256*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 15*256+4		;; 15 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 256*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-16*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 256*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*256*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 63			;; 63 iterations of 2
d9b:	x4cl_four_complex_fft esi, 256*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 2560K-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft2560K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm2560K	;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 319 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm2560K	;; Load loop counter
c0b:

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm2560K	;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 636 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 318 macros each processing 16 data values

	lea	esi, [esi-2*clm2560K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 159*256		;; 159 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-160*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+2*blkdst]
	prefetcht1 [esi-128+clm2560K*128+4*blkdst]
	prefetcht1 [esi-128+clm2560K*128+6*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 624 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 156 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 39*256+2		;; 39 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+2*blkdst]
	prefetcht1 [esi-128+clm2560K*128+4*blkdst]
	prefetcht1 [esi-128+clm2560K*128+6*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-40*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+8*blkdst]
	prefetcht1 [esi-128+clm2560K*128+16*blkdst]
	prefetcht1 [esi-128+clm2560K*128+24*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 656 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 144 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 9*256+8		;; 9 iterations of 8 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+8*blkdst]
	prefetcht1 [esi-128+clm2560K*128+16*blkdst]
	prefetcht1 [esi-128+clm2560K*128+24*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-10*32*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...

;; Do 128 eight_reals_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 16 data values

start_timer 18
	mov	al, 32			;; 32 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+32*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 512 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+64*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 2*256+32		;; 2 iterations of 32 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+32*blkdst]
	prefetcht1 [esi-128+clm2560K*128+64*blkdst]
	prefetcht1 [esi-128+clm2560K*128+96*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 32			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*128*blkdst-64*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	1024K	1536K	2048K
;;	514K
;;	...
;;	1022K

;; Do 1024 five_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 128 macros each processing 40 data values

start_timer 19
	mov	eax, 64			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+64*blkdst]
	prefetcht1 [esi-128+clm2560K*128+128*blkdst]
	prefetcht1 [esi-128+clm2560K*128+192*blkdst]
	prefetcht1 [esi-128+clm2560K*128+256*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	1024K	1536K	2048K
;;	514K
;;	...
;;	1022K

;; Do 1024 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 128 iterations each processing 40 data values

b0b:
start_timer 21
	mov	eax, 64			;; 64 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+68*blkdst]
	prefetcht1 [esi-128+132*blkdst]
	prefetcht1 [esi-128+196*blkdst]
	prefetcht1 [esi-128+260*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-2559K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	1024K	1536K	2048K
;;	514K
;;	...
;;	1022K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 8 data values

start_timer 22
	mov	al, 64			;; 64 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 64*blkdst, 128*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+64*blkdst]
	prefetcht1 [esi-128+clm2560K*128+128*blkdst]
	prefetcht1 [esi-128+clm2560K*128+192*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst-64*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-2559K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+16*blkdst]
	prefetcht1 [esi-128+clm2560K*128+32*blkdst]
	prefetcht1 [esi-128+clm2560K*128+48*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 128 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+16		;; 4 iterations of 16 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+16*blkdst]
	prefetcht1 [esi-128+clm2560K*128+32*blkdst]
	prefetcht1 [esi-128+clm2560K*128+48*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-5*64*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-2559K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+4*blkdst]
	prefetcht1 [esi-128+clm2560K*128+8*blkdst]
	prefetcht1 [esi-128+clm2560K*128+12*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 608 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 152 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 19*256+4		;; 19 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+4*blkdst]
	prefetcht1 [esi-128+clm2560K*128+8*blkdst]
	prefetcht1 [esi-128+clm2560K*128+12*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-20*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-2559K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm2560K	;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 632 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 158 macros each processing 32 data values

	lea	esi, [esi-2*clm2560K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 79			;; 79 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm2560K*128]
	prefetcht1 [esi-128+clm2560K*128+blkdst]
	prefetcht1 [esi-128+clm2560K*128+2*blkdst]
	prefetcht1 [esi-128+clm2560K*128+3*blkdst]
	IF clm2560K NE 1
	add	cl, 256/clm2560K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm2560K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-80*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 1280 values

no_fft:	lea	esi, [esi+clm2560K*128]	;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 64			;; 64 iterations of 2
d1b:	x5cl_five_reals_first_fft esi, 320*64, 64*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 64			;; 64 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 320*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
d3b:	x4cl_four_complex_fft esi, 320*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-64*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 320*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+16		;; 4 iterations of 16 iters of 2
d5b:	x4cl_four_complex_fft esi, 320*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-5*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 320*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 19*256+4		;; 19 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 320*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-20*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 320*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*320*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 79			;; 79 iterations of 2
d9b:	x4cl_four_complex_fft esi, 320*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 3M-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft3072K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm3072K	;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 383 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm3072K	;; Load loop counter
c0b:

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm3072K	;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 764 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 382 macros each processing 16 data values

	lea	esi, [esi-2*clm3072K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 191*256		;; 191 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-192*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+2*blkdst]
	prefetcht1 [esi-128+clm3072K*128+4*blkdst]
	prefetcht1 [esi-128+clm3072K*128+6*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 752 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 188 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 47*256+2		;; 47 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+2*blkdst]
	prefetcht1 [esi-128+clm3072K*128+4*blkdst]
	prefetcht1 [esi-128+clm3072K*128+6*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-48*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+8*blkdst]
	prefetcht1 [esi-128+clm3072K*128+16*blkdst]
	prefetcht1 [esi-128+clm3072K*128+24*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 704 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 176 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 11*256+8		;; 11 iterations of 8 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+8*blkdst]
	prefetcht1 [esi-128+clm3072K*128+16*blkdst]
	prefetcht1 [esi-128+clm3072K*128+24*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-12*32*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...

;; Do 128 eight_reals_unfft_2 macros
;; Do 128 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values

start_timer 18
	mov	al, 32			;; 32 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+32*blkdst]
	prefetcht1 [esi-128+clm3072K*128+64*blkdst]
	prefetcht1 [esi-128+clm3072K*128+96*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 512 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 2*256+32		;; 2 iterations of 32 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+32*blkdst]
	prefetcht1 [esi-128+clm3072K*128+64*blkdst]
	prefetcht1 [esi-128+clm3072K*128+96*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 32			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*128*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	1536K	2048K	2560K
;;	1026K
;;	...
;;	1534K

;; Do 1024 six_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 256 macros each processing 24 data values

start_timer 19
	mov	eax, 128*256		;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 128*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+128*blkdst]
	prefetcht1 [esi-128+clm3072K*128+256*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-128*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	1536K	2048K	2560K
;;	1026K
;;	...
;;	1534K

;; Do 1024 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 128 iterations each processing 24 data values

b0b:
start_timer 21
	mov	eax, 128*256		;; 128 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 128*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+132*blkdst]
	prefetcht1 [esi-128+260*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-128*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-1023K is semi-real data, 1024K-3071K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	1536K	2048K	2560K
;;	1026K
;;	...
;;	1534K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;; Do 128 nop_two_two_complex_fft_2 macros
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 16 data values

start_timer 22
	mov	al, 64			;; 64 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+64*blkdst]
	prefetcht1 [esi-128+clm3072K*128+128*blkdst]
	prefetcht1 [esi-128+clm3072K*128+192*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	esi, [esi-64*blkdst+128*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 64*blkdst, 128*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+64*blkdst]
	prefetcht1 [esi-128+clm3072K*128+128*blkdst]
	prefetcht1 [esi-128+clm3072K*128+192*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst-128*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+16*blkdst]
	prefetcht1 [esi-128+clm3072K*128+32*blkdst]
	prefetcht1 [esi-128+clm3072K*128+48*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 640 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 160 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+16		;; 5 iterations of 16 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+16*blkdst]
	prefetcht1 [esi-128+clm3072K*128+32*blkdst]
	prefetcht1 [esi-128+clm3072K*128+48*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-6*64*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-3071K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+4*blkdst]
	prefetcht1 [esi-128+clm3072K*128+8*blkdst]
	prefetcht1 [esi-128+clm3072K*128+12*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 736 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 184 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 23*256+4		;; 23 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+4*blkdst]
	prefetcht1 [esi-128+clm3072K*128+8*blkdst]
	prefetcht1 [esi-128+clm3072K*128+12*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-24*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-3071K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm3072K	;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 760 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 190 macros each processing 32 data values

	lea	esi, [esi-2*clm3072K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 95			;; 95 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3072K*128]
	prefetcht1 [esi-128+clm3072K*128+blkdst]
	prefetcht1 [esi-128+clm3072K*128+2*blkdst]
	prefetcht1 [esi-128+clm3072K*128+3*blkdst]
	IF clm3072K NE 1
	add	cl, 256/clm3072K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm3072K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-96*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 1536 values

no_fft:	lea	esi, [esi+clm3072K*128]	;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 128*256		;; 128 iterations of 2
d1b:	x3cl_six_reals_first_fft esi, 384*64, 128*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-128*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 64			;; 64 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 384*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-64*64+128*64]	;; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
d3b:	x4cl_four_complex_fft esi, 384*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-128*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 384*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+16		;; 5 iterations of 16 iters of 2
d5b:	x4cl_four_complex_fft esi, 384*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-6*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 384*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 23*256+4		;; 23 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 384*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-24*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 384*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*384*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 95			;; 95 iterations of 2
d9b:	x4cl_four_complex_fft esi, 384*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 3584K-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft3584K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm3584K	;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 447 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm3584K	;; Load loop counter
c0b:

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm3584K	;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 892 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 446 macros each processing 16 data values

	lea	esi, [esi-2*clm3584K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 223*256		;; 223 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-224*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+2*blkdst]
	prefetcht1 [esi-128+clm3584K*128+4*blkdst]
	prefetcht1 [esi-128+clm3584K*128+6*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 880 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 220 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 55*256+2		;; 55 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+2*blkdst]
	prefetcht1 [esi-128+clm3584K*128+4*blkdst]
	prefetcht1 [esi-128+clm3584K*128+6*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-56*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+8*blkdst]
	prefetcht1 [esi-128+clm3584K*128+16*blkdst]
	prefetcht1 [esi-128+clm3584K*128+24*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 832 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 208 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 13*256+8		;; 13 iterations of 8 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+8*blkdst]
	prefetcht1 [esi-128+clm3584K*128+16*blkdst]
	prefetcht1 [esi-128+clm3584K*128+24*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-14*32*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...

;; Do 128 eight_reals_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values

start_timer 18
	mov	al, 32			;; 32 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+32*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 768 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 192 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+64*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 3*256+32		;; 3 iterations of 32 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+32*blkdst]
	prefetcht1 [esi-128+clm3584K*128+64*blkdst]
	prefetcht1 [esi-128+clm3584K*128+96*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 32			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-3*128*blkdst-64*blkdst];; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;	1536K	2048K	2560K	3072K
;;	1538K
;;	...
;;	2046K

;; Do 1024 seven_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 128 macros each processing 56 data values

start_timer 19
	mov	al, 64			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+64*blkdst]
	prefetcht1 [esi-128+clm3584K*128+128*blkdst]
	prefetcht1 [esi-128+clm3584K*128+192*blkdst]
	prefetcht1 [esi-128+clm3584K*128+256*blkdst]
	prefetcht1 [esi-128+clm3584K*128+320*blkdst]
	prefetcht1 [esi-128+clm3584K*128+384*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;	1536K	2048K	2560K	3072K
;;	1538K
;;	...
;;	2046K

;; Do 1024 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 128 iterations each processing 56 data values

b0b:
start_timer 21
	mov	eax, 64			;; 64 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+3*blkdst]
	prefetcht1 [esi-128+67*blkdst]
	prefetcht1 [esi-128+131*blkdst]
	prefetcht1 [esi-128+195*blkdst]
	prefetcht1 [esi-128+259*blkdst]
	prefetcht1 [esi-128+323*blkdst]
	prefetcht1 [esi-128+387*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-1023K is semi-real data, 1024K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;	1536K	2048K	2560K	3072K
;;	1538K
;;	...
;;	2046K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 8 data values

start_timer 22
	mov	al, 64			;; 64 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 16 data values

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 64*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3a			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+64*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b3a
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3a			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	esi, [esi-64*blkdst+128*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 64			;; 64 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 64*blkdst, 128*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+64*blkdst]
	prefetcht1 [esi-128+clm3584K*128+128*blkdst]
	prefetcht1 [esi-128+clm3584K*128+192*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst-192*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+16*blkdst]
	prefetcht1 [esi-128+clm3584K*128+32*blkdst]
	prefetcht1 [esi-128+clm3584K*128+48*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 768 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 192 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+16		;; 6 iterations of 16 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+16*blkdst]
	prefetcht1 [esi-128+clm3584K*128+32*blkdst]
	prefetcht1 [esi-128+clm3584K*128+48*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-7*64*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+4*blkdst]
	prefetcht1 [esi-128+clm3584K*128+8*blkdst]
	prefetcht1 [esi-128+clm3584K*128+12*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 864 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 216 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 27*256+4		;; 27 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+4*blkdst]
	prefetcht1 [esi-128+clm3584K*128+8*blkdst]
	prefetcht1 [esi-128+clm3584K*128+12*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-28*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm3584K	;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 888 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 222 macros each processing 32 data values

	lea	esi, [esi-2*clm3584K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 111			;; 111 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm3584K*128]
	prefetcht1 [esi-128+clm3584K*128+blkdst]
	prefetcht1 [esi-128+clm3584K*128+2*blkdst]
	prefetcht1 [esi-128+clm3584K*128+3*blkdst]
	IF clm3584K NE 1
	add	cl, 256/clm3584K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm3584K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-112*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 1792 values

no_fft:	lea	esi, [esi+clm3584K*128]	;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 64			;; 64 iterations of 2
d1b:	x7cl_seven_reals_first_fft esi, 448*64, 64*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 64			;; 64 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 448*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
d3a:	x2cl_four_complex_fft esi, 448*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3a			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3a			;; Iterate if necessary

	lea	esi, [esi-64*64+128*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 64			;; 64 iterations of 2
d3b:	x4cl_four_complex_fft esi, 448*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-192*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 448*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+16		;; 6 iterations of 16 iters of 2
d5b:	x4cl_four_complex_fft esi, 448*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-7*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 448*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 27*256+4		;; 27 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 448*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-28*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 448*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*448*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 111			;; 111 iterations of 2
d9b:	x4cl_four_complex_fft esi, 448*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM


;; Perform a 4M-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft4096K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, fftdn

;; Call FFT code unless the FFT has already been started

clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0	;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm4096K	;; Load loop counter
	sub	ecx, ecx
	JMP_X	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 511 pass2_11_levels_complex

pass2:
start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	JE_X	gw_finish_fft_3
end_timer 0

;; Do the inverse FFT

start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	sub	ecx, ecx

	mov	edx, 512/clm4096K	;; Load loop counter
c0b:

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

start_timer 16
c8b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm4096K	;; Test loop counter
	JNC_X	c8b			;; Iterate if necessary

;; Do 1020 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 510 macros each processing 16 data values

	lea	esi, [esi-2*clm4096K*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 255*256		;; 255 iterations of 2
c9b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c9b			;; Iterate if necessary
	prefetcht1 [esi-128+6*blkdst]
	prefetcht1 [esi-128+7*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c9b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c9b			;; Iterate if necessary
	lea	esi, [esi-256*2*blkdst]	;; Restore source pointer
end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c6b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+2*blkdst]
	prefetcht1 [esi-128+clm4096K*128+4*blkdst]
	prefetcht1 [esi-128+clm4096K*128+6*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c6b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c6b			;; Iterate if necessary

;; Do 1008 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 252 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 63*256+2		;; 63 iterations of 2 iters of 2
c7b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+2*blkdst]
	prefetcht1 [esi-128+clm4096K*128+4*blkdst]
	prefetcht1 [esi-128+clm4096K*128+6*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c7b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-64*8*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

start_timer 17
	mov	al, 8			;; 8 iterations of 2
c4b:	x4cl_eight_reals_unfft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+8*blkdst]
	prefetcht1 [esi-128+clm4096K*128+16*blkdst]
	prefetcht1 [esi-128+clm4096K*128+24*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c4b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c4b			;; Iterate if necessary

;; Do 960 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 240 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 15*256+8		;; 15 iterations of 8 iters of 2
c5b:	x4cl_four_complex_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+8*blkdst]
	prefetcht1 [esi-128+clm4096K*128+16*blkdst]
	prefetcht1 [esi-128+clm4096K*128+24*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c5b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 8			;; Load middle loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*32*blkdst]	;; Restore source pointer
end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...

;; Do 128 eight_reals_unfft_2 macros
;; Do 128 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values

start_timer 18
	mov	al, 32			;; 32 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+32*blkdst]
	prefetcht1 [esi-128+clm4096K*128+64*blkdst]
	prefetcht1 [esi-128+clm4096K*128+96*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c2b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c2b			;; Iterate if necessary

;; Do 768 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 192 macros each processing 32 data values

	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	eax, 3*256+32		;; 3 iterations of 32 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 32*blkdst, 64*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+32*blkdst]
	prefetcht1 [esi-128+clm4096K*128+64*blkdst]
	prefetcht1 [esi-128+clm4096K*128+96*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c3b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst+128*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 32			;; Reload middle counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-4*128*blkdst]	;; Restore source pointer
end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	1024K	2048K	3072K
;;	2K	...
;;	...
;;	1022K

;; Do 1024 eight_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 256 macros each processing 32 data values

start_timer 19
	mov	eax, 128*256		;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 128*blkdst, 256*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+128*blkdst]
	prefetcht1 [esi-128+clm4096K*128+256*blkdst]
	prefetcht1 [esi-128+clm4096K*128+384*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	c1b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	c1b			;; Iterate if necessary
	lea	esi, [esi-128*blkdst]	;; Restore source pointer
end_timer 19

;; Normalize these values

start_timer 20
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	sub	ecx, ecx
end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	1024K	2048K	3072K
;;	2K	...
;;	...
;;	1022K
;; On output the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K	...
;;	2048K	...
;;	...

;; Do 1024 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 512 iterations each processing 16 data values

b0b:
start_timer 21
	mov	eax, 256*256		;; 256 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 256*blkdst
	add	al, 256/2		;; Test loop counter
	JNC_X	b1b			;; Iterate if necessary
	prefetcht1 [esi-128+4*blkdst]
	prefetcht1 [esi-128+260*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b1b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-256*blkdst]	;; Restore source pointer
end_timer 21

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-1023K is semi-real data, 1024K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K	...
;;	2048K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;; Do 128 nop_two_two_complex_fft_2 macros
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

start_timer 22
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 64*blkdst, 128*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+64*blkdst]
	prefetcht1 [esi-128+clm4096K*128+128*blkdst]
	prefetcht1 [esi-128+clm4096K*128+192*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b2b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	esi, [esi-64*blkdst+256*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 64			;; 64 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 64*blkdst, 128*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+64*blkdst]
	prefetcht1 [esi-128+clm4096K*128+128*blkdst]
	prefetcht1 [esi-128+clm4096K*128+192*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b3b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-64*blkdst-256*blkdst];; Restore source pointer
end_timer 22

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

start_timer 23
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
b4b:	x4cl_eight_reals_fft_2 esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+16*blkdst]
	prefetcht1 [esi-128+clm4096K*128+32*blkdst]
	prefetcht1 [esi-128+clm4096K*128+48*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b4b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary

;; Do 896 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 224 macros each processing 32 data values

	lea	esi, [esi-16*blkdst+64*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+16		;; 7 iterations of 16 iters of 2
b5b:	x4cl_four_complex_fft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+16*blkdst]
	prefetcht1 [esi-128+clm4096K*128+32*blkdst]
	prefetcht1 [esi-128+clm4096K*128+48*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b5b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst+64*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*64*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b6b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+4*blkdst]
	prefetcht1 [esi-128+clm4096K*128+8*blkdst]
	prefetcht1 [esi-128+clm4096K*128+12*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b6b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b6b			;; Iterate if necessary

;; Do 992 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 248 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 31*256+4		;; 31 iterations of 4 iters of 2
b7b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+4*blkdst]
	prefetcht1 [esi-128+clm4096K*128+8*blkdst]
	prefetcht1 [esi-128+clm4096K*128+12*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b7b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-32*16*blkdst]	;; Restore source pointer
end_timer 23

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm4096K	;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 1016 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 254 macros each processing 32 data values

	lea	esi, [esi-2*clm4096K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 127			;; 127 iterations of 2
b9b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b9b			;; Iterate if necessary
	prefetcht1 [esi-128+clm4096K*128]
	prefetcht1 [esi-128+clm4096K*128+blkdst]
	prefetcht1 [esi-128+clm4096K*128+2*blkdst]
	prefetcht1 [esi-128+clm4096K*128+3*blkdst]
	IF clm4096K NE 1
	add	cl, 256/clm4096K
	jnc	b9b
	ENDIF
	lea	esi, [esi-2*clm4096K*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-128*4*blkdst]	;; Restore source pointer
end_timer 24

;; Work on next 4 sets of 2048 values

no_fft:	lea	esi, [esi+clm4096K*128]	;; Next source pointer
	sub	edx, 1			;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JNE_X	c0b			;; Do inverse-FFT/norm/FFT iteration
	JMP_X	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	JE_X	pass2			;; FFT-only, go do pass 2
end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

start_timer 26
	CALL_X	gw_split_carries_3
end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	JE_X	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	ebx, ebx
	mov	eax, 256*256		;; 256 iterations of 2
d1b:	x2cl_eight_reals_first_fft esi, 512*64, 256*64
	add	al, 256/2		;; Test loop counter
	JNC_X	d1b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	d1b			;; Iterate if necessary
	lea	esi, [esi-256*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 512*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2b			;; Iterate if necessary

	lea	esi, [esi-64*64+256*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 64			;; 64 iterations of 2
d3b:	x4cl_four_complex_fft esi, 512*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d3b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-256*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations of 2
d4b:	x4cl_eight_reals_fft_2 esi, 512*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d4b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+16		;; 7 iterations of 16 iters of 2
d5b:	x4cl_four_complex_fft esi, 512*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d5b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	JNZ_X	d5b			;; Iterate if necessary
	lea	esi, [esi-8*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d6b:	x4cl_eight_reals_fft_2 esi, 512*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d6b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 31*256+4		;; 31 iterations of 4 iters of 2
d7b:	x4cl_four_complex_fft esi, 512*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d7b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	JNZ_X	d7b			;; Iterate if necessary
	lea	esi, [esi-32*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 512*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d8b			;; Iterate if necessary

	lea	esi, [esi-2*512*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 127			;; 127 iterations of 2
d9b:	x4cl_four_complex_fft esi, 512*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	d9b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d9b			;; Iterate if necessary
end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	JMP_X	gw_finish_mult_3
	ENDM
