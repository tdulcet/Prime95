; Copyright 2001-2003 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros perform the large 2 pass FFTs using SSE2 instructions.
;

; ********************************************************
; ********************************************************
; ********************  FFT MACROS  **********************
; ********************************************************
; ********************************************************

;; For small FFTs, use the v22 distance between two pass 2 data blocks.
;; Pass 2 does 11 FFT levels 2 sets of data (2 * 2^11 complex values =
;; 2^13 doubles = 64KB).

set_small_FFT_constants MACRO
	PREFETCHING = 1
	clm = 4
	blkdst = (65536+4096+128)
	ENDM

;; For larger FFTs, we use a scratch area to reduce TLB thrashing.  This
;; changes the optimal distance between two pass 2 data blocks.

set_big_FFT_constants MACRO clmarg
	IF clmarg NE 0
	PREFETCHING = 1
	clm = clmarg
	ELSE
	PREFETCHING = 0
	clm = 1
	ENDIF
	blkdst = (65536+2*clm*128)
	clmblkdst = (clm*128)
	clmblkdst8 = (clmblkdst*8+128)
	ENDM

; Note:  All memory layouts are for 64 byte L1 cache lines.  The high
; order XMM words are not shown (they are 1K higher than the low
; order XMM word.  Since the L2 cache reads 128 byte cache lines, two
; 64 byte cache lines are processed at a time.  The second 64 byte
; cache line contains a completely independent set of data.


;; Perform a 40K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft40K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 4 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c0b:	start_timer 18
c2b:	x1cl_half_eight_reals_unfft_2 esi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2b

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*2*blkdst-blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 8 five_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 40 data values

	start_timer 19
c1b:	x5cl_five_reals_last_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	16K	24K	32K
;;	10K
;;	...
;;	14K

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 40 data values

b0b:	start_timer 21
	sub	eax, eax		;; 1 iteration of 2
b1b:	x5cl_five_reals_first_fft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 16K-39K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

	start_timer 22
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 20 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	eax, eax		;; 1 iteration of 2
d1b:	x5cl_five_reals_fft esi, 5*64, 64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*5*64]	;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x1cl_half_eight_reals_fft_2 esi, 5*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary

	lea	esi, [esi-2*5*64+64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3b:	x4cl_four_complex_fft esi, 5*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 48K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft48K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 5 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 18
c2b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2b

;; Do 8 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 4 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*2*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K

;; Do 16 six_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 24 data values

	start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 4 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 2			;; 2 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+blkdst]
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-47K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	start_timer 22
b2b:	x2cl_eight_reals_fft_2 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-2*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 24 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 2			;; 2 iterations of 2
d1b:	x3cl_six_reals_fft esi, 6*64, 2*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*6*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x2cl_eight_reals_fft_2 esi, 6*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary

	lea	esi, [esi-2*6*64+2*64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3b:	x4cl_four_complex_fft esi, 6*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 56K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft56K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3a, d3b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 6 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...

;; Do 2 eight_reals_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 18
c2b:	x1cl_half_eight_reals_unfft_2 esi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2b

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*2*blkdst-blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 16 seven_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 56 data values

	start_timer 19
c1b:	x7cl_seven_reals_last_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+5*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 2 iterations each processing 56 data values

b0b:	start_timer 21
	sub	eax, eax
b1b:	x7cl_seven_reals_first_fft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-55K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	12K	16K	20K
;;	10K
;;	24K	32K	40K	48K
;;	26K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

	start_timer 22
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b

;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
b3a:	x2cl_four_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	b3a

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-3*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 28 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	sub	eax, eax		;; 1 iterations of 2
d1b:	x7cl_seven_reals_fft esi, 7*64, 64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*7*64]	;; Restore source pointer

;; Do FFT levels 4,5

d2b:	x1cl_half_eight_reals_fft_2 esi, 7*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary

	lea	esi, [esi-2*7*64+64]	;; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
d3a:	x2cl_four_complex_fft esi, 7*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary

	lea	esi, [esi-2*7*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
d3b:	x4cl_four_complex_fft esi, 7*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 64K-element FFT.  This is done in two passes.  Pass 1
;; does 5 levels, pass 2 uses common code to perform the last 11 levels.

xfft64K MACRO
	LOCAL	b0b, b1b, b2b, b3b
	LOCAL	c0b, c1b, c2b, c3b
	LOCAL	d1b, d2b, d3b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 7 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 18
c2b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	c2b

;; Do 12 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 6 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*2*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K

;; Do 16 eight_reals_last_unfft macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8K
;;	do 8 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+6*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-63K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	4K	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 22
	mov	edi, sincos1		;; Load sin/cos pointer
b2b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b2b

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64-4*blkdst];; Restore source pointer
	end_timer 22

;; Work on next 4 sets of 32 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 4			;; 4 iterations of 2
d1b:	x2cl_eight_reals_fft esi, 8*64, 4*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*8*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos1		;; Load sin/cos pointer
d2b:	x4cl_eight_reals_fft_2 esi, 8*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary

	lea	esi, [esi-2*8*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
d3b:	x4cl_four_complex_fft esi, 8*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 80K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft80K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 9 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 36 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-10*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

	start_timer 18
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	c2b

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*4*blkdst-2*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 32 five_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 40 data values

	start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K

;; Do 32 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 40 data values

b0b:	start_timer 21
	mov	eax, 2			;; 2 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+blkdst]
	xprefetcht1 [esi-128+3*blkdst]
	xprefetcht1 [esi-128+5*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	xprefetcht1 [esi-128+9*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	32K	48K	64K
;;	18K
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 8 data values

	start_timer 22
	mov	al, 2			;; 2 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-2*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 32 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-5*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 40 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 2			;; 2 iterations of 2
d1b:	x5cl_five_reals_fft esi, 10*64, 2*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 10*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 10*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-2*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 10*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*10*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d5b:	x2cl_two_complex_fft esi, 10*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*10*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 96K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft96K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 11 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 22 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-12*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	start_timer 18
c2b:	x4cl_eight_reals_unfft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	c2b

;; Do 16 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*4*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 32 six_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 24 data values

	start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K

;; Do 32 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 8 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+blkdst]
	xprefetcht1 [esi-128+5*blkdst]
	xprefetcht1 [esi-128+9*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 16 data values

	start_timer 22
	mov	al, 2			;; 2 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-4*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-95K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 40 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 10 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-6*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 48 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 4			;; 4 iterations of 2
d1b:	x3cl_six_reals_fft esi, 12*64, 4*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 12*64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-2*64+4*64]	;; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 12*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-4*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 12*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*12*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
d5b:	x2cl_two_complex_fft esi, 12*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*12*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 112K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft112K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 13 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 52 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-14*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...

;; Do 4 eight_reals_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 16 data values

	start_timer 18
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	c2b

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 6 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*4*blkdst-2*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 32 seven_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 56 data values

	start_timer 19
	mov	al, 2			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+10*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K

;; Do 32 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 56 data values

b0b:	start_timer 21
	mov	eax, 2			;; 2 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	24K	32K	40K
;;	18K
;;	...
;;	22K
;;	48K	64K	80K	96K
;;	50K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 8 data values

	start_timer 22
	mov	al, 2			;; 2 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-6*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-111K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 48 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-7*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 56 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 2			;; 2 iterations of 2
d1b:	x7cl_seven_reals_fft esi, 14*64, 2*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 2			;; 2 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 14*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d3a:	x2cl_four_complex_fft esi, 14*64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3a			;; Iterate if necessary

	lea	esi, [esi-2*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 14*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-6*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 14*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*14*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
d5b:	x2cl_two_complex_fft esi, 14*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*14*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 128K-element FFT.  This is done in two passes.  Pass 1
;; does 6 levels, pass 2 uses common code to perform the last 11 levels.

xfft128K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 15 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...

;; Do 2 eight_reals_unfft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 8 data values

c0b:	start_timer 16
c4b:	x1cl_eight_reals_unfft_1 esi, 64
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 60 two_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 8 data values

	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2
c5b:	x1cl_two_complex_unfft esi, 64
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+3*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft_2 macros
;; Do 4 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4K
;;	do 2 macros each processing 32 data values

	start_timer 18
c2b:	x4cl_eight_reals_unfft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	c2b

;; Do 24 four_complex_unfft macros
;;	distance between fft data elements is 4K
;;	do 6 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 3			;; 3 iterations of 2
c3b:	x4cl_four_complex_unfft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*4*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K

;; Do 32 eight_reals_last_unfft macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16K
;;	do 16 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+4*blkdst]
	xprefetcht1 [esi-128+12*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 4 eight_reals_fft_2 macros
;; Do 4 nop_two_two_complex_fft_2 macros
;; Do 8 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 22
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-3K is real data, 4K-7K is semi-real data, 8K-127K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_1 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 56 two_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 14 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
b5b:	x2cl_two_complex_fft esi, 64, blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-8*2*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 64 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 8			;; 8 iterations of 2
d1b:	x2cl_eight_reals_fft esi, 16*64, 8*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 16*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-2*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 2			;; 2 iterations of 2
d3b:	x4cl_four_complex_fft esi, 16*64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64-8*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x2cl_eight_reals_fft_1 esi, 16*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*16*64+2*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
d5b:	x2cl_two_complex_fft esi, 16*64, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*16*64+2*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 160K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft160K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 19 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 72 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 9			;; 9 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-10*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*8*blkdst-4*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 64 five_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 40 data values

	start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x5cl_five_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K

;; Do 64 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 40 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+blkdst]
	xprefetcht1 [esi-128+5*blkdst]
	xprefetcht1 [esi-128+9*blkdst]
	xprefetcht1 [esi-128+13*blkdst]
	xprefetcht1 [esi-128+17*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-159K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	64K	96K	128K
;;	34K
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 8 data values

	start_timer 22
	mov	al, 4			;; 4 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-4*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-159K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-5*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 80 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 4			;; 4 iterations of 2
d1b:	x5cl_five_reals_fft esi, 20*64, 4*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 20*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 20*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-4*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 20*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*20*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d5b:	x4cl_four_complex_fft esi, 20*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*20*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 192K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft192K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 23 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 44 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 11			;; 11 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-12*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 32 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 2*256+2		;; 2 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 64 six_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 24 data values

	start_timer 19
	mov	al, 8			;; Load loop counter
c1b:	x3cl_six_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K

;; Do 64 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 16 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+blkdst]
	xprefetcht1 [esi-128+9*blkdst]
	xprefetcht1 [esi-128+17*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	start_timer 22
	mov	al, 4			;; 4 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-191K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 40 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 10 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-6*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 96 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 8			;; 8 iterations of 2
d1b:	x3cl_six_reals_fft esi, 24*64, 8*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 24*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 24*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-8*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 24*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*24*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 5			;; 5 iterations of 2
d5b:	x4cl_four_complex_fft esi, 24*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*24*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 224K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft224K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 27 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 52 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 13			;; 13 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-14*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...

;; Do 8 eight_reals_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*8*blkdst-4*blkdst];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 64 seven_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 56 data values

	start_timer 19
	mov	al, 4			;; Load loop counter
c1b:	x7cl_seven_reals_last_unfft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+20*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K

;; Do 64 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 56 data values

b0b:	start_timer 21
	mov	eax, 4			;; 4 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+10*blkdst]
	xprefetcht1 [esi-128+14*blkdst]
	xprefetcht1 [esi-128+18*blkdst]
	xprefetcht1 [esi-128+22*blkdst]
	xprefetcht1 [esi-128+26*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	48K	64K	80K
;;	34K
;;	...
;;	46K
;;	96K	128K	160K	192K
;;	98K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 8 data values

	start_timer 22
	mov	al, 4			;; 4 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-12*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-223K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 48 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-7*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 112 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 4			;; 4 iterations of 2
d1b:	x7cl_seven_reals_fft esi, 28*64, 4*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-4*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 4			;; 4 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 28*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d3a:	x2cl_four_complex_fft esi, 28*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3a			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 28*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-12*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 28*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*28*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 6			;; 6 iterations of 2
d5b:	x4cl_four_complex_fft esi, 28*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*28*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 256K-element FFT.  This is done in two passes.  Pass 1
;; does 7 levels, pass 2 uses common code to perform the last 11 levels.

xfft256K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b
	LOCAL	d1b, d2b, d3b, d4b, d5b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 31 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c4b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

;; Do 60 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 15			;; 15 iterations of 2
c5b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-16*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 18
	mov	al, 2			;; 2 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 48 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 12 macros each processing 32 data values

	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 3*256+2		;; 3 iterations of 2 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 2*blkdst, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+6*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K

;; Do 64 eight_reals_last_unfft macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	start_timer 19
	mov	al, 8			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32K
;;	do 32 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 16			;; 16 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+4*blkdst]
	xprefetcht1 [esi-128+20*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 22
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst-16*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-255K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b4b

;; Do 56 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 14 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
b5b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-8*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 128 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 16			;; 16 iterations of 2
d1b:	x2cl_eight_reals_fft esi, 32*64, 16*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 32*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 4			;; 4 iterations of 2
d3b:	x4cl_four_complex_fft esi, 32*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-4*64-16*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos1		;; Load sin/cos pointer
d4b:	x4cl_eight_reals_fft_2 esi, 32*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary

	lea	esi, [esi-2*32*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 iterations of 2
d5b:	x4cl_four_complex_fft esi, 32*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*32*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d5b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 320K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft320K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 39 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 76 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 38 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 19			;; 19 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-20*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 72 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 36 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-10*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 16 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-2*16*blkdst-8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 128 five_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 40 data values

	start_timer 19
	mov	al, 8			;; 8 iterations of 2
c1b:	x5cl_five_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	xprefetcht1 [esi-128+clm*128+32*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K

;; Do 128 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 40 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x5cl_five_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+10*blkdst]
	xprefetcht1 [esi-128+18*blkdst]
	xprefetcht1 [esi-128+26*blkdst]
	xprefetcht1 [esi-128+34*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-319K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	128K	192K	256K
;;	66K
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 8 data values

	start_timer 22
	mov	al, 8			;; 8 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-8*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4b			;; Iterate if necessary

;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-5*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-319K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b6b

;; Do 72 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 18 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b			;; Iterate if necessary
	lea	esi, [esi-10*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 160 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 8			;; 8 iterations of 2
d1b:	x5cl_five_reals_fft esi, 40*64, 8*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 40*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 40*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-8*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 40*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 40*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-5*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 40*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*40*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 9			;; 9 iterations of 2
d7b:	x4cl_four_complex_fft esi, 40*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*40*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 384K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft384K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 47 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 92 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 46 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 23			;; 23 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-24*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 88 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 44 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-12*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft_2 macros
;; Do 16 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 64 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 2*256+4		;; 2 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*16*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 128 six_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 24 data values

	start_timer 19
	mov	al, 16			;; 16 iterations of 2
c1b:	x3cl_six_reals_last_unfft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+32*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K

;; Do 128 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 32 iterations each processing 24 data values

b0b:	start_timer 21
	mov	eax, 16			;; 16 iterations of 2
b1b:	x3cl_six_reals_first_fft esi, 64, 16*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+18*blkdst]
	xprefetcht1 [esi-128+34*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, and
;; 128K-383K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 16 data values

	start_timer 22
	mov	al, 8			;; 8 iterations of 2
b2b:	x2cl_eight_reals_fft_2 esi, 64, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-16*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4b			;; Iterate if necessary

;; Do 80 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-6*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-383K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b6b

;; Do 88 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 22 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b			;; Iterate if necessary
	lea	esi, [esi-12*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 192 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 16			;; 16 iterations of 2
d1b:	x3cl_six_reals_fft esi, 48*64, 16*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x2cl_eight_reals_fft_2 esi, 48*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-8*64+16*64]	;; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 48*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-16*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 48*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 48*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-6*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 48*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*48*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 11			;; 11 iterations of 2
d7b:	x4cl_four_complex_fft esi, 48*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*48*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 448K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft448K MACRO
	LOCAL	b0b, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 55 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 108 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 54 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 27			;; 27 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-28*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 104 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 52 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-14*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...

;; Do 16 eight_reals_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 16 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x2cl_half_eight_reals_unfft_2 esi, 64, 4*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-3*16*blkdst-8*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 128 seven_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 56 data values

	start_timer 19
	mov	al, 8			;; 8 iterations of 2
c1b:	x7cl_seven_reals_last_unfft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	xprefetcht1 [esi-128+clm*128+32*blkdst]
	xprefetcht1 [esi-128+clm*128+40*blkdst]
	xprefetcht1 [esi-128+clm*128+48*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K

;; Do 128 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 56 data values

b0b:	start_timer 21
	mov	eax, 8			;; 8 iterations of 2
b1b:	x7cl_seven_reals_first_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+2*blkdst]
	xprefetcht1 [esi-128+10*blkdst]
	xprefetcht1 [esi-128+18*blkdst]
	xprefetcht1 [esi-128+26*blkdst]
	xprefetcht1 [esi-128+34*blkdst]
	xprefetcht1 [esi-128+42*blkdst]
	xprefetcht1 [esi-128+50*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-447K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	96K	128K	160K
;;	66K
;;	...
;;	94K
;;	192K	256K	320K	384K
;;	194K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 8 data values

	start_timer 22
	mov	al, 8			;; 8 iterations of 2
b2b:	x1cl_half_eight_reals_fft_2 esi, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 16 data values

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b3a:	x2cl_four_complex_fft esi, 64, 8*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	add	dl, 256/clm
	jnc	b3a
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-24*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4b			;; Iterate if necessary

;; Do 96 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 48 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-7*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-447K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b6b

;; Do 104 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 26 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b			;; Iterate if necessary
	lea	esi, [esi-14*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 224 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 8			;; 8 iterations of 2
d1b:	x7cl_seven_reals_fft esi, 56*64, 8*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-8*64]		;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 8			;; 8 iterations of 2
d2b:	x1cl_half_eight_reals_fft_2 esi, 56*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3a:	x2cl_four_complex_fft esi, 56*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3a			;; Iterate if necessary

	lea	esi, [esi-8*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 56*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-24*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 56*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 56*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-7*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 56*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*56*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 13			;; 13 iterations of 2
d7b:	x4cl_four_complex_fft esi, 56*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*56*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 512K-element FFT.  This is done in two passes.  Pass 1
;; does 8 levels, pass 2 uses common code to perform the last 11 levels.

xfft512K MACRO
	LOCAL	b0b, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, fftdn

	set_small_FFT_constants

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 63 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
c6b:	x2cl_eight_reals_unfft_2 esi, 64, blkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 124 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 62 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 31			;; 31 iterations of 2
c7b:	x2cl_four_complex_unfft esi, 64, blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
	xprefetcht1 [esi-128+6*blkdst]
	xprefetcht1 [esi-128+7*blkdst]
	add	dl, 256/clm
	jnc	c7b
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-32*2*blkdst]	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 16 data values

	start_timer 17
	mov	al, 2			;; 2 iterations of 2 
c4b:	x2cl_eight_reals_unfft_1 esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 120 two_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 60 macros each processing 16 data values

	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters of 2
c5b:	x2cl_two_complex_unfft esi, 64, 2*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	add	dl, 256/clm
	jnc	c5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-2*blkdst+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5b			;; Iterate if necessary
	lea	esi, [esi-16*4*blkdst]	;; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft_2 macros
;; Do 16 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16K
;;	do 8 macros each processing 32 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2
c2b:	x4cl_eight_reals_unfft_2 esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 16K
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 3*256+4		;; 3 iterations of 4 iters of 2
c3b:	x4cl_four_complex_unfft esi, 64, 4*blkdst, 8*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+12*blkdst]
	add	dl, 256/clm
	jnc	c3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+16*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Reload middle counter
	jnz	c3b			;; Iterate if necessary
	lea	esi, [esi-4*16*blkdst]	;; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K

;; Do 128 eight_reals_last_unfft macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values

	start_timer 19
	mov	al, 16			;; Load loop counter
c1b:	x4cl_eight_reals_last_unfft esi, 64, 16*blkdst, 32*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+32*blkdst]
	xprefetcht1 [esi-128+clm*128+48*blkdst]
	add	dl, 256/clm
	jnc	c1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c1b			;; Iterate if necessary
	lea	esi, [esi-16*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 20
	push	esi
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	no_fft			;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64K
;;	do 64 iterations each processing 16 data values

b0b:	start_timer 21
	mov	eax, 32			;; 32 iterations of 2
b1b:	x2cl_eight_reals_first_fft esi, 64, 32*blkdst
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi-128+4*blkdst]
	xprefetcht1 [esi-128+36*blkdst]
	add	dl, 256/clm
	jnc	b1b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1b			;; Iterate if necessary
	lea	esi, [esi-32*blkdst]	;; Restore source pointer
	end_timer 21

;; Do FFT levels 4,5
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	start_timer 22
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
b2b:	x4cl_eight_reals_fft_2 esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	b2b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

	lea	esi, [esi-8*blkdst+32*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
b3b:	x4cl_four_complex_fft esi, 64, 8*blkdst, 16*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+8*blkdst]
	xprefetcht1 [esi-128+clm*128+16*blkdst]
	xprefetcht1 [esi-128+clm*128+24*blkdst]
	add	dl, 256/clm
	jnc	b3b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b3b			;; Iterate if necessary
	lea	esi, [esi-8*blkdst-32*blkdst];; Restore source pointer
	end_timer 22

;; Do FFT levels 6
;; Values 0K-15K is real data, 16K-31K is semi-real data, 32K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 8 eight_reals_fft_1 macros
;; Do 8 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 16 data values

	start_timer 23
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
b4b:	x2cl_eight_reals_fft_1 esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b4b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b4b			;; Iterate if necessary

;; Do 112 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 56 macros each processing 16 data values

	lea	esi, [esi-4*blkdst+8*blkdst];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
b5b:	x2cl_two_complex_fft esi, 64, 4*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+4*blkdst]
	add	dl, 256/clm
	jnc	b5b
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-4*blkdst+8*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b5b			;; Iterate if necessary
	lea	esi, [esi-8*8*blkdst]	;; Restore source pointer
	end_timer 23

;; Do FFT levels 7,8
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-511K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	add	dl, 256/clm
	jnc	b6b

;; Do 120 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 30 macros each processing 32 data values

	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2
b7b:	x4cl_four_complex_fft esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b7b
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b			;; Iterate if necessary
	lea	esi, [esi-16*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 256 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 32			;; 32 iterations of 2
d1b:	x2cl_eight_reals_fft esi, 64*64, 32*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations of 2
d2b:	x4cl_eight_reals_fft_2 esi, 64*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-8*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 8 iterations of 2
d3b:	x4cl_four_complex_fft esi, 64*64, 8*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-8*64-32*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations of 2
d4b:	x2cl_eight_reals_fft_1 esi, 64*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+8*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters of 2
d5b:	x2cl_two_complex_fft esi, 64*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+8*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-8*8*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 64*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*64*64+4*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 iterations of 2
d7b:	x4cl_four_complex_fft esi, 64*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDM


;; Perform a 640K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft640K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5a, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 79 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c6b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 156 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 78 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 10*256+3		;; 39 iterations
c7b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next dest pointer
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-40*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-10*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 144 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 36 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 9*256+2		;; 9 iterations of 2 iters
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-10*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;;
;; Do 32 eight_reals_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values
;;
;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K
;;
;; Do 256 five_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 40 data values

	start_timer 18
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations

c2a:	xtouchlines 3			;; Preload TLBs

c2b:	x2cl_half_eight_reals_unfft_2 ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
c3b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst8];; Restore source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/2		;; Test outer loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	edi, [edi-2*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*4*clmblkdst8-2*clmblkdst8];; Restore source pointer
c1b:	x5cl_five_reals_last_unfft ecx, 64, 2*clmblkdst8
	xloop1sp c1b, clmblkdst8
	add	ah, 256/2
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-2*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-3*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+3*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-2*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-42*blkdst]	;; Restore source pointer
	end_timer 18

;; Normalize these values

	start_timer 20
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K
;;
;; Do 256 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 40 data values

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-639K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	256K	384K	512K
;;	130K
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 8 data values
;;
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-639K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;;
;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values
;;
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

yes_fft:start_timer 21
	push	ebp
	lea	esi, [esi+40*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos2		;; Load sin/cos pointer
	mov	eax, 4			;; 4 iterations

b1a:	xtouchlines 10			;; Preload TLBs

b1b:	x5cl_five_reals_fft ecx, 64, 2*clmblkdst8
	xloop1sp b1b, 4*clmblkdst
	add	ah, 256/2		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b1b

	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
b2b:	x1cl_half_eight_reals_fft_2 ecx, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b2b

;;	lea	ecx, [ecx-2*clmblkdst8+2*clmblkdst8];; Next source pointer
b3b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b3b

	lea	ecx, [ecx-2*clmblkdst8-2*clmblkdst8];; Restore source pointer
b4b:	x4cl_eight_reals_fft_2_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
b5b:	x4cl_four_complex_fft_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	xloop1sp b5b, 2*clmblkdst8
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/4		;; Test middle loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ebp, [ebp-9*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-5*2*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-10*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+10*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-5*2*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst]	;; Restore source pointer
	lea	esi, [esi-80*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 21

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-619K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 152 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 38 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 10*256+1		;; 19 iterations
b7b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b7b
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1
	mov	al, 2
	jnz	b7b
	lea	esi, [esi-20*4*blkdst]	;; Restore dest pointer
	end_timer 24

;; Work on next 4 sets of 320 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d640K
	ELSE
d640K:	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 16			;; 16 iterations
d1b:	x5cl_five_reals_fft esi, 80*64, 16*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations
d2b:	x1cl_half_eight_reals_fft_2 esi, 80*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d3b:	x4cl_four_complex_fft esi, 80*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-16*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 80*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+4		;; 4 iterations of 4 iters
d5b:	x4cl_four_complex_fft esi, 80*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-5*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 80*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*80*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 19			;; 19 iterations
d7b:	x4cl_four_complex_fft esi, 80*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*80*64+4*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 768K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft768K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5a, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 95 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c6b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 188 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 94 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 12*256+3		;; 47 iterations
c7b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c7b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-48*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-12*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 176 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 44 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 11*256+2		;; 11 iterations of 2 iters
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-12*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	30K
;;	256K	...
;;	...
;;
;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values
;;
;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	30K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;
;; Do 256 six_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 24 data values

	start_timer 18
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations

c2a:	xtouchlines 3			;; Preload TLBs

c2b:	x4cl_eight_reals_unfft_2 ecx, 64, clmblkdst8, 2*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
c3b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop1sp c3b, 4*clmblkdst8
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/2		;; Test outer loop counter
	jnc	c3b			;; Iterate if necessary
	lea	edi, [edi-2*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-3*4*clmblkdst8];; Restore source pointer
c1b:	x3cl_six_reals_last_unfft ecx, 64, 4*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+clmblkdst8]
	add	ah, 256/4
	jnc	c1b
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer

	IF clm GT 1
	lea	ecx, [ecx-4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-3*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+3*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-46*blkdst]	;; Restore source pointer
	end_timer 18

;; Normalize these values

	start_timer 20
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;
;; Do 256 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 64 iterations each processing 24 data values

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-255K is semi-real data, and
;; 256K-767K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K	...
;;	64K	...
;;	...
;;
;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values
;;
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-767K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;;
;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values
;;
;; Do 160 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

yes_fft:start_timer 21
	push	ebp
	lea	esi, [esi+44*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos2		;; Load sin/cos pointer
	mov	eax, 4			;; 4 iterations

b1a:	xtouchlines 13			;; Preload TLBs

b1b:	x3cl_six_reals_fft ecx, 64, 4*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h/4*2
	jnc	b1b

	lea	ecx, [ecx-4*clmblkdst8];; Restore source pointer
b2b:	x2cl_eight_reals_fft_2 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b2b

	lea	ecx, [ecx-2*clmblkdst8+4*clmblkdst8];; Next source pointer
b3b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop1sp b3b, 4*clmblkdst
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b3b

	lea	ecx, [ecx-2*clmblkdst8-4*clmblkdst8];; Restore source pointer
b4b:	x4cl_eight_reals_fft_2_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Load source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	mov	ah, 5			;; 5 iterations
b5b:	x4cl_four_complex_fft_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	xloop1sp b5b, 2*clmblkdst8
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	ebp, [ebp-11*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-6*2*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-13*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+13*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-6*2*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst]	;; Restore source pointer
	lea	esi, [esi-96*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 21

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-767K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 184 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 46 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 12*256+1		;; 23 iterations
b7b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	add	dl, 256/clm
	jnc	b7b
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b7b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b7b			;; Iterate if necessary
	lea	esi, [esi-24*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 384 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d768K
	ELSE
d768K:	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 32			;; 32 iterations
d1b:	x3cl_six_reals_fft esi, 96*64, 32*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations
d2b:	x2cl_eight_reals_fft_2 esi, 96*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d3b:	x4cl_four_complex_fft esi, 96*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-32*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 96*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+4		;; 5 iterations of 4 iters
d5b:	x4cl_four_complex_fft esi, 96*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-6*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 96*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*96*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 23			;; 23 iterations
d7b:	x4cl_four_complex_fft esi, 96*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*96*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 896K-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft896K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5a, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 111 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c6b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 220 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 110 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 14*256+3		;; 55 iterations
c7b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c7b			;; Iterate if necessary
	lea	esi, [esi-56*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-14*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 208 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 52 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 13*256+2		;; 13 iterations of 2 iters
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-14*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;;
;; Do 32 eight_reals_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values
;;
;; Do 192 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K
;;
;; Do 256 seven_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 56 data values

	start_timer 18
	mov	edi, sincos3		;; Load sin/cos pointer
	lea	esi, [esi-4*blkdst]	;; Restore prefetch pointer
	mov	al, 8			;; 8 iterations

c2a:	xtouchlines 5			;; Preload TLBs

c2b:	x2cl_half_eight_reals_unfft_2 ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	mov	ah, 3
c3b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop1sp c3b, 4*clmblkdst8
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	edi, [edi-3*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-3*4*clmblkdst8-2*clmblkdst8];; Restore source pointer
c1b:	x7cl_seven_reals_last_unfft ecx, 64, 2*clmblkdst8
	xloop1sp c1b, clmblkdst8
	add	ah, 256/2
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-2*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-5*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+5*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-2*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-62*blkdst]	;; Restore prefetch pointer
	end_timer 18

;; Normalize these values

	start_timer 20
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 112
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 112

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K
;;
;; Do 256 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 56 data values

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-895K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	192K	256K	320K
;;	130K
;;	...
;;	190K
;;	384K	512K	640K	768K
;;	386K
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_2 macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 8 data values
;;
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-895K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;;
;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values
;;
;; Do 192 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 48 macros each processing 32 data values

yes_fft:start_timer 21
	push	ebp
	lea	esi, [esi+56*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos2		;; Load sin/cos pointer
	mov	eax, 4			;; 4 iterations

b1a:	xtouchlines 14			;; Preload TLBs

b1b:	x7cl_seven_reals_fft ecx, 64, 2*clmblkdst8
	xloop1sp b1b, 4*clmblkdst
	add	ah, 256/2		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b1b

	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
b2b:	x1cl_half_eight_reals_fft_2 ecx, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b2b

;;	lea	ecx, [ecx-2*clmblkdst8+2*clmblkdst8];; Next source pointer
b3a:	x2cl_four_complex_fft ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b3a

	lea	ecx, [ecx-2*clmblkdst8+4*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop1sp b3b, 4*clmblkdst
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b3b
	lea	edi, [edi-XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*clmblkdst8-6*clmblkdst8];; Restore source pointer
b4b:	x4cl_eight_reals_fft_2_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Load source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	mov	ah, 6			;; 6 iterations
b5b:	x4cl_four_complex_fft_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	xloop1sp b5b, 2*clmblkdst8
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	ebp, [ebp-13*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-7*2*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-14*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+14*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-7*2*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst]	;; Restore source pointer
	lea	esi, [esi-112*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 21

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-895K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 208 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 54 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 14*256+1		;; 27 iterations
b7b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b7b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b7b			;; Iterate if necessary
	lea	esi, [esi-28*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 448 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d896K
	ELSE
d896K:	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 16			;; 16 iterations
d1b:	x7cl_seven_reals_fft esi, 112*64, 16*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-16*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 16			;; 16 iterations
d2b:	x1cl_half_eight_reals_fft_2 esi, 112*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d3a:	x2cl_four_complex_fft esi, 112*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3a			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sin/cos pointer
	mov	al, 16			;; 16 iterations
d3b:	x4cl_four_complex_fft esi, 112*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-48*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 112*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+4		;; 6 iterations of 4 iters
d5b:	x4cl_four_complex_fft esi, 112*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-7*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 112*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*112*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 27			;; 27 iterations
d7b:	x4cl_four_complex_fft esi, 112*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*112*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 1M-element FFT.  This is done in two passes.  Pass 1
;; does 9 levels, pass 2 uses common code to perform the last 11 levels.

xfft1024K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4a, c4b, c5a, c5b, c6b, c7b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 127 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c6b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary

;; Do 252 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 16*256+3		;; 63 iterations
c7b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c7b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7b			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next dest pointer
	sub	ah, 1
	mov	al, 4
	jnz	c7b
	lea	esi, [esi-64*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-16*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations
c4a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c4b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 240 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 60 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 15*256+2		;; 15 iterations of 2 iters
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-16*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;;
;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values
;;
;; Do 192 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;
;; Do 256 eight_reals_last_unfft macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values

	start_timer 18
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 8			;; 8 iterations

c2a:	xtouchlines 4			;; Preload TLBs

c2b:	x4cl_eight_reals_unfft_2 ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop1sp c2b, 4*clmblkdst8

	mov	ah, 3			;; 3 iterations
c3b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop1sp c3b, 4*clmblkdst8
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	edi, [edi-3*XMM_SCD]	;; Next sine/cosine pointer

	lea	ecx, [ecx-4*4*clmblkdst8];; Next source pointer
c1b:	x4cl_eight_reals_last_unfft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+clmblkdst8];; Restore source pointer
	add	ah, 256/4
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-4*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+4*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary

	lea	esi, [esi-64*blkdst]	;; Restore prefetch pointer
	end_timer 18

;; Normalize these values

	start_timer 20
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 20

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;;
;; Do 256 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128K
;;	do 128 iterations each processing 16 data values

;; Do FFT levels 4,5
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values
;;
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 6,7
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;;
;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values
;;
;; Do 224 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 56 macros each processing 32 data values

yes_fft:start_timer 21
	push	ebp
	lea	esi, [esi+64*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos2		;; Load sin/cos pointer
	mov	eax, 4			;; 4 iterations

b1a:	xtouchlines 16			;; Preload TLBs

b1b:	x2cl_eight_reals_fft ecx, 64, 8*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h/8*2
	jnc	b1b

	lea	ecx, [ecx-8*clmblkdst8];; Restore source pointer
b2b:	x4cl_eight_reals_fft_2 ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b2b

	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst]
	add	ah, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	lea	ecx, [ecx-2*4*clmblkdst+clmblkdst8]
	add	eax, 80000000h
	jnc	b3b
	lea	edi, [edi-XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*clmblkdst8-8*clmblkdst8];; Restore source pointer
b4b:	x4cl_eight_reals_fft_2_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	xloop1sp b4b, 2*clmblkdst8

	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	mov	ah, 7			;; 7 iterations
b5b:	x4cl_four_complex_fft_screg ecx, 64, 4*clmblkdst, clmblkdst8, ebp
	xloop1sp b5b, 2*clmblkdst8
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	ebp, [ebp-15*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-8*2*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-16*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+16*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-8*2*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst]	;; Restore source pointer
	lea	esi, [esi-128*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 21

;; Do FFT levels 8,9
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1023K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos1		;; Load sin/cos pointer
b6b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	dl, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary

;; Do 248 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 62 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 16*256+1		;; 31 iterations
b7b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b7b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b7b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b7b			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1
	mov	al, 2
	jnz	b7b
	lea	esi, [esi-32*4*blkdst]	;; Restore source pointer
	end_timer 24

;; Work on next 4 sets of 512 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 26
	CALL_X	gw_split_carries_3
	end_timer 26

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d1024K
	ELSE
d1024K:	start_timer 27
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 64			;; 64 iterations
d1b:	x2cl_eight_reals_fft esi, 128*64, 64*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d2b:	x4cl_eight_reals_fft_2 esi, 128*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 16			;; 16 iterations
d3b:	x4cl_four_complex_fft esi, 128*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-16*64-64*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 128*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+4		;; 7 iterations of 4 iters
d5b:	x4cl_four_complex_fft esi, 128*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-8*16*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos1		;; Load sin/cos pointer
d6b:	x4cl_eight_reals_fft_2 esi, 128*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary

	lea	esi, [esi-2*128*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 31			;; 31 iterations
d7b:	x4cl_four_complex_fft esi, 128*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*128*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d7b			;; Iterate if necessary
	end_timer 27

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 1280K-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft1280K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b
	LOCAL	b4b, b5b, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5b, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 159 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 316 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 158 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 20*256+3		;; 79 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-80*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-20*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c6b			;; Iterate if necessary

;; Do 304 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 76 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 19*256+2		;; 19 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-20*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values
;;
;; Do 304 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 152 macros each processing 16 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	768K
;;	...
;;
;; Do 64 eight_reals_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 16 data values
;;
;; Do 256 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	768K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	512K	768K	1024K
;;	258K
;;	...
;;	510K
;;
;; Do 512 five_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 40 data values

	start_timer 18
	push	ebp
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos4		;; Load sin/cos pointer
	mov	eax, 8			;; 8 iterations 

c2a:	xtouchlines 8			;; Preload TLBs

c4b:	x2cl_eight_reals_unfft_1 ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	mov	ah, 9			;; 9 iterations
c5b:	x2cl_two_complex_unfft ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1		;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	edi, [edi-9*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-10*2*clmblkdst8];; Restore source pointer
c2b:	x2cl_half_eight_reals_unfft_2 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+clmblkdst8]
	add	ah, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*clmblkdst8+4*clmblkdst8];; Next source pointer
c3b:	x4cl_four_complex_unfft_screg ecx, 64, 2*clmblkdst8, 4*clmblkdst8, ebp
	xloop1sp c3b, clmblkdst8
	add	edx, 80000000h		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8]
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/2		;; Test outer loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ebp, [ebp-2*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*8*clmblkdst8-4*clmblkdst8];; Restore source pointer
c1b:	x5cl_five_reals_last_unfft ecx, 64, 4*clmblkdst8
	xloop1sp c1b, clmblkdst8
	add	ah, 256/4
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-8*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c4b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+8*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-102*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 18

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	512K	768K	1024K
;;	258K
;;	...
;;	510K
;;
;; Do 512 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 40 data values

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-1279K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	512K	768K	1024K
;;	258K
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;;
;; Do 64 eight_reals_fft_2 macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 8 data values
;;
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-1279K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values
;;
;; Do 256 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 128 macros each processing 16 data values

yes_fft:start_timer 22
	push	ebp
	lea	esi, [esi+60*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	ebp, sincos3		;; Load sin/cos pointer
	mov	eax, 2			;; 16 iterations

b1a:	xtouchlines 4			;; Preload TLBs

b1b:	x5cl_five_reals_fft ecx, 64, 4*clmblkdst8
	xloop1sp b1b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b1b

	lea	ecx, [ecx-2*2*clmblkdst8];; Restore source pointer
b2b:	x1cl_half_eight_reals_fft_2 ecx, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	add	ah, 256/2
	jnc	b2b

;;	lea	ecx, [ecx-2*2*clmblkdst8+4*clmblkdst8];; Next source pointer
b3b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	xloop1sp b3b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b3b

	lea	ecx, [ecx-4*clmblkdst8-4*clmblkdst8];; Restore source pointer
b4b:	x2cl_eight_reals_fft_1 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
b5b:	x2cl_two_complex_fft_screg ecx, 64, 2*clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/4		;; Test outer loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ebp, [ebp-9*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-5*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-4*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+4*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-5*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	b1a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
	pop	ebp
	end_timer 22

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b6b			;; Iterate if necessary

;; Do 288 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 72 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 9*256+4		;; 9 iterations of 4 iters
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop1	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-10*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-160*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 312 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 78 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 20*256+1		;; 39 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-40*4*blkdst]	;; Restore dest pointer
	end_timer 26

;; Work on next 4 sets of 640 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d1280K
	ELSE
d1280K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 32			;; 32 iterations
d1b:	x5cl_five_reals_fft esi, 160*64, 32*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 32			;; 32 iterations
d2b:	x1cl_half_eight_reals_fft_2 esi, 160*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations
d3b:	x4cl_four_complex_fft esi, 160*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-32*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x2cl_eight_reals_fft_1 esi, 160*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+16		;; 4 iterations of 16 iters
d5b:	x2cl_two_complex_fft esi, 160*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-5*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 160*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 9*256+4		;; 9 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 160*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-10*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 160*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*160*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 39			;; 39 iterations
d9b:	x4cl_four_complex_fft esi, 160*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*160*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 2M-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft1536K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5b, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 191 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 380 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 190 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 24*256+3		;; 95 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-96*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-24*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c6b			;; Iterate if necessary

;; Do 368 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 92 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 23*256+2		;; 23 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-24*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values
;;
;; Do 352 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 176 macros each processing 16 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...
;;
;; Do 64 eight_reals_unfft_2 macros
;; Do 64 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values
;;
;; Do 256 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;
;; Do 512 six_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 128 macros each processing 24 data values

	start_timer 18
	push	ebp
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos4		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations 

c2a:	xtouchlines 12			;; Preload TLB

c4b:	x2cl_eight_reals_unfft_1 ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	mov	ah, 11			;; 11 iterations
c5b:	x2cl_two_complex_unfft ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	edi, [edi-11*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-12*2*clmblkdst8];; Restore source pointer
c2b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+clmblkdst8]
	add	ah, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Next source pointer
c3b:	x4cl_four_complex_unfft_screg ecx, 64, 2*clmblkdst8, 4*clmblkdst8, ebp
	xloop1sp c3b, clmblkdst8
	add	edx, 80000000h		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8]
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/2
	jnc	c3b
	lea	ebp, [ebp-2*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-3*8*clmblkdst8];; Restore source pointer
c1b:	x3cl_six_reals_last_unfft ecx, 64, 8*clmblkdst8
	xloop1sp c1b, clmblkdst8
	add	ah, 256/8
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-8*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-12*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c4b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+12*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-8*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-142*blkdst]	;; Restore source pointer
	pop	ebp
	end_timer 18

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;
;; Do 512 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 128 iterations each processing 24 data values

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-511K is semi-real data, 512K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;;
;; Do 64 eight_reals_fft_2 macros
;; Do 64 nop_two_two_complex_fft_2 macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 16 data values
;;
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values
;;
;; Do 320 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 160 macros each processing 16 data values

yes_fft:start_timer 22
	push	ebp
	lea	esi, [esi+116*blkdst]	;; Create prefetch pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	ebp, sincos3		;; Load sin/cos pointer
	mov	eax, 2			;; 16 iterations

b1a:	xtouchlines 2			;; Preload TLBs

b1b:	x3cl_six_reals_fft ecx, 64, 8*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	add	ah, 256/4
	jnc	b1b

	lea	ecx, [ecx-4*2*clmblkdst8];; Restore source pointer
b2b:	x2cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	add	ah, 256/2
	jnc	b2b

	lea	ecx, [ecx-2*2*clmblkdst8+8*clmblkdst8];; Next source pointer
b3b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	xloop1sp b3b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b3b

	lea	ecx, [ecx-2*2*clmblkdst8-8*clmblkdst8];; Restore source pointer
b4b:	x2cl_eight_reals_fft_1 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+4*clmblkdst8];; Load source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	mov	ah, 5			;; 5 iterations
b5b:	x2cl_two_complex_fft_screg ecx, 64, 2*clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	ebp, [ebp-11*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-6*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-2*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+2*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-6*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	b1a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
	pop	ebp
	end_timer 22

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b6b			;; Iterate if necessary

;; Do 352 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 88 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 11*256+4		;; 11 iterations of 4 iters
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop1	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-12*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-192*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1535K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 504 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 24*256+1		;; 47 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-48*4*blkdst]	;; Restore source pointer
	end_timer 26

;; Work on next 4 sets of 768 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d1536K
	ELSE
d1536K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 64			;; 64 iterations
d1b:	x3cl_six_reals_fft esi, 192*64, 64*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 32			;; 32 iterations
d2b:	x2cl_eight_reals_fft_2 esi, 192*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-32*64+64*64]	;; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations
d3b:	x4cl_four_complex_fft esi, 192*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-64*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x2cl_eight_reals_fft_1 esi, 192*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+16		;; 5 iterations of 16 iters
d5b:	x2cl_two_complex_fft esi, 192*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-6*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 192*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 11*256+4		;; 11 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 192*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-12*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 192*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*192*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 47			;; 47 iterations
d9b:	x4cl_four_complex_fft esi, 192*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*192*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 1792K-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft1792K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3a, b3b, b4b
	LOCAL	b5b, b6a, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5b
	LOCAL	c6a, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 223 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 444 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 222 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 28*256+3		;; 111 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-112*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-28*clmblkdst8] ;; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
 	mov	al, 2			;; 2 iterations
c6a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c6b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	c6a			;; Iterate if necessary

;; Do 432 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 108 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 27*256+2		;; 27 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-28*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...

;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values
;;
;; Do 416 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 208 macros each processing 16 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	...
;;
;; Do 64 eight_reals_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 16 data values
;;
;; Do 384 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 96 macros each processing 32 data values
;;
;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;	768K	1024K	1280K	1536K
;;	770K
;;	...
;;	1022K
;;
;; Do 512 seven_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 56 data values

	start_timer 18
	push	ebp
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos4		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations 

c2a:	xtouchlines 14			;; Preload TLBs

c4b:	x2cl_eight_reals_unfft_1 ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	mov	ah, 13			;; 13 iterations
c5b:	x2cl_two_complex_unfft ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	edi, [edi-13*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-14*2*clmblkdst8];; Restore source pointer
c2b:	x2cl_half_eight_reals_unfft_2 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+clmblkdst8]
	add	ah, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*clmblkdst8+4*clmblkdst8];; Next source pointer
	mov	ah, 3			;; 3 iterations
c3b:	x4cl_four_complex_unfft_screg ecx, 64, 2*clmblkdst8, 4*clmblkdst8, ebp
	xloop1sp c3b, clmblkdst8
	add	edx, 80000000h		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8]
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	c3b			;; Iterate if necessary
	lea	ebp, [ebp-3*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-3*8*clmblkdst8-4*clmblkdst8];; Restore source pointer
c1b:	x7cl_seven_reals_last_unfft ecx, 64, 4*clmblkdst8
	xloop1prefetch2sp c1b, clmblkdst8
	add	ah, 256/4
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-14*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c4b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+14*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-168*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 18

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 224
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 224

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;	768K	1024K	1280K	1536K
;;	770K
;;	...
;;	1022K
;;
;; Do 512 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 56 data values

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-511K is semi-real data, 512K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	384K	512K	640K
;;	258K
;;	...
;;	382K
;;	768K	1024K	1280K	1536K
;;	770K
;;	...
;;	1022K
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;;
;; Do 64 eight_reals_fft_2 macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 8 data values
;;
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values
;;
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values
;;
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values
;;
;; Do 384 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 192 macros each processing 16 data values

yes_fft:start_timer 22
	push	ebp
	lea	esi, [esi+72*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	ebp, sincos3		;; Load sin/cos pointer
	mov	eax, 2			;; 16 iterations

b1a:	xtouchlines 6			;; Preload TLBs

b1b:	x7cl_seven_reals_fft ecx, 64, 4*clmblkdst8
	xloop1prefetch2sp b1b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b1b

	lea	ecx, [ecx-2*2*clmblkdst8];; Restore source pointer
b2b:	x1cl_half_eight_reals_fft_2 ecx, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	add	ah, 256/2
	jnc	b2b

;;	lea	ecx, [ecx-2*2*clmblkdst8+4*clmblkdst8];; Next source pointer
b3a:	x2cl_four_complex_fft ecx, 64, 4*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b3a			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	add	ah, 256/2
	jnc	b3a

	lea	ecx, [ecx-2*2*clmblkdst8+8*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	xloop1sp b3b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b3b
	lea	edi, [edi-XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*2*clmblkdst8-12*clmblkdst8];; Restore src pointer
b4b:	x2cl_eight_reals_fft_1 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	mov	ah, 6			;; 6 iterations
b5b:	x2cl_two_complex_fft_screg ecx, 64, 2*clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	ebp, [ebp-13*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-7*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-6*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+6*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-7*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	b1a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
	pop	ebp
	end_timer 22

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	xloop1	b6b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	b6a			;; Iterate if necessary

;; Do 416 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 104 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 13*256+4		;; 13 iterations of 4 iters
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop1	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-14*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-224*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-1791K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 440 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 110 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 28*256+1		;; 55 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-56*4*blkdst]	;; Restore dest pointer
	end_timer 26

;; Work on next 4 sets of 896 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d1792K
	ELSE
d1792K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	al, 32			;; 32 iterations
d1b:	x7cl_seven_reals_fft esi, 224*64, 32*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-32*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 32			;; 32 iterations
d2b:	x1cl_half_eight_reals_fft_2 esi, 224*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations
d3a:	x2cl_four_complex_fft esi, 224*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3a			;; Iterate if necessary

	lea	esi, [esi-32*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 32			;; 32 iterations
d3b:	x4cl_four_complex_fft esi, 224*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-96*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x2cl_eight_reals_fft_1 esi, 224*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+16		;; 6 iterations of 16 iters
d5b:	x2cl_two_complex_fft esi, 224*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-7*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 224*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 13*256+4		;; 13 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 224*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-14*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 224*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*224*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 55			;; 55 iterations
d9b:	x4cl_four_complex_fft esi, 224*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*224*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 2M-element FFT.  This is done in two passes.  Pass 1
;; does 10 levels, pass 2 uses common code to perform the last 11 levels.

xfft2048K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6a, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b, c5b, c6a, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 255 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 508 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 254 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 32*256+3		;; 127 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-128*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-32*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c6a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c6b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	c6a			;; Iterate if necessary

;; Do 492 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 124 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	eax, 31*256+2		;; 31 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-32*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_unfft_1 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 16 data values
;;
;; Do 480 four_complex_unfft macros
;;	distance between fft data elements is 32K
;;	do 240 macros each processing 16 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...
;;
;; Do 64 eight_reals_unfft_2 macros
;; Do 64 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 64K
;;	do 32 macros each processing 32 data values
;;
;; Do 384 four_complex_unfft macros
;;	distance between fft data elements is 64K
;;	do 96 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K
;;
;; Do 512 eight_reals_last_unfft macros
;;	distance between fft data elements is 256K
;;	do 128 macros each processing 32 data values

	start_timer 18
	push	ebp
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	ebp, sincos4		;; Load sin/cos pointer
	mov	al, 8			;; 8 iterations

c2a:	xtouchlines 16			;; Preload TLBs

c4b:	x2cl_eight_reals_unfft_1 ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	mov	ah, 15			;; 15 iterations
c5b:	x2cl_two_complex_unfft ecx, 64, clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	c5b			;; Iterate if necessary
	lea	edi, [edi-15*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-16*2*clmblkdst8];; Restore source pointer
c2b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop1sp c2b, clmblkdst8
	add	ah, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Next source pointer
	mov	ah, 3			;; 3 iterations
c3b:	x4cl_four_complex_unfft_screg ecx, 64, 2*clmblkdst8, 4*clmblkdst8, ebp
	xloop1sp c3b, clmblkdst8
	add	edx, 80000000h		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8]
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1
	jnz	c3b
	lea	ebp, [ebp-3*XMM_SCD]	;; Next sine/cosine pointer

	lea	ecx, [ecx-4*8*clmblkdst8];; Restore source pointer
c1b:	x4cl_eight_reals_last_unfft ecx, 64, 8*clmblkdst8, 16*clmblkdst8
	xloop1sp c1b, clmblkdst8
	add	ah, 256/8
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-8*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-16*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c4b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+16*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-8*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-192*blkdst]	;; Restore prefetch pointer
	pop	ebp
	end_timer 18

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K	...
;;	1024K	...
;;	...
;;
;; Do 512 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 256K
;;	do 256 iterations each processing 16 data values

;; Do FFT levels 4,5
;; Values 0K-255K is real data, 256K-511K is semi-real data, 512K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K	...
;;	1024K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;;
;; Do 64 eight_reals_fft_2 macros
;; Do 64 nop_two_two_complex_fft_2 macros
;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values
;;
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6
;; Values 0K-63K is real data, 64K-127K is semi-real data, 128K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 32 eight_reals_fft_1 macros
;; Do 32 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 16 data values
;;
;; Do 448 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 224 macros each processing 16 data values

yes_fft:start_timer 22
	push	ebp
	lea	esi, [esi+128*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	ebp, sincos3		;; Load sin/cos pointer
	mov	eax, 2			;; 16 iterations

b1a:	xtouchlines 4			;; Preload TLBs

b1b:	x2cl_eight_reals_fft ecx, 64, 16*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	b1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8];; Next source pointer
	add	ah, 256/8
	jnc	b1b

	lea	ecx, [ecx-8*2*clmblkdst8];; Restore source pointer
b2b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	xloop1sp b2b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b2b

	lea	ecx, [ecx-2*2*clmblkdst8+16*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	xloop1sp b3b, 2*clmblkdst8
	add	ah, 256/2
	jnc	b3b
	lea	edi, [edi-XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*2*clmblkdst8-16*clmblkdst8];; Restore src pointer
b4b:	x2cl_eight_reals_fft_1 ecx, 64, 2*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+4*clmblkdst8];; Load source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
	mov	ah, 7			;; 7 iterations
b5b:	x2cl_two_complex_fft_screg ecx, 64, 2*clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test outer loop counter
	jnz	b5b			;; Iterate if necessary
	lea	ebp, [ebp-15*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-8*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-4*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+4*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-8*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	b1a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
	pop	ebp
	end_timer 22

;; Do FFT levels 7,8
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	xloop1	b6b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	b6a			;; Iterate if necessary

;; Do 480 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 120 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 15*256+4		;; 15 iterations of 4 iters
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop1	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-16*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-256*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 9,10
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-2047K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 504 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 126 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 32*256+1		;; 63 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-64*4*blkdst]	;; Restore source pointer
	end_timer 26

;; Work on next 4 sets of 1024 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d2048K
	ELSE
d2048K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 128*256		;; 128 iterations
d1b:	x2cl_eight_reals_fft esi, 256*64, 128*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-128*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 32			;; 32 iterations
d2b:	x4cl_eight_reals_fft_2 esi, 256*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-32*64+128*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 32			;; 32 iterations
d3b:	x4cl_four_complex_fft esi, 256*64, 32*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-32*64-128*64]	;; Restore source pointer

;; Do FFT levels 6

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x2cl_eight_reals_fft_1 esi, 256*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+16		;; 7 iterations of 16 iters
d5b:	x2cl_two_complex_fft esi, 256*64, 16*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-8*32*64]	;; Restore source pointer

;; Do FFT levels 7,8

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 256*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 15*256+4		;; 15 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 256*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-16*16*64]	;; Restore source pointer

;; Do FFT levels 9,10

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 256*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*256*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 63			;; 63 iterations
d9b:	x4cl_four_complex_fft esi, 256*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*256*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 2560K-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft2560K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b
	LOCAL	c5a, c5b, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 319 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 636 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 318 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 40*256+3		;; 159 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-160*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-40*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c6b			;; Iterate if necessary

;; Do 624 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 156 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 39			;; 39 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop2	c7b, clmblkdst
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-40*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	start_timer 18
	mov	al, 8			;; 8 iterations
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, clmblkdst8, 2*clmblkdst8
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 656 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 144 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst+4*clmblkdst8];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 9*256+4		;; 9 iterations of 4 iters of 2
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop2	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-4*2*clmblkdst+4*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-10*4*clmblkdst8];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...
;;
;; Do 128 eight_reals_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 16 data values
;;
;; Do 512 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	1024K	1536K	2048K
;;	514K
;;	...
;;	1022K
;;
;; Do 1024 five_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 128 macros each processing 40 data values

	start_timer 19
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 4			;; 32 iterations

c2a:	xtouchlines 3			;; Preload TLBs

c2b:	x2cl_half_eight_reals_unfft_2 ecx, 64, 4*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+8*clmblkdst8];; Next source pointer
c3b:	x4cl_four_complex_unfft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+16*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/2		;; Test middle loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	edi, [edi-2*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-2*16*clmblkdst8-8*clmblkdst8];; Restore src pointer
c1b:	x5cl_five_reals_last_unfft ecx, 64, 8*clmblkdst8
	xloop1sp c1b, 4*clmblkdst8
	add	ah, 256/2
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-2*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-3*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+3*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-2*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	c2a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-171*blkdst]	;; Restore prefetch pointer
	end_timer 19

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 320
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 320

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	1024K	1536K	2048K
;;	514K
;;	...
;;	1022K
;;
;; Do 1024 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 128 iterations each processing 40 data values

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-2559K is complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	1024K	1536K	2048K
;;	514K
;;	...
;;	1022K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;;
;; Do 128 eight_reals_fft_2 macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 8 data values
;;
;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-2559K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;;
;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values
;;
;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 128 macros each processing 32 data values

yes_fft:start_timer 22
	push	ebp
	lea	esi, [esi+170*blkdst]	;; Create prefetching pointer
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	ebp, sincos3		;; Load sin/cos pointer
	mov	eax, 2			;; 16 iterations

b1a:	xtouchlines 7			;; Preload TLBs

b1b:	x5cl_five_reals_fft ecx, 64, 8*clmblkdst8
	xloop1sp b1b, 2*clmblkdst8
	add	ah, 256/4		;; Test inner loop counter
	jnc	b1b			;; Iterate if necessary

	lea	ecx, [ecx-4*2*clmblkdst8];; Restore source pointer
b2b:	x1cl_half_eight_reals_fft_2 ecx, 64
	add	al, 256/2		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8]
	add	ah, 256/4		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer

;;	lea	ecx, [ecx-4*2*clmblkdst8+8*clmblkdst8]
b3b:	x4cl_four_complex_fft ecx, 64, 8*clmblkdst8, 16*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+2*clmblkdst8]
	add	ah, 256/4		;; Test inner loop counter
	jnc	b3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer

	lea	ecx, [ecx-4*2*clmblkdst8-8*clmblkdst8];;Restore src pointer
b4b:	x4cl_eight_reals_fft_2_screg ecx, 64, 2*clmblkdst8, 4*clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer

	lea	ecx, [ecx-2*64+8*clmblkdst8];; Next source pointer
	lea	ebp, [ebp+XMM_SCD]	;; Next sine/cosine pointer
b5b:	x4cl_four_complex_fft_screg ecx, 64, 2*clmblkdst8, 4*clmblkdst8, ebp
	add	al, 256/2		;; Test inner loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+8*clmblkdst8]
	lea	ebp, [ebp+2*XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/4		;; Test outer loop counter
	jnc	b5b			;; Iterate if necessary
	lea	ebp, [ebp-9*XMM_SCD]	;; Restore sine/cosine pointer

	IF clm GT 1
	lea	ecx, [ecx-5*8*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-7*blkdst+128];; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	b1b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+7*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-5*8*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	b1a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8]	;; Restore source pointer
	pop	ebp
	end_timer 22

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-2559K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b6b			;; Iterate if necessary

;; Do 608 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 152 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 19*256+2		;; 19 iterations of 2 iters of 2
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop2	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-2*2*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-20*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-320*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-2559K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 632 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 158 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 40*256+1		;; 79 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-80*4*blkdst]	;; Restore source pointer
	end_timer 26

;; Work on next 4 sets of 1280 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d2560K
	ELSE
d2560K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 64			;; 64 iterations
d1b:	x5cl_five_reals_fft esi, 320*64, 64*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 64			;; 64 iterations
d2b:	x1cl_half_eight_reals_fft_2 esi, 320*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations
d3b:	x4cl_four_complex_fft esi, 320*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-64*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 320*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 4*256+16		;; 4 iterations of 16 iters
d5b:	x4cl_four_complex_fft esi, 320*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-5*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 320*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 19*256+4		;; 19 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 320*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-20*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 320*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*320*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 79			;; 79 iterations
d9b:	x4cl_four_complex_fft esi, 320*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*320*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 3M-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft3072K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4b
	LOCAL	b5a, b5b, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4b
	LOCAL	c5a, c5b, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 383 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 764 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 382 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 48*256+3		;; 191 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-192*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-48*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations 
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c6b			;; Iterate if necessary

;; Do 752 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 188 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 47			;; 47 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop2	c7b, clmblkdst
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-48*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	start_timer 18
	mov	al, 8			;; 8 iterations
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, clmblkdst8, 2*clmblkdst8
	add	al, 256/2/clm		;; Test loop counter
	jnc	c4b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c4b			;; Iterate if necessary

;; Do 704 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 176 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst+4*clmblkdst8];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 11*256+4		;; 11 iterations of 4 iters of 2
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop2	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-4*2*clmblkdst+4*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-12*4*clmblkdst8];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...
;;
;; Do 128 eight_reals_unfft_2 macros
;; Do 128 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values
;;
;; Do 512 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	1536K	2048K	2560K
;;	1026K
;;	...
;;	1534K
;;
;; Do 1024 six_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 256 macros each processing 24 data values

	start_timer 19
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 4			;; 32 iterations

c2a:	xtouchlines 3			;; Preload TLBs

c2b:	x4cl_eight_reals_unfft_2 ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+16*clmblkdst8];; Next source pointer
c3b:	x4cl_four_complex_unfft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+16*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	ah, 256/2		;; Test middle loop counter
	jnc	c3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	edi, [edi-2*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-3*16*clmblkdst8];; Restore source pointer
c1b:	x3cl_six_reals_last_unfft ecx, 64, 16*clmblkdst8
	add	al, 256/2		;; Test inner loop counter
	jnc	c1b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+4*clmblkdst8];; Next source pointer
	add	ah, 256/2		;; Test middle loop counter
	jnc	c1b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	add	edx, 80000000h		;; Test middle loop counter
	jnc	c1b			;; Iterate if necessary

	IF clm GT 1
	lea	ecx, [ecx-4*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-3*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+3*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-4*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	c2a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-187*blkdst]	;; Restore source pointer
	end_timer 19

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 384
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 384

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	1536K	2048K	2560K
;;	1026K
;;	...
;;	1534K
;;
;; Do 1024 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 128 iterations each processing 24 data values

yes_fft:start_timer 22
	mov	ecx, scratch_area	;; Get address of scratch area
	lea	esi, [esi+186*blkdst]	;; Create prefetching pointer
	mov	eax, 16			;; 64 iterations 2 iters
b1a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b1b:	x3cl_six_reals_fft ecx, 64, 16*clmblkdst8
	xloop2	b1b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b1a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-16*clmblkdst8];; Restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-1023K is semi-real data, 1024K-3071K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	1536K	2048K	2560K
;;	1026K
;;	...
;;	1534K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;; Do 128 nop_two_two_complex_fft_2 macros
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 16 data values

	start_timer 23
	mov	al, 8			;; 16 iterations of 4 iters
b2a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b2b:	x2cl_eight_reals_fft_2 ecx, 64, 8*clmblkdst8
	xloop4	b2b, clmblkdst
	add	eax, 80000000h
	jnc	b2a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst8+16*clmblkdst8];; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 8			;; 32 iterations of 2 iters
b3a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b3b:	x4cl_four_complex_fft ecx, 64, 8*clmblkdst8, 16*clmblkdst8
	xloop2	b3b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b3a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst8-16*clmblkdst8];; Restore src pointer
	end_timer 23

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 2			;; 16 iterations
b4b:	x4cl_eight_reals_fft_2 ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b4b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	add	ah, 256/8
	jnc	b4b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b4b			;; Iterate if necessary

;; Do 640 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 160 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+2		;; 5 iterations of 8 iters of 2
b5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b5b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop2	b5b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b5a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	ecx, [ecx-6*8*clmblkdst8];; Restore source pointer
	end_timer 24

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-3071K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b6b			;; Iterate if necessary

;; Do 736 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 184 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 23*256+2		;; 23 iterations of 2 iters of 2
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop2	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-2*2*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-24*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-384*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-3071K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 760 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 190 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 48*256+1		;; 95 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-96*4*blkdst]	;; Restore source pointer
	end_timer 26

;; Work on next 4 sets of 1536 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d3072K
	ELSE
d3072K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 128*256		;; 128 iterations
d1b:	x3cl_six_reals_fft esi, 384*64, 128*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-128*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 64			;; 64 iterations
d2b:	x2cl_eight_reals_fft_2 esi, 384*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-64*64+128*64]	;; Next source pointer
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations
d3b:	x4cl_four_complex_fft esi, 384*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-128*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 384*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 5*256+16		;; 5 iterations of 16 iters
d5b:	x4cl_four_complex_fft esi, 384*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-6*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 384*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 23*256+4		;; 23 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 384*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-24*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 384*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*384*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 95			;; 95 iterations
d9b:	x4cl_four_complex_fft esi, 384*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*384*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 3584K-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft3584K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2b, b3a0, b3a, b3, b3b, b4a, b4b
	LOCAL	b5a, b5b, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4a, c4b, c5a, c5b
	LOCAL	c6a, c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3a, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 447 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 892 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 446 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 56*256+3		;; 223 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-224*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-56*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	mov	al, 2			;; 2 iterations
c6a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop1	c6b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	c6a			;; Iterate if necessary

;; Do 880 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 220 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 55			;; 55 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop2	c7b, clmblkdst
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-56*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	start_timer 18
	mov	al, 8			;; 8 iterations
c4a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop1	c4b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 832 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 208 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst+4*clmblkdst8];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 13*256+4		;; 13 iterations of 4 iters of 2
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop2	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-4*2*clmblkdst+4*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-14*4*clmblkdst8];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...
;;
;; Do 128 eight_reals_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values
;;
;; Do 768 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 192 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;	1536K	2048K	2560K	3072K
;;	1538K
;;	...
;;	2046K
;;
;; Do 1024 seven_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 128 macros each processing 56 data values

	start_timer 19
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 4			;; 32 iterations

c2a:	xtouchlines 5			;; Preload TLBs

c2b:	x2cl_half_eight_reals_unfft_2 ecx, 64, 4*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c2b			;; Iterate if necessary

	lea	ecx, [ecx-2*64+8*clmblkdst8];; Next source pointer
	mov	ah, 3			;; 3 iterations
c3b:	x4cl_four_complex_unfft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+16*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test middle loop counter
	jnz	c3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	edi, [edi-3*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-3*16*clmblkdst8-8*clmblkdst8];; Restore src pointer
c1b:	x7cl_seven_reals_last_unfft ecx, 64, 8*clmblkdst8
	xloop1prefetch2sp c1b, 4*clmblkdst8
	add	ah, 256/2
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-2*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-5*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+5*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-2*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	c2a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-277*blkdst]	;; Restore prefetch pointer
	end_timer 19

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 448
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 448

;; Do FFT levels 1,2,3
;;
;; On input and output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;	1536K	2048K	2560K	3072K
;;	1538K
;;	...
;;	2046K
;;
;; Do 1024 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 128 iterations each processing 56 data values

yes_fft:start_timer 22
	mov	ecx, scratch_area	;; Get address of scratch area
	lea	esi, [esi+162*blkdst]	;; Create prefetching pointer
	mov	eax, 8			;; 64 iterations
b1a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
	xtouch	[esi+(clm-1)*128+blkdst]
b1b:	x7cl_seven_reals_fft ecx, 64, 8*clmblkdst8
	xloop1prefetch2 b1b, clmblkdst
	add	ah, 256/8
	jnc	b1a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst8]	;; Restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-1023K is semi-real data, 1024K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K
;;	512K	768K	1024K	1280K
;;	514K
;;	...
;;	766K
;;	1536K	2048K	2560K	3072K
;;	1538K
;;	...
;;	2046K
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 8 data values

	start_timer 23
	mov	al, 8			;; 64 iterations
b2b:	x1cl_half_eight_reals_fft_2 ecx, 64
	add	dl, 256/2/clm		;; Test inner loop counter
	jnc	b2b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	add	ah, 256/8
	jnc	b2b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b2b			;; Iterate if necessary

;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 16 data values

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 8			;; 16 iterations of 4 iters
b3a0:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b3a:	x2cl_four_complex_fft ecx, 64, 8*clmblkdst8
	xloop4	b3a, clmblkdst
	add	eax, 80000000h
	jnc	b3a0
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b3a0			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst8+16*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 32 iterations of 2
b3:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b3b:	x4cl_four_complex_fft ecx, 64, 8*clmblkdst8, 16*clmblkdst8
	xloop2	b3b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b3
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b3			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst8-24*clmblkdst8];; Restore src pointer
	end_timer 23

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 2			;; 8 iterations of 2 iters
b4a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b4b:	x4cl_eight_reals_fft_2 ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop2	b4b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b4a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b4a			;; Iterate if necessary

;; Do 768 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 192 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+2		;; 6 iterations of 8 iters of 2
b5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b5b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop2	b5b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b5a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	ecx, [ecx-7*8*clmblkdst8];; Restore source pointer
	end_timer 24

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b6b			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	b6b			;; Iterate if necessary

;; Do 864 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 216 macros each processing 32 data values

	lea	ecx, [ecx-4*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 27*256+2		;; 27 iterations of 2 iters of 2
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop2	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-2*2*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-28*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-448*blkdst]	;; Restore prefetching pointer
	end_timer 25

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-3583K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 888 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 222 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 56*256+1		;; 111 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-112*4*blkdst]	;; Restore dest pointer
	end_timer 26

;; Work on next 4 sets of 1792 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d3584K
	ELSE
d3584K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 64			;; 64 iterations
d1b:	x7cl_seven_reals_fft esi, 448*64, 64*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	al, 64			;; 64 iterations
d2b:	x1cl_half_eight_reals_fft_2 esi, 448*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations
d3a:	x2cl_four_complex_fft esi, 448*64, 64*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3a			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3a			;; Iterate if necessary

	lea	esi, [esi-64*64+128*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 64			;; 64 iterations
d3b:	x4cl_four_complex_fft esi, 448*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-192*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 448*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 6*256+16		;; 6 iterations of 16 iters
d5b:	x4cl_four_complex_fft esi, 448*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-7*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 448*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 27*256+4		;; 27 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 448*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-28*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 448*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*448*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 111			;; 111 iterations
d9b:	x4cl_four_complex_fft esi, 448*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*448*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Perform a 4M-element FFT.  This is done in two passes.  Pass 1
;; does 11 levels, pass 2 uses common code to perform the last 11 levels.

xfft4096K MACRO clmarg, jump_to_common
	LOCAL	b0b, b1a, b1b, b2a, b2b, b3a, b3b, b4a, b4b
	LOCAL	b5a, b5b, b6a, b6b, b7a, b7b, b8b, b9b
	LOCAL	c0b, c1b, c2a, c2b, c3b, c4a, c4b, c5a, c5b
	LOCAL	c6b, c7a, c7b, c8b, c9b
	LOCAL	d1b, d2b, d3b, d4b, d5b, d6b, d7b, d8b, d9b
	LOCAL	pass2, no_fft, yes_fft, fftdn

	set_big_FFT_constants clmarg

;; Call FFT code unless the FFT has already been started

	clear_timers
	cmp	DWORD PTR [esi-28][ebx], 0;; Test FFT-started flag
	jne	short pass2		;; Jump if FFT already started
	mov	norm_ptr1, 0		;; Set FFT-ing flag
	mov	edx, 512/clm*256	;; Load loop counter
	jmp	b0b			;; Do the pass 1 fft

;; Do the last 11 FFT levels
;;	do 1 pass2_11_levels_real and 511 pass2_11_levels_complex

pass2:	start_timer 0
	CALL_Y	xpass2_11_levels
	cmp	ffttype, 1		;; We're done if FFTing only
	je	gw_finish_fft_3
	end_timer 0

;; Do the inverse FFT

	start_timer 1
	subpd	xmm0, xmm0		;; Init SUMOUT
	movapd	XMM_SUMOUT, xmm0
	movlpd	xmm0, _MAXERR		;; Init maximum error
	movhpd	xmm0, _MAXERR
	movapd	XMM_MAXERR, xmm0
	mov	edx, norm_biglit_array	;; Addr of the big/little flags array
	mov	norm_ptr1, edx		;; Save ptr
	mov	edx, norm_col_mults	;; Addr of the column multipliers
	mov	norm_ptr2, edx		;; Save ptr
	mov	edx, 512/clm*256	;; Load loop counter

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	10K	12K	14K
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 16 data values

c0b:	start_timer 16
	mov	ecx, scratch_area	;; Get address of scratch area
c8b:	g2cl_eight_reals_unfft_2 esi, 64, blkdst, ecx, 64, clmblkdst
	add	al, 256/2/clm		;; Test loop counter
	jnc	c8b			;; Iterate if necessary

;; Do 1020 four_complex_unfft macros
;;	distance between fft data elements is 2K
;;	do 510 macros each processing 16 data values

	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	mov	edi, sincos1		;; Load sin/cos pointer
	mov	eax, 64*256+3		;; 255 iterations
c9b:	g2cl_four_complex_unfft esi, 64, blkdst, ecx, 64, clmblkdst
	add	dl, 256/2/clm		;; Test loop counter
	jnc	c9b			;; Iterate if necessary
;	xprefetcht1 [esi]
	lea	esi, [esi-2*clm*64+2*blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+2*clmblkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	c9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 4
	jnz	c9b			;; Iterate if necessary
	lea	esi, [esi-256*2*blkdst]	;; Restore source pointer
	lea	ecx, [ecx-64*clmblkdst8];; Restore dest pointer
	end_timer 16

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	4K	8K	12K
;;	2K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 8K
;;	do 4 macros each processing 32 data values

	start_timer 17
	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c6b:	x4cl_eight_reals_unfft_2 ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop2	c6b, clmblkdst

;; Do 1008 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 252 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 63			;; 63 iterations of 2 iters
c7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c7b:	x4cl_four_complex_unfft ecx, 64, 2*clmblkdst, 4*clmblkdst
	xloop2	c7b, clmblkdst
	lea	ecx, [ecx-2*clmblkdst+clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	c7a			;; Iterate if necessary
	lea	ecx, [ecx-64*clmblkdst8];; Restore source pointer
	end_timer 17

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	16K	32K	48K
;;	2K	...
;;	...
;;	14K
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 32K
;;	do 16 macros each processing 32 data values

	start_timer 18
	mov	al, 4			;; 4 iterations of 2
c4a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c4b:	x4cl_eight_reals_unfft_2 ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop2	c4b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	c4a			;; Iterate if necessary

;; Do 960 four_complex_unfft macros
;;	distance between fft data elements is 8K
;;	do 240 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst+4*clmblkdst8];; Next source pointer
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	eax, 15*256+4		;; 15 iterations of 4 iters of 2
c5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
c5b:	x4cl_four_complex_unfft ecx, 64, clmblkdst8, 2*clmblkdst8
	xloop2	c5b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-4*2*clmblkdst+4*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	c5a			;; Iterate if necessary
	lea	ecx, [ecx-16*4*clmblkdst8];; Restore source pointer
	end_timer 18

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	64K	128K	192K
;;	2K	...
;;	...
;;	62K
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...
;;
;; Do 128 eight_reals_unfft_2 macros
;; Do 128 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 128K
;;	do 64 macros each processing 32 data values
;;
;; Do 768 four_complex_unfft macros
;;	distance between fft data elements is 128K
;;	do 192 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	256K	512K	768K
;;	2K	...
;;	...
;;	254K
;;	1024K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	1024K	2048K	3072K
;;	2K	...
;;	...
;;	1022K
;;
;; Do 1024 eight_reals_last_unfft macros
;;	distance between fft data elements is 512K
;;	do 256 macros each processing 32 data values

	start_timer 19
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 4			;; 32 iterations

c2a:	xtouchlines 4			;; Preload TLBs

c2b:	x4cl_eight_reals_unfft_2 ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2
	jnc	c2b
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer

	lea	ecx, [ecx-2*64+16*clmblkdst8];; Next source pointer
	mov	ah, 3			;; 3 iterations
c3b:	x4cl_four_complex_unfft ecx, 64, 4*clmblkdst8, 8*clmblkdst8
	add	al, 256/2		;; Test loop counter
	jnc	c3b			;; Iterate if necessary
	lea	ecx, [ecx-2*64+16*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	ah, 1			;; Test middle loop counter
	jnz	c3b			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	lea	edi, [edi-3*XMM_SCD]	;; Restore sine/cosine pointer

	lea	ecx, [ecx-4*16*clmblkdst8];; Restore source pointer
c1b:	x4cl_eight_reals_last_unfft ecx, 64, 16*clmblkdst8, 32*clmblkdst8
	add	al, 256/2
	jnc	c1b
	lea	ecx, [ecx-2*64+4*clmblkdst8]
	add	ah, 256/2
	jnc	c1b
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	add	edx, 80000000h
	jnc	c1b

	IF clm GT 1
	lea	ecx, [ecx-4*4*clmblkdst8+2*64];; Next source pointer
	lea	esi, [esi-4*blkdst+128]	;; Next prefetch pointer
	add	dl, 256/clm		;; clm iterations
	jnc	c2b
	lea	ecx, [ecx-clm*2*64+clmblkdst];; Next source pointer
	lea	esi, [esi-clm*128+4*blkdst];; Next prefetch pointer
	ELSE
	lea	ecx, [ecx-4*4*clmblkdst8+clmblkdst];; Next source pointer
	ENDIF

	add	eax, 80000000h/8*2	;; Test loop counter
	jnc	c2a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8];; Next source pointer
	sub	al, 1			;; Test loop counter
	jnz	c2a			;; Iterate if necessary
	lea	esi, [esi-256*blkdst]	;; Restore prefetch pointer
	end_timer 19

;; Normalize these values

	start_timer 21
	push	esi
	mov	esi, scratch_area
	mov	eax, _NORMRTN		;; Addr of normalization routine
	call	eax
	sub	eax, eax
	pop	esi
	end_timer 21

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	jne	yes_fft			;; Do FFT code if flag is set

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 512
	jmp	no_fft			;; Skip FFT code if flag not set

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 512

;; Do FFT levels 1,2,3
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	1024K	2048K	3072K
;;	2K	...
;;	...
;;	1022K
;; On output the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K	...
;;	2048K	...
;;	...
;;
;; Do 1024 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 512K
;;	do 512 iterations each processing 16 data values

yes_fft:start_timer 22
	mov	ecx, scratch_area	;; Get address of scratch area
	lea	esi, [esi+256*blkdst]	;; Create prefetching pointer
	mov	eax, 32			;; 64 iterations of 4 iters
b1a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b1b:	x2cl_eight_reals_fft ecx, 64, 32*clmblkdst8
	xloop4	b1b, clmblkdst
	add	eax, 80000000h
	jnc	b1a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test loop counter
	jnz	b1a			;; Iterate if necessary
	lea	ecx, [ecx-32*clmblkdst8];; Restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; Values 0K-511K is real data, 512K-1023K is semi-real data, 1024K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	512K	1024K	1536K
;;	2K	...
;;	...
;;	510K	...
;;	2048K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;; Do 128 nop_two_two_complex_fft_2 macros
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	start_timer 23
	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 8			;; 32 iterations of 2 iters
b2a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b2b:	x4cl_eight_reals_fft_2 ecx, 64, 8*clmblkdst8, 16*clmblkdst8
	xloop2	b2b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b2a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b2a			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 128K
;;	do 128 macros each processing 32 data values

	lea	ecx, [ecx-8*clmblkdst8+32*clmblkdst8];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 8			;; 32 iterations of 2 iters
b3a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b3b:	x4cl_four_complex_fft ecx, 64, 8*clmblkdst8, 16*clmblkdst8
	xloop2	b3b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b3a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b3a			;; Iterate if necessary
	lea	ecx, [ecx-8*clmblkdst8-32*clmblkdst8];; Restore source pointer
	end_timer 23

;; Do FFT levels 6,7
;; Values 0K-127K is real data, 128K-255K is semi-real data, 256K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	128K	256K	384K
;;	2K	...
;;	...
;;	126K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft_2 macros
;; Do 64 two_two_complex_fft macros
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

	start_timer 24
	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 2			;; 8 iterations of 2 iters
b4a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b4b:	x4cl_eight_reals_fft_2 ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop2	b4b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b4a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test outer loop counter
	jnz	b4a			;; Iterate if necessary

;; Do 896 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 224 macros each processing 32 data values

	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+2		;; 7 iterations of 8 iters of 2
b5a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b5b:	x4cl_four_complex_fft ecx, 64, 2*clmblkdst8, 4*clmblkdst8
	xloop2	b5b, clmblkdst
	add	eax, 80000000h/4*2	;; 4 iterations
	jnc	b5a
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	ecx, [ecx-2*clmblkdst8+8*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b5a			;; Iterate if necessary
	lea	ecx, [ecx-8*8*clmblkdst8];; Restore source pointer
	end_timer 24

;; Do FFT levels 8,9
;; Values 0K-31K is real data, 32K-63K is semi-real data, 64K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	32K	64K	96K
;;	2K	...
;;	...
;;	30K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 two_two_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 2			;; 2 iterations of 2
b6a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b6b:	x4cl_eight_reals_fft_2 ecx, 64, 4*clmblkdst, clmblkdst8
	xloop2	b6b, clmblkdst
	sub	al, 1			;; Test outer loop counter
	jnz	b6a			;; Iterate if necessary

;; Do 992 four_complex_fft macros
;;	distance between fft data elements is 8K
;;	do 248 macros each processing 32 data values

	lea	ecx, [ecx-2*2*clmblkdst+2*clmblkdst8];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 31*256+2		;; 31 iterations of 2 iters of 2
b7a:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
b7b:	x4cl_four_complex_fft ecx, 64, 4*clmblkdst, clmblkdst8
	xloop2	b7b, clmblkdst
	sub	al, 1			;; Test middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-2*2*clmblkdst+2*clmblkdst8];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 2			;; Load middle loop counter
	jnz	b7a			;; Iterate if necessary
	lea	ecx, [ecx-32*2*clmblkdst8];; Restore source pointer
	lea	esi, [esi-512*blkdst]	;; Restore prefetch pointer
	end_timer 25

;; Do FFT levels 10,11
;; Values 0K-7K is real data, 8K-15K is semi-real data, 16K-4095K is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0K	8K	16K	24K
;;	2K	...
;;	...
;;	6K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	2K	4K	6K
;;	8K	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 2 macros each processing 32 data values

	start_timer 26
	mov	edi, sincos1		;; Load sin/cos pointer
b8b:	g4cl_eight_reals_fft_2 ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	b8b			;; Iterate if necessary

;; Do 1016 four_complex_fft macros
;;	distance between fft data elements is 2K
;;	do 254 macros each processing 32 data values

	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 64*256+1		;; 127 iterations
b9b:	g4cl_four_complex_fft ecx, 64, clmblkdst, 2*clmblkdst, esi, 64, blkdst, 2*blkdst
	add	al, 256/2		;; Test inner loop counter
	jnc	b9b			;; Iterate if necessary
	xprefetcht1 [esi-128+clm*128]
	xprefetcht1 [esi-128+clm*128+blkdst]
	xprefetcht1 [esi-128+clm*128+2*blkdst]
	xprefetcht1 [esi-128+clm*128+3*blkdst]
	IF clm NE 1
	add	dl, 256/clm
	jnc	b9b
	ENDIF
	lea	ecx, [ecx-2*clm*64+4*clmblkdst];; Next source pointer
	lea	esi, [esi-2*clm*64+4*blkdst];; Next dest pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1
	jnz	b9b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	ah, 1			;; Test outer loop counter
	mov	al, 2
	jnz	b9b			;; Iterate if necessary
	lea	esi, [esi-128*4*blkdst]	;; Restore source pointer
	end_timer 26

;; Work on next 4 sets of 2048 values

no_fft:	lea	esi, [esi+clm*128]	;; Next source pointer
	sub	edx, 256		;; Test loop counter
	jz	short fftdn		;; Jump if done looping
	cmp	norm_ptr1, 0		;; What was the loop start point?
	jne	c0b			;; Do inverse-FFT/norm/FFT iteration
	jmp	b0b			;; Do another FFT-only iteration
fftdn:	lea	esi, [esi-512*128]	;; Restore source pointer
	sub	ebx, ebx
	cmp	norm_ptr1, 0		;; What was the loop start point?
	je	pass2			;; FFT-only, go do pass 2
	end_timer 1

;; Split the carries into high and low carries (so they do not exceed
;; the desired number of bits per FFT word.

	start_timer 28
	CALL_X	gw_split_carries_3
	end_timer 28

;; Have we been given permission to start the FFT on the result?
;; If so, do so now while the data is in the L2 cache.

	cmp	_POSTFFT, 0		;; Test flag
	je	gw_finish_mult_3	;; Skip FFT code if flag not set

;; Do FFT levels 1,2,3

	IF jump_to_common EQ 1
	jmp	d4096K
	ELSE
d4096K:	start_timer 29
	mov	esi, carries		;; Load addr of carries (data to FFT)
	mov	eax, 256*256		;; 256 iterations
d1b:	x2cl_eight_reals_fft esi, 512*64, 256*64
	add	al, 256/2		;; Test loop counter
	jnc	d1b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	eax, 256		;; Test loop counter
	jnz	d1b			;; Iterate if necessary
	lea	esi, [esi-256*64]	;; Restore source pointer

;; Do FFT levels 4,5

	mov	edi, sincos4		;; Load sin/cos pointer
	mov	al, 64			;; 64 iterations
d2b:	x4cl_eight_reals_fft_2 esi, 512*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d2b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d2b			;; Iterate if necessary

	lea	esi, [esi-64*64+256*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 64			;; 64 iterations
d3b:	x4cl_four_complex_fft esi, 512*64, 64*64, 128*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d3b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d3b			;; Iterate if necessary
	lea	esi, [esi-64*64-256*64]	;; Restore source pointer

;; Do FFT levels 6,7

	mov	edi, sincos3		;; Load sin/cos pointer
	mov	al, 16			;; 16 iterations
d4b:	x4cl_eight_reals_fft_2 esi, 512*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d4b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d4b			;; Iterate if necessary

	lea	esi, [esi-16*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 7*256+16		;; 7 iterations of 16 iters
d5b:	x4cl_four_complex_fft esi, 512*64, 16*64, 32*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d5b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 16			;; Load middle loop counter
	jnz	d5b			;; Iterate if necessary
	lea	esi, [esi-8*64*64]	;; Restore source pointer

;; Do FFT levels 8,9

	mov	edi, sincos2		;; Load sin/cos pointer
	mov	al, 4			;; 4 iterations
d6b:	x4cl_eight_reals_fft_2 esi, 512*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d6b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d6b			;; Iterate if necessary

	lea	esi, [esi-4*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	eax, 31*256+4		;; 31 iterations of 4 iters
d7b:	x4cl_four_complex_fft esi, 512*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d7b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	sub	al, 1			;; Test middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	mov	al, 4			;; Load middle loop counter
	jnz	d7b			;; Iterate if necessary
	lea	esi, [esi-32*16*64]	;; Restore source pointer

;; Do FFT levels 10,11

	mov	edi, sincos1		;; Load sin/cos pointer
d8b:	x4cl_eight_reals_fft_2 esi, 512*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d8b			;; Iterate if necessary

	lea	esi, [esi-2*512*64+4*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 127			;; 127 iterations
d9b:	x4cl_four_complex_fft esi, 512*64, 64, 2*64
	add	al, 256/2		;; Test inner loop counter
	jnc	d9b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+4*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	jnz	d9b			;; Iterate if necessary
	end_timer 29

;; Now add in the FFT'ed carries, cleanup and return

	jmp	gw_finish_mult_3
	ENDIF
	ENDM


;; Macros that help in looping.  They are called right after a building block
;; macro.

;; This macro then loops 2*clm times. If prefetching, a prefetch is done
;; every 2 times the building block macro is called.
xloop1	MACRO	label2, incr
	IF clm EQ 1
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	ENDIF

	IF clm GE 2
	add	al, 256/2		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+128]
	add	dl, 256/clm
	jnc	label2
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	lea	esi, [esi-clm*128+blkdst];; Next prefetch pointer
	ENDIF
	ENDM

;; This macro then loops 2*clm times. If prefetching, two prefetches are done
;; every 2 times the building block macro is called.
xloop1prefetch2	MACRO label2, incr
	IF clm EQ 1
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	xprefetcht1 [esi+clm*128]
	xprefetcht1 [esi+clm*128+blkdst]
	lea	esi, [esi+2*blkdst]	;; Next prefetch pointer
	ENDIF

	IF clm GE 2
	add	al, 256/2		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	xprefetcht1 [esi+clm*128+blkdst]
	lea	esi, [esi+128]
	add	dl, 256/clm
	jnc	label2
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	lea	esi, [esi-clm*128+2*blkdst];; Next prefetch pointer
	ENDIF
	ENDM

;; This macro then loops 4*clm times. If prefetching, a prefetch is done
;; every 4 times the building block macro is called.
xloop2	MACRO	label2, incr
	IF clm EQ 1
	add	al, 256/2		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	add	ah, 256/2		;; Test middle loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	ENDIF

	IF clm EQ 2
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+128]
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	add	ah, 256/2		;; Test middle loop counter
	jnc	label2			;; Iterate if necessary
	lea	esi, [esi-clm*128+blkdst];; Next prefetch pointer
	ENDIF

	IF clm GE 4
	add	al, 256/2/2		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+128]
	add	dl, 256/(clm/2)
	jnc	label2
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	add	ah, 256/2		;; Test middle loop counter
	jnc	label2			;; Iterate if necessary
	lea	esi, [esi-clm*128+blkdst];; Next prefetch pointer
	ENDIF
	ENDM

;; This macro then loops 8*clm times. If prefetching, a prefetch is done
;; every 8 times the building block macro is called.
xloop4	MACRO	label2, incr
	IF clm EQ 1
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	add	dl, 256/4		;; Test outer loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	ENDIF

	IF clm EQ 2
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	add	dl, 256/2		;; Test middle loop counter
	jnc	label2			;; Iterate if necessary
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+128]
	add	ah, 256/2		;; Test outer loop counter
	jnc	label2			;; Iterate if necessary
	lea	esi, [esi-clm*128+blkdst];; Next prefetch pointer
	ENDIF

	IF clm EQ 4
	add	al, 256/2/clm		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*clm*64+incr];; Next source pointer
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+128]
	add	dl, 256/4		;; Test outer loop counter
	jnc	label2			;; Iterate if necessary
	lea	esi, [esi-clm*128+blkdst];; Next prefetch pointer
	ENDIF
	ENDM



xtouchlines MACRO num
	LOCAL	lab
	IF PREFETCHING NE 0
	IF num EQ 1
	xtouch	[esi+(clm-1)*128]	;; Preload TLB
	ENDIF
	IF num EQ 2
	xtouch	[esi+(clm-1)*128]	;; Preload TLB
	xtouch	[esi+(clm-1)*128+blkdst]
	ENDIF
	IF num EQ 3
	xtouch	[esi+(clm-1)*128]	;; Preload TLB
	xtouch	[esi+(clm-1)*128+blkdst]
	xtouch	[esi+(clm-1)*128+2*blkdst]
	ENDIF
	IF num GE 4
	mov	ah, num
lab:	xtouch	[esi+(clm-1)*128]	;; Preload TLB
	lea	esi, [esi+blkdst]
	sub	ah, 1
	jnz	short lab
	lea	esi, [esi-num*blkdst]
	ENDIF
	ENDIF
	ENDM

xloop1sp MACRO	label2, incr
	add	al, 256/2		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*64+incr]	;; Next source pointer
	xprefetcht1 [esi+clm*128]
	lea	esi, [esi+blkdst]	;; Next prefetch pointer
	ENDM

xloop1prefetch2sp MACRO label2, incr
	add	al, 256/2		;; Test inner loop counter
	jnc	label2			;; Iterate if necessary
	lea	ecx, [ecx-2*64+incr]	;; Next source pointer
	xprefetcht1 [esi+clm*128]
	xprefetcht1 [esi+clm*128+blkdst]
	lea	esi, [esi+2*blkdst]	;; Next prefetch pointer
	ENDM

copy_scratch_data_to_fft MACRO cachelines
	LOCAL	a0b
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	eax, cachelines/8	;; Load counter
a0b:	movapd	xmm0, [ecx]		;; Copy a cache line
	movapd	xmm1, [ecx+16]
	movapd	xmm2, [ecx+32]
	movapd	xmm3, [ecx+48]
	movapd	[esi], xmm0
	movapd	[esi+16], xmm1
	movapd	[esi+32], xmm2
	movapd	[esi+48], xmm3
	lea	ecx, [ecx+64]		;; Next source pointer
	lea	esi, [esi+64]		;; Next dest pointer
	add	dl, 256/2/clm		;; Test loop counter
	jnc	a0b			;; Iterate if necessary
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next dest pointer
	add	ah, 256/8
	jnc	a0b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test loop counter
	jnz	a0b			;; Iterate if necessary
	lea	esi, [esi-cachelines*blkdst]	;; Restore source pointer
	ENDM

copy_fft_data_to_scratch MACRO cachelines
	LOCAL	a0b
	mov	ecx, scratch_area	;; Get address of scratch area
	mov	eax, cachelines/8	;; Load counter
a0b:	movapd	xmm0, [esi][ebx]	;; Copy a cache line
	movapd	xmm1, [esi+16][ebx]
	movapd	xmm2, [esi+32][ebx]
	movapd	xmm3, [esi+48][ebx]
	movapd	[ecx], xmm0
	movapd	[ecx+16], xmm1
	movapd	[ecx+32], xmm2
	movapd	[ecx+48], xmm3
	lea	ecx, [ecx+64]		;; Next source pointer
	lea	esi, [esi+64]		;; Next dest pointer
	add	dl, 256/2/clm		;; Test loop counter
	jnc	a0b			;; Iterate if necessary
	lea	esi, [esi-2*clm*64+blkdst];; Next source pointer
	lea	ecx, [ecx-2*clm*64+clmblkdst];; Next dest pointer
	add	ah, 256/8
	jnc	a0b
	lea	ecx, [ecx-8*clmblkdst+clmblkdst8]
	sub	al, 1			;; Test loop counter
	jnz	a0b			;; Iterate if necessary
	lea	esi, [esi-cachelines*blkdst]	;; Restore source pointer
	ENDM
