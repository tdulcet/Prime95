; Copyright 1998-2000 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;

; ********************************************************
; ********************************************************
; ********************  FFT MACROS  **********************
; ********************************************************
; ********************************************************


fft160 MACRO type
	LOCAL	b1b, c1b

;; Do 32 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF	type NE 4
	mov	al, 32			;; V - 32 iterations
b1b:	disp five_reals_first_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-32*dist1+128]	;; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn256_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end160
	JMP_X	cmn256_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end160
	JMP_X	cmn256_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn256_4
	ENDIF

;; Do 32 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF	type EQ 4
end160:	lea	esi, [esi-160*dist1-128];; U - Load source pointer
c1b:	disp five_reals_last_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft192 MACRO type
	LOCAL	b1b, c1b, c2b

;; Do 32 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF	type NE 4
	mov	al, 32			;; V - 32 iterations
b1b:	disp six_reals_first_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 32*dist1
	IF	type EQ 1
	JMP_X	cmn256a_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end192
	JMP_X	cmn256a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end192
	JMP_X	cmn256a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn256a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 16 complex values into 32 real values.

;; Do 8 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 8*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end192:	lea	esi, [esi-192*dist1+32*dist1];; U - Load source pointer
c2b:	dispc two_two_complex_unfft_2, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 32 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	lea	esi, [esi-4*dist1-32*dist1-128];; U - Load source pointer
c1b:	disp six_reals_last_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft224 MACRO type
	LOCAL	b1b, c1b

;; Do 32 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF	type NE 4
	mov	al, 32			;; V - 32 iterations
b1b:	disp seven_reals_first_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-32*dist1+128]	;; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn256_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end224
	JMP_X	cmn256_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end224
	JMP_X	cmn256_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn256_4
	ENDIF

;; Do 32 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF	type EQ 4
end224:	lea	esi, [esi-224*dist1-128];; U - Load source pointer
c1b:	disp seven_reals_last_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft256 MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, c1b, c2a, c2b, c3b, c4b

;; Do 32 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF	type NE 4
	mov	al, 32			;; V - 32 iterations
b1b:	disp eight_reals_first_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 32*dist1
;;	IF	type EQ 1
;;	JMP_X	cmn256a_1		;; Fall through to cmn256a_1
;;	ENDIF
	IF	type EQ 2
	push	OFFSET end256
	JMP_X	cmn256a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end256
	JMP_X	cmn256a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn256a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 16 complex values into 32 real values.

;; Do 8 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 8*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end256:	lea	esi, [esi-256*dist1+32*dist1];; U - Load source pointer
c2a:	dispc two_two_complex_unfft_2, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	c2a			;;*V - Iterate if necessary

;; Do 32 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	lea	esi, [esi-4*dist1-32*dist1-128];; U - Load source pointer
c1b:	disp eight_reals_last_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF

;;
;; Common code to perform the rest of the FFT
;; Note - this first chunk is only done for fft192 and fft256
;;

cmn256a_&type:

;; Do nothing (FFT level 4)
;; This will turn these 32 real values into 16 complex values.

;; Do 8 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 8*dist1
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.

	IF	type NE 4
b2a:	disp two_two_complex_fft_2, 4*dist1, 8*dist1, 16*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1-32*dist1+128]
	ENDIF

;; This is the entry point for fft160 and fft224

cmn256_&type:

;; Do 4 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 4 * dist1
;;	do 4 iterations

	IF	type NE 4
b2b:	dispc eight_reals_fft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	b2b			;;*V - Iterate if necessary

;; Do 16/24 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 8 * dist1
;;	do 2/3 iterations of 8

	lea	esi, [esi-4*dist1+32*dist1][ecx];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 8
b3b:	dispc four_complex_fft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Do 16/20/24/28 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 2 * dist1
;;	do 8/10/12/14 iterations of 2

	mov	esi, _DESTARG		;; U - Reload source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	add	esi, 32*dist1		;; U - Load source pointer
	add	edi, SCD		;; V - Load sin/cos pointer
	mov	eax, count2		;; V - 8/10/12/14 iterations of 2
b4b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b4b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b4b			;; V - Iterate if necessary
	mov	esi, _DESTARG		;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft_2 macros (FFT level 7, 8)
;;	distance between fft data elements is dist1
;;	1 iterations

	IF	type EQ 1
	disp eight_reals_fft_2, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_2, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_2, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_2, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 3 four_complex_fft macros (FFT levels 7,8)
;;	distance between fft data elements is dist1
;;	do 3 iterations

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	edi, sincos3		;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations
	IF	type EQ 1
b6b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b6b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b6b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b6b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b6b			;; V - Iterate if necessary

;; Do 16/20/24/28 two_two_complex_fft macros (FFT level 8)
;;	distance between fft data elements is dist1

	mov	eax, count3		;; V - 16/20/24/28 iterations
	IF	type EQ 1
b5b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b5b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b5b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b5b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b5b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn256
	ENDIF
	IF	type EQ 3
	JMP_X	cmn256
	ENDIF

;; Do 4 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 4 * dist1
;;	do 4 iterations

	IF	type EQ 4
cmn256:	mov	esi, _DESTARG		;; U - Load source pointer
c2b:	disp eight_reals_unfft, 4*dist1, 8*dist1, 16*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 16/20/24/28 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 2 * dist1
;;	do 8/10/12/14 iterations of 2

	lea	esi, [esi-4*dist1+32*dist1];; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, count2		;; U - 8/10/12/14 iterations of 2
	add	edi, SCD		;; V - Load sin/cos pointer
c4b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c4b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c4b			;; V - Iterate if necessary

;; Do 16/24 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 8 * dist1
;;	do 2/3 iterations of 8

	mov	esi, _DESTARG		;; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	lea	esi, [esi+32*dist1+128][ecx];; U - Load source pointer
	mov	eax, count1		;; V - 2/3 iterations of 8
c3b:	dispc four_complex_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary
	retn				;; Return from common code
	ENDIF
	ENDM


fft256p MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, c1b, c2a, c2b, c3b, c4b

;; Do 32 four_complex_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	IF type NE 4
	mov	edi, plus1_premults	;; Address of the multipliers
	mov	al, 32			;; V - 32 iterations
b1b:	disp four_complex_first_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	JNZ_X	b1b			;; V - Iterate if necessary

;; Do 32 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 8 * dist1
;;	do 4 iterations of 8

	lea	esi, [esi-32*dist1+128]	;; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 8
b3b:	dispc four_complex_fft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Do 32 four_complex_fft macros (FFT levels 5,6)
;;	distance between fft data elements is 2 * dist1
;;	do 16 iterations of 2

	lea	esi, [esi-256*dist1-128];; U - Reload source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 16			;; V - 16 iterations of 2
b4b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b4b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	JNZ_X	b4b			;; V - Iterate if necessary
	lea	esi, [esi-256*dist1]	;; U - Load source pointer
	ENDIF

;; Do 32 two_two_complex_fft macros (FFT level 7)
;;	distance between fft data elements is dist1

	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 32			;; V - 32 iterations
	IF	type EQ 1
b5b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b5b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b5b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b5b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b5b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn256p
	ENDIF
	IF	type EQ 3
	JMP_X	cmn256p
	ENDIF

;; Do 32 four_complex_unfft macros (FFT levels 5,6)
;;	distance between fft data elements is 2 * dist1
;;	do 16 iterations of 2

	IF type EQ 4
cmn256p:lea	esi, [esi-256*dist1]	;; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 16			;; U - 16 iterations of 2
c4b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c4b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c4b			;; V - Iterate if necessary

;; Do 32 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 8 * dist1
;;	do 4 iterations of 8

	lea	esi, [esi-256*dist1+128];; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 8
c3b:	dispc four_complex_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary

;; Do 32 four_complex_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 32 * dist1
;;	do 32 iterations

	lea	esi, [esi-256*dist1-128];; U - Load source pointer
	mov	edi, plus1_premults	;; V - Address of the multipliers
c1b:	disp four_complex_last_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	add	al, 256/32		;; U - Test loop counter
	JNC_X	c1b			;; V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft320 MACRO type
	LOCAL	b1b, c1b

;; Do 64 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF	type NE 4
	mov	al, 64			;; V - 64 iterations
b1b:	disp five_reals_first_fft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-64*dist1+128]	;; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn512_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end320
	JMP_X	cmn512_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end320
	JMP_X	cmn512_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn512_4
	ENDIF

;; Do 64 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF	type EQ 4
end320:	lea	esi, [esi-320*dist1-128];; U - Load source pointer
c1b:	disp five_reals_last_unfft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/64		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft384 MACRO type
	LOCAL	b1b, c1b, c2b

;; Do 64 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF	type NE 4
	mov	al, 64			;; V - 64 iterations
b1b:	disp six_reals_first_fft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 64*dist1
	IF	type EQ 1
	JMP_X	cmn512a_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end384
	JMP_X	cmn512a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end384
	JMP_X	cmn512a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn512a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 32 complex values into 64 real values.

;; Do 16 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 16*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end384:	lea	esi, [esi-384*dist1+64*dist1];; U - Load source pointer
c2b:	dispc two_two_complex_unfft_2, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 64 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	lea	esi, [esi-8*dist1-64*dist1-128];; U - Load source pointer
c1b:	disp six_reals_last_unfft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/64		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft448 MACRO type
	LOCAL	b1b, c1b

;; Do 64 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF	type NE 4
	mov	al, 64			;; V - 64 iterations
b1b:	disp seven_reals_first_fft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-64*dist1+128]	;; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn512_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end448
	JMP_X	cmn512_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end448
	JMP_X	cmn512_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn512_4
	ENDIF

;; Do 64 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF	type EQ 4
end448:	lea	esi, [esi-448*dist1-128];; U - Load source pointer
c1b:	disp seven_reals_last_unfft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/64		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft512 MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c1b, c2a, c2b, c3b, c4b, c7b

;; Do 64 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF	type NE 4
	mov	al, 64			;; V - 64 iterations
b1b:	disp eight_reals_first_fft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 64*dist1
;;	IF	type EQ 1
;;	JMP_X	cmn512a_1		;; Fall through to cmn512a_1
;;	ENDIF
	IF	type EQ 2
	push	OFFSET end512
	JMP_X	cmn512a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end512
	JMP_X	cmn512a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn512a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 32 complex values into 64 real values.

;; Do 16 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 16*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end512:	lea	esi, [esi-512*dist1+64*dist1];; U - Load source pointer
c2a:	dispc two_two_complex_unfft_2, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c2a			;;*V - Iterate if necessary

;; Do 64 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	lea	esi, [esi-8*dist1-64*dist1-128];; U - Load source pointer
c1b:	disp eight_reals_last_unfft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/64		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF

;;
;; Common code to perform the rest of the FFT
;; Note - this first chunk is only done for fft384 and fft512
;;

cmn512a_&type:

;; Do nothing (FFT level 4)
;; This will turn these 64 real values into 32 complex values.

;; Do 16 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 16*dist1
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.

	IF	type NE 4
b2a:	disp two_two_complex_fft_2, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1-64*dist1+128]
	ENDIF

;; This is the entry point for fft320 and fft448

cmn512_&type:

;; Do 8 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 8 * dist1
;;	do 8 iterations

	IF	type NE 4
b2b:	dispc eight_reals_funny_fft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	b2b			;;*V - Iterate if necessary

;; Do 32/48 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 16 * dist1
;;	do 2/3 iterations of 16

	lea	esi, [esi-8*dist1+64*dist1][ecx];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 16
b3b:	dispc four_complex_fft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1+128*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Do nothing (FFT level 7)
;; This will turn these 8 real values into 4 complex values.

;; Do 4 two_complex_fft_2 operations (FFT level 7)
;; Distance between fft data elements is 4*dist1
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.

	mov	esi, _DESTARG		;; U - Reload source pointer
	add	esi, 16*dist1		;; U - Load source pointer
b7b:	disp two_two_complex_fft_2, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	b7b			;;*V - Iterate if necessary

;; Do 36/44/52/60 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 4 * dist1
;;	do 9/11/13/15 iterations of 4

	lea	esi, [esi-2*dist1+16*dist1+128];; U - Next source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, count2		;; V - 9/11/13/15 iterations of 4
b4b:	dispc four_complex_fft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	b4b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b4b			;; V - Iterate if necessary
	mov	esi, _DESTARG		;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft_3 macros (FFT level 7, 8, 9)
;;	distance between fft data elements is dist1
;;	1 iterations

	IF	type EQ 1
	disp eight_reals_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_3, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 39/47/55/63 four_complex_fft macros (FFT level 8,9)
;;	distance between fft data elements is dist1

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	edi, sincos3		;; U - Load sin/cos pointer
	mov	eax, count3		;; V - 39/47/55/63 iterations
	IF	type EQ 1
b5b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b5b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b5b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b5b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b5b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn512
	ENDIF
	IF	type EQ 3
	JMP_X	cmn512
	ENDIF

;; Do nothing (FFT level 7)
;; This will turn these 4 complex values into 8 real values.

;; Do 4 two_complex_unfft operations (FFT level 7)
;; Distance between fft data elements is 4*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
cmn512:	mov	esi, _DESTARG		;; U - Load source pointer
	add	esi, 16*dist1		;; U - Reload source pointer
c7b:	disp two_two_complex_unfft_2, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	c7b			;;*V - Iterate if necessary

;; Do 36/44/52/60 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 4 * dist1
;;	do 9/11/13/15 iterations of 4

	lea	esi, [esi-2*dist1+16*dist1+128];; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, count2		;; V - 9/11/13/15 iterations of 4
c4b:	dispc four_complex_unfft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	c4b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c4b			;; V - Iterate if necessary

;; Do 8 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 8 * dist1
;;	do 8 iterations

	mov	esi, _DESTARG		;; U - Load source pointer
c2b:	disp eight_reals_funny_unfft, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 32/48 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 16 * dist1
;;	do 2/3 iterations of 16

	lea	esi, [esi-8*dist1+64*dist1+128][ecx];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 16
c3b:	dispc four_complex_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-16*dist1+128*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary
	retn				;; Return from common code
	ENDIF
	ENDM


fft512p MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, b7b
	LOCAL	c1b, c2a, c2b, c3b, c4b, c7b

;; Do 64 four_complex_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	IF type NE 4
	mov	edi, plus1_premults	;; Address of the multipliers
	mov	al, 64			;; V - 64 iterations
b1b:	disp four_complex_first_fft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	JNZ_X	b1b			;; V - Iterate if necessary

;; Do 64 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 16 * dist1
;;	do 4 iterations of 16

	lea	esi, [esi-64*dist1+128]	;; U - Next source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 16
b3b:	dispc four_complex_fft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1+128*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Do 64 four_complex_fft macros (FFT levels 5,6)
;;	distance between fft data elements is 4 * dist1
;;	do 16 iterations of 4

	lea	esi, [esi-512*dist1]	;; U - Next source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 16			;; V - 16 iterations of 4
b4b:	dispc four_complex_fft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	b4b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	JNZ_X	b4b			;; V - Iterate if necessary
	lea	esi, [esi-512*dist1-128];; U - Load source pointer
	ENDIF

;; Do 64 four_complex_fft macros (FFT level 7,8)
;;	distance between fft data elements is dist1

	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 64			;; V - 64 iterations
	IF	type EQ 1
b5b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b5b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b5b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b5b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b5b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn512p
	ENDIF
	IF	type EQ 3
	JMP_X	cmn512p
	ENDIF

;; Do 64 four_complex_unfft macros (FFT levels 5,6)
;;	distance between fft data elements is 4 * dist1
;;	do 16 iterations of 4

	IF type EQ 4
cmn512p:lea	esi, [esi-512*dist1+128];; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 16			;; V - 16 iterations of 4
c4b:	dispc four_complex_unfft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	c4b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	JNZ_X	c4b			;; V - Iterate if necessary

;; Do 64 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 16 * dist1
;;	do 4 iterations of 16

	lea	esi, [esi-512*dist1]	;; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 16
c3b:	dispc four_complex_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-16*dist1+128*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary

;; Do 64 four_complex_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 64 * dist1
;;	do 64 iterations

	lea	esi, [esi-512*dist1-128];; U - Load source pointer
	mov	edi, plus1_premults	;; V - Address of the multipliers
c1b:	disp four_complex_last_unfft, 64*dist1, 128*dist1, 256*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	add	al, 256/64		;; U - Test loop counter
	JNC_X	c1b			;; V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft640 MACRO type
	LOCAL	b1b, c1b

;; Do 128 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF	type NE 4
	mov	al, 128			;; V - 128 iterations
b1b:	disp five_reals_first_fft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-128*dist1+128];; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn1024_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end640
	JMP_X	cmn1024_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end640
	JMP_X	cmn1024_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn1024_4
	ENDIF

;; Do 128 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF	type EQ 4
end640:	lea	esi, [esi-640*dist1]	;; U - Load source pointer
c1b:	disp five_reals_last_unfft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/128		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft768 MACRO type
	LOCAL	b1b, c1b, c2b

;; Do 128 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF	type NE 4
	mov	al, 128			;; V - 128 iterations
b1b:	disp six_reals_first_fft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 128*dist1
	IF	type EQ 1
	JMP_X	cmn1024a_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end768
	JMP_X	cmn1024a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end768
	JMP_X	cmn1024a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn1024a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 64 complex values into 128 real values.

;; Do 32 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 32*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end768:	lea	esi, [esi-768*dist1+128*dist1+128];; U - Load source pointer
c2b:	dispc two_two_complex_unfft_2, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 128 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	lea	esi, [esi-16*dist1-128*dist1-128];; U - Load source pointer
c1b:	disp six_reals_last_unfft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/128		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft896 MACRO type
	LOCAL	b1b, c1b

;; Do 128 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF	type NE 4
	mov	al, 128			;; V - 128 iterations
b1b:	disp seven_reals_first_fft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-128*dist1+128];; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn1024_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end896
	JMP_X	cmn1024_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end896
	JMP_X	cmn1024_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn1024_4
	ENDIF

;; Do 128 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF	type EQ 4
end896:	lea	esi, [esi-896*dist1]	;; U - Load source pointer
c1b:	disp seven_reals_last_unfft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/128		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft1024 MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	c1b, c2a, c2b, c3b, c4b, c7b, c8b, c9b

;; Do 128 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF	type NE 4
	mov	al, 128			;; V - 128 iterations
b1b:	disp eight_reals_first_fft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 128*dist1
;;	IF	type EQ 1
;;	JMP_X	cmn1024a_1		;; Fall through to cmn1024a_1
;;	ENDIF
	IF	type EQ 2
	push	OFFSET end1024
	JMP_X	cmn1024a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end1024
	JMP_X	cmn1024a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn1024a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 64 complex values into 128 real values.

;; Do 32 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 32*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end1024:lea	esi, [esi-1024*dist1+128*dist1+128];; U - Load source pointer
c2a:	dispc two_two_complex_unfft_2, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c2a			;;*V - Iterate if necessary

;; Do 128 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	lea	esi, [esi-16*dist1-128*dist1-128];; U - Load source pointer
c1b:	disp eight_reals_last_unfft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/128		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF

;;
;; Common code to perform the rest of the FFT
;; Note - this first chunk is only done for fft768 and fft1024
;;

cmn1024a_&type:

;; Do nothing (FFT level 4)
;; This will turn these 128 real values into 64 complex values.

;; Do 32 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 32*dist1
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.

	IF	type NE 4
b2a:	disp two_two_complex_fft_2, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1-128*dist1+128]
	ENDIF

;; This is the entry point for fft640 and fft896

cmn1024_&type:

;; Do 16 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type NE 4
b2b:	dispc eight_reals_funny_fft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	b2b			;;*V - Iterate if necessary

;; Do 64/96 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 32 * dist1
;;	do 2/3 iterations of 32

	lea	esi, [esi-16*dist1+128*dist1-128][ecx];; U - Load source ptr
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 32
b3b:	disp four_complex_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-32*dist1+256*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Do nothing (FFT level 7)
;; This will turn these 16 real values into 8 complex values.

;; Do 8 two_complex_fft_2 operations (FFT level 7)
;; Distance between fft data elements is 8*dist1
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.

	mov	esi, _DESTARG		;; U - Reload source pointer
	add	esi, 32*dist1+128	;;*U - Load source pointer
b7b:	dispc two_two_complex_fft_2, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	b7b			;;*V - Iterate if necessary

;; Do 72/88/104/120 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is 8 * dist1
;;	do 9/11/13/15 iterations of 8

	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, count2		;; V - 9/11/13/15 iterations of 8
b4b:	dispc four_complex_fft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	b4b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b4b			;; V - Iterate if necessary

;; Do 2 eight_reals_fft macros (FFT level 7, 8, 9)
;;	distance between fft data elements is 2*dist1
;;	2 iterations

	mov	esi, _DESTARG		;; U - Load source pointer
b8b:	disp eight_reals_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	b8b			;;*V - Iterate if necessary

;; Do 78/94/110/126 four_complex_fft macros (FFT level 8,9)
;;	distance between fft data elements is 2*dist1
;;	Do 39/47/55/63 iterations of 2

	lea	esi, [esi-2*dist1+16*dist1];; U - Load source pointer
	mov	edi, sincos3		;; U - Load sin/cos pointer
	mov	eax, count3		;; V - 39/47/55/63 iterations of 2
b9b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b9b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b9b			;; V - Iterate if necessary
	mov	esi, _DESTARG		;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 10)
;;	distance between fft data elements is dist1
;;	1 iterations

	IF	type EQ 1
	disp eight_reals_fft_1, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_1, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_1, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_1, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 79/95/111/127 two_two_complex_fft macros (FFT level 10)
;;	distance between fft data elements is dist1

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	eax, count4		;; V - 79/95/111/127 iterations
	mov	edi, sincos4		;; U - Load sin/cos pointer
	IF	type EQ 1
b5b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b5b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b5b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b5b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b5b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn1024
	ENDIF
	IF	type EQ 3
	JMP_X	cmn1024
	ENDIF

;; Do 2 eight_reals_unfft macros (FFT level 7, 8, 9)
;;	distance between fft data elements is 2*dist1
;;	2 iterations

	IF	type EQ 4
cmn1024:mov	esi, _DESTARG		;; U - Load source pointer
c8b:	disp eight_reals_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	c8b			;;*V - Iterate if necessary

;; Do 78/94/110/126 four_complex_unfft macros (FFT level 8,9)
;;	distance between fft data elements is 2*dist1
;;	Do 39/47/55/63 iterations of 2

	lea	esi, [esi-2*dist1+16*dist1];; U - Load source pointer
	mov	edi, sincos3		;; U - Load sin/cos pointer
	mov	eax, count3		;; V - 39/47/55/63 iterations of 2
c9b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c9b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c9b			;; V - Iterate if necessary

;; Do nothing (FFT level 7)
;; This will turn these 8 complex values into 16 real values.

;; Do 8 two_complex_unfft operations (FFT level 7)
;; Distance between fft data elements is 8*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	mov	esi, _DESTARG		;; U - Load source pointer
	add	esi, 32*dist1+128	;; U - Reload source pointer
c7b:	dispc two_two_complex_unfft_2, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	c7b			;;*V - Iterate if necessary

;; Do 72/88/104/120 four_complex_unfft macros (FFT levels 6,7)
;;	distance between fft data elements is 8 * dist1
;;	do 9/11/13/15 iterations of 8

	lea	esi, [esi-4*dist1+32*dist1];; U - Load source pointer
	mov	edi, sincos2		;; V - Load sin/cos pointer
	mov	eax, count2		;; V - 9/11/13/15 iterations of 8
c4b:	dispc four_complex_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	c4b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c4b			;; V - Iterate if necessary

;; Do 16 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 16 * dist1
;;	do 16 iterations

	mov	esi, _DESTARG		;; U - Load source pointer
c2b:	disp eight_reals_funny_unfft, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 64/96 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 32 * dist1
;;	do 2/3 iterations of 32

	lea	esi, [esi-16*dist1+128*dist1][ecx];; U - Load source pointer
	mov	edi, sincos1		;; V - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 32
c3b:	disp four_complex_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-32*dist1+256*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary
	retn				;; Return from common code
	ENDIF
	ENDM


fft1024p MACRO type
	LOCAL	b1b, b3b, b4b, b5b, b9b, c1b, c3b, c4b, c9b

;; Do 128 four_complex_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	IF type NE 4
	mov	edi, plus1_premults	;; Address of the multipliers
	mov	al, 128			;; V - 128 iterations
b1b:	disp four_complex_first_fft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	JNZ_X	b1b			;; V - Iterate if necessary

;; Do 128 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 32 * dist1
;;	do 4 iterations of 32

	lea	esi, [esi-128*dist1]	;; U - Next source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 32
b3b:	disp four_complex_fft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-32*dist1+256*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Do 128 four_complex_fft macros (FFT levels 5,6)
;;	distance between fft data elements is 8 * dist1
;;	do 16 iterations of 8

	lea	esi, [esi-1024*dist1+128];; U - Next source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 16			;; V - 16 iterations of 8
b4b:	dispc four_complex_fft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	b4b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b4b			;; V - Iterate if necessary

;; Do 128 four_complex_fft macros (FFT level 7,8)
;;	distance between fft data elements is 2*dist1
;;	Do 64 iterations of 2

	lea	esi, [esi-1024*dist1-128];; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 64			;; V - 64 iterations of 2
b9b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b9b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	JNZ_X	b9b			;; V - Iterate if necessary
	lea	esi, [esi-1024*dist1]	;; U - Load source pointer
	ENDIF

;; Do 128 two_two_complex_fft macros (FFT level 9)
;;	distance between fft data elements is dist1

	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 128			;; V - 128 iterations
	IF	type EQ 1
b5b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b5b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b5b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b5b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b5b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn1024p
	ENDIF
	IF	type EQ 3
	JMP_X	cmn1024p
	ENDIF

;; Do 128 four_complex_unfft macros (FFT level 7,8)
;;	distance between fft data elements is 2*dist1
;;	Do 64 iterations of 2

	IF type EQ 4
cmn1024p:lea	esi, [esi-1024*dist1]	;; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 64			;; V - 64 iterations of 2
c9b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c9b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c9b			;; V - Iterate if necessary

;; Do 128 four_complex_unfft macros (FFT levels 5,6)
;;	distance between fft data elements is 8 * dist1
;;	do 16 iterations of 8

	lea	esi, [esi-1024*dist1+128];; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 16			;; V - 16 iterations of 8
c4b:	dispc four_complex_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test inner loop counter
	JNC_X	c4b			;;*V - Iterate if necessary
	lea	esi, [esi-8*dist1+64*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c4b			;; V - Iterate if necessary

;; Do 128 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 32 * dist1
;;	do 4 iterations of 32

	lea	esi, [esi-1024*dist1-128];; U - Load source pointer
	mov	edi, sincos_complex	;; V - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 32
c3b:	disp four_complex_unfft, 32*dist1, 64*dist1, 128*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/32		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-32*dist1+256*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary

;; Do 128 four_complex_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 128 * dist1
;;	do 128 iterations

	lea	esi, [esi-1024*dist1]	;; U - Load source pointer
	mov	edi, plus1_premults	;; V - Address of the multipliers
c1b:	disp four_complex_last_unfft, 128*dist1, 256*dist1, 512*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	add	al, 256/128		;; U - Test loop counter
	JNC_X	c1b			;; V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM
