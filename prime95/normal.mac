; Copyright 1995-2000 - Just For Fun Software, Inc.
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros efficiently implement the normalization to integers
; and multiplication by two-to-phi powers.
;

; *************** simple normalize macro ******************
; This macro "normalizes" eight FFT data values.  This involves
; multiplying the data value by two-to-minus-phi.  Rounding the
; value to an integer.  Making sure the integer is smaller than
; the maximum allowable integer, generating a carry if necessary.
; Finally, the value is multiplied by two-to-phi and stored.
; st(1) = sumout
; st(0) = carry
; esi = pointer to the FFT data values
; ebx = pointer two-to-power multipliers
; ebp = number of big words
; edi = big vs. little running sum
; eax = this big vs. little word flag
; A pipelined version of this code:
;	fld	QWORD PTR [esi+0*8]	;; Load value
;	fmul	QWORD PTR [ebx+0*16+8]	;; Mul value by two-to-minus-phi
;	faddp	st(4), st		;; x = value + carry
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fadd	st, st(4)		;; y = top bits of x
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y
;	fsubp	st(6), st		;; rounded value = x - z
;	fadd	QWORD PTR [esi+0*8]	;; sumout += value
;	fmulp	QWORD PTR [ebx+0*16]	;; new value = val * two-to-phi
;	sub	edi, ebp		;; U - 2 steps to compute
;	sbb	eax, eax		;;*U - next big vs. little flag
;	fstp	QWORD PTR [esi+0*8]	;; Save the previous value

simple_normalize MACRO
	fld	QWORD PTR [esi+0*8]	;; Load value		;v0,c0,s
	fmul	QWORD PTR [ebx+0*16+8]	;; Mul value by two-to-minus-phi
	sub	edi, ebp		;;*U - 2 steps to compute
	 fld	QWORD PTR [esi+1*8]	;; Load value		;v1,v0,c0,s
	 fxch	st(1)						;v0,v1,c0,s
	faddp	st(2), st		;; x = value + carry	;v1,x0,s
	 fmul	QWORD PTR [ebx+1*16+8]	;; Mul value by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const	;y0,v1,x0,s
	fadd	st, st(2)		;; y = top bits of x
	fxch	st(3)						;s,v1,x0,y0
	fadd	QWORD PTR [esi+0*8]	;; sumout += value
	fld	limit_bigmax[eax*8]	;; z = rounding const	;z0,s,v1,x0,y0
	fsubr	st, st(4)		;; z = y - z
	fxch	st(4)						;y0,s,v1,x0,z0
	fmul	limit_inverse[eax*8]	;; next carry = shift y	;c1,s,v1,x0,z0
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	edi, ebp		;; V - 2 steps to compute
	  fld	QWORD PTR [esi+2*8]	;; Load value	;v2,c1,s,v1,x0,z0
	  fxch	st(5)					;z0,c1,s,v1,x0,v2
	fsubp	st(4), st		;; new value = x - z	;c1,s,v1,v0,v2
	 faddp	st(2), st		;; x = value + carry	;s,x1,v0,v2
	 fld	limit_bigmax[eax*8]	;; y = rounding const	;y1,s,x1,v0,v2
	 fxch	st(3)						;v0,s,x1,y1,v2
	fmul	QWORD PTR [ebx+0*16]	;; new value = val * two-to-phi
	fxch	st(3)						;y1,s,x1,v0,v2
	 fadd	st, st(2)		;; y = top bits of x
	 fxch	st(1)						;s,y1,x1,v0,v2
	 fadd	QWORD PTR [esi+1*8]	;; sumout += value
	 fxch	st(4)						;v2,y1,x1,v0,s
	  fmul	QWORD PTR [ebx+2*16+8]	;; Mul value by two-to-minus-phi
	 fld	limit_bigmax[eax*8]	;; z = rounding const ;z1,v2,y1,x1,v0,s
	 fsubr	st, st(2)		;; z = y - z
	 fxch	st(2)					      ;y1,v2,z1,x1,v0,s
	 fmul	limit_inverse[eax*8]	;; carry = shift y    ;c2,v2,z1,x1,v0,s
	 fxch	st(4)					      ;v0,v2,z1,x1,c2,s
	fstp	QWORD PTR [esi+0*8]	;; Save the value	;v2,z1,x1,c2,s
	 sbb	eax, eax		;; U - next big vs. little flag
	  sub	edi, ebp		;; V - 2 steps to compute
	fld	QWORD PTR [esi+3*8]	;; Load value	      ;v3,v2,z1,x1,c2,s
	fxch	st(2)					      ;z1,v2,v3,x1,c2,s
	 fsubp	st(3), st		;; new value = x - z	;v2,v3,v1,c2,s
	  faddp	st(3), st		;; x = value + carry	;v3,v1,x2,s
	  fld	limit_bigmax[eax*8]	;; y = rounding const	;y2,v3,v1,x2,s
	  fxch	st(2)						;v1,v3,y2,x2,s
	 fmul	QWORD PTR [ebx+1*16]	;; new value = val * two-to-phi
	 fxch	st(2)						;y2,v3,v1,x2,s
	  fadd	st, st(3)		;; y = top bits of x
	  fxch	st(4)						;s,v3,v1,x2,y2
	  fadd	QWORD PTR [esi+2*8]	;; sumout += value
	  fxch	st(1)						;v3,s,v1,x2,y2
	fmul	QWORD PTR [ebx+3*16+8]	;; Mul value by two-to-minus-phi
	  fld	limit_bigmax[eax*8]	;; z = rounding const ;z2,v3,s,v1,x2,y2
	  fsubr	st, st(5)		;; z = y - z
	  fxch	st(5)					      ;y2,v3,s,v1,x2,z2
	  fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c3,v3,s,v1,x2,z2
	  fxch	st(3)					      ;v1,v3,s,c3,x2,z2
	 fstp	QWORD PTR [esi+1*8]	;; Save the value	;v3,s,c3,x2,z2
	  sbb	eax, eax		;; U - next big vs. little flag
	sub	edi, ebp		;; V - 2 steps to compute
	 fld	QWORD PTR [esi+4*8]	;; Load value	      ;v4,v3,s,c3,x2,z2
	 fxch	st(5)					      ;z2,v3,s,c3,x2,v4
	  fsubp	st(4), st		;; value = x - z	;v3,s,c3,v2,v4
	faddp	st(2), st		;; x = value + carry	;s,x3,v2,v4
	fld	limit_bigmax[eax*8]	;; y = rounding const	;y3,s,x3,v2,v4
	fxch	st(3)						;v2,s,x3,y3,v4
	  fmul	QWORD PTR [ebx+2*16]	;; new value = val * two-to-phi
	  fxch	st(3)						;y3,s,x3,v2,v4
	fadd	st, st(2)		;; y = top bits of x
	fxch	st(1)						;s,y3,x3,v2,v4
	fadd	QWORD PTR [esi+3*8]	;; sumout += value
	fxch	st(4)						;v4,y3,x3,v2,s
	 fmul	QWORD PTR [ebx+4*16+8]	;; Mul value by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z = rounding const ;z3,v4,y3,x3,v2,s
	fsubr	st, st(2)		;; z = y - z
	fxch	st(2)					      ;y3,v4,z3,x3,v2,s
	fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c4,v4,z3,x3,v2,s
	fxch	st(4)					      ;v2,v4,z3,x3,c4,s
	  fstp	QWORD PTR [esi+2*8]	;; Save previous value	;v4,z3,x3,c4,s
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	edi, ebp		;; V - 2 steps to compute
	  fld	QWORD PTR [esi+5*8]	;; Load value	      ;v5,v4,z3,x3,c4,s
	  fxch	st(2)					      ;z3,v4,v5,x3,c4,s
	fsubp	st(3), st		;; value = x - z	;v4,v5,v3,c4,s
	 faddp	st(3), st		;; x = value + carry	;v5,v3,x4,s
	 fld	limit_bigmax[eax*8]	;; y = rounding const	;y4,v5,v3,x4,s
	 fxch	st(2)						;v3,v5,y4,x4,s
	fmul	QWORD PTR [ebx+3*16]	;; new value = val * two-to-phi
	fxch	st(2)						;y4,v5,v3,x4,s
	 fadd	st, st(3)		;; y = top bits of x
	 fxch	st(4)						;s,v5,v3,x4,y4
	 fadd	QWORD PTR [esi+4*8]	;; sumout += value
	 fxch	st(1)						;v5,s,v3,x4,y4
	  fmul	QWORD PTR [ebx+5*16+8]	;; Mul value by two-to-minus-phi
	 fld	limit_bigmax[eax*8]	;; z = rounding const ;z4,v5,s,v3,x4,y4
	 fsubr	st, st(5)		;; z = y - z
	 fxch	st(5)					      ;y4,v5,s,v3,x4,z4
	 fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c5,v5,s,v3,x4,z4
	 fxch	st(3)					      ;v3,v5,s,c5,x4,z4
	fstp	QWORD PTR [esi+3*8]	;; Save previous value	;v5,s,c5,x4,z4
	 sbb	eax, eax		;; U - next big vs. little flag
	  sub	edi, ebp		;; V - 2 steps to compute
	fld	QWORD PTR [esi+6*8]	;; Load value	      ;v6,v5,s,c5,x4,z4
	fxch	st(5)					      ;z4,v5,s,c5,x4,v6
	 fsubp	st(4), st		;; value = x - z	;v5,s,c5,v4,v6
	  faddp	st(2), st		;; x = value + carry	;s,x5,v4,v6
	  fld	limit_bigmax[eax*8]	;; y = rounding const	;y5,s,x5,v4,v6
	  fxch	st(3)						;v4,s,x5,y5,v6
	 fmul	QWORD PTR [ebx+4*16]	;; new value = val * two-to-phi
	 fxch	st(3)						;y5,s,x5,v4,v6
	  fadd	st, st(2)		;; y = top bits of x
	  fxch	st(1)						;s,y5,x5,v4,v6
	  fadd	QWORD PTR [esi+5*8]	;; sumout += value
	  fxch	st(4)						;v6,y5,x5,v4,s
	fmul	QWORD PTR [ebx+6*16+8]	;; Mul value by two-to-minus-phi
	  fld	limit_bigmax[eax*8]	;; z = rounding const ;z5,v6,y5,x5,v4,s
	  fsubr	st, st(2)		;; z = y - z
	  fxch	st(2)					      ;y5,v6,z5,x5,v4,s
	  fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c6,v6,z5,x5,v4,s
	  fxch	st(4)					      ;v4,v6,z5,x5,c6,s
	 fstp	QWORD PTR [esi+4*8]	;; Save previous value	;v6,z5,x5,c6,s
	  sbb	eax, eax		;; U - next big vs. little flag
	sub	edi, ebp		;; V - 2 steps to compute
	 fld	QWORD PTR [esi+7*8]	;; Load value	      ;v7,v6,z5,x5,c6,s
	 fxch	st(2)					      ;z5,v6,v7,x5,c6,s
	  fsubp	st(3), st		;; value = x - z	;v6,v7,v5,c6,s
	faddp	st(3), st		;; x = value + carry	;v7,v5,x6,s
	fld	limit_bigmax[eax*8]	;; y = rounding const	;y6,v7,v5,x6,s
	fxch	st(2)						;v5,v7,y6,x6,s
	  fmul	QWORD PTR [ebx+5*16]	;; new value = val * two-to-phi
	  fxch	st(2)						;y6,v7,v5,x6,s
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(4)						;s,v7,v5,x6,y6
	fadd	QWORD PTR [esi+6*8]	;; sumout += value
	fxch	st(1)						;v7,s,v5,x6,y6
	 fmul	QWORD PTR [ebx+7*16+8]	;; Mul value by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z = rounding const ;z6,v7,s,v5,x6,y6
	fsubr	st, st(5)		;; z = y - z
	fxch	st(5)					      ;y6,v7,s,v5,x6,z6
	fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c7,v7,s,v5,x6,z6
	fxch	st(3)					      ;v5,v7,s,c7,x6,z6
	  fstp	QWORD PTR [esi+5*8]	;; Save previous value	;v7,s,c7,x6,z6
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	edi, ebp		;; V - 2 steps to compute
	 faddp	st(2), st		;; x = value + carry	;s,x7,x6,z6
	 fxch	st(2)						;x6,x7,s,z6
	fsubrp	st(3), st		;; value = x - z	;x7,s,v6
	 fld	limit_bigmax[eax*8]	;; y = rounding const	;y7,x7,s,v6
	 fadd	st, st(1)		;; y = top bits of x
	 fxch	st(3)						;v6,x7,s,y7
	fmul	QWORD PTR [ebx+6*16]	;; new value = val * two-to-phi
	 fld	limit_bigmax[eax*8]	;; z = rounding const	;z7,v6,x7,s,y7
	 fsubr	st, st(4)		;; z = y - z
	 fxch	st(4)						;y7,v6,x7,s,z7
	 fmul	limit_inverse[eax*8]	;; carry = shifted y	;c,v6,x7,s,z7
	 fxch	st(3)						;s,v6,x7,c,z7
	 fadd	QWORD PTR [esi+7*8]	;; sumout += value
	 fxch	st(4)						;z7,v6,x7,c,s
	 fsubp	st(2), st		;; value = x - z	;v6,v7,c,s
	fstp	QWORD PTR [esi+6*8]	;; Save previous value	;v7,c,s
	 fmul	QWORD PTR [ebx+7*16]	;; new value = val * two-to-phi
	 sbb	eax, eax		;;*U - next big vs. little flag
					;; STALL
					;; STALL
	 fstp	QWORD PTR [esi+7*8]	;; Save previous value	;c,s
	ENDM


; *************** simple normalize macro ******************
; This macro finisishes the normalize process by adding the final
; carry from the first pass back into the lower two data values.
; We take advantage of the fact that the first two-to-phi multiplier
; and the first two-to-minus-phi multiplier are one.  We also know
; the first data value is a big word (eax would be -1).
; st(0) = carry
; esi = pointer to the FFT data values
; ebx = pointer two-to-power multipliers

simple_normalize_012 MACRO
	fadd	QWORD PTR [esi]		;; x = value + carry	;x0
	fld	limit_bigmax_high	;; y = rounding const	;y0,x0
	fadd	st, st(1)		;; y = top bits of x
	fld	limit_inverse_high	;; Load carry shifter	;c1,y0,x0
	fmul	st, st(1)		;; carry = shifted y
	fxch	st(1)						;y0,c1,x0
	fsub	limit_bigmax_high	;; y = y - (maximum * BIGVAL - BIGVAL)
	fsubp	st(2), st		;; value = x - y	;c1,x0
	 fsub	BIGVAL			;; carry -= round off const
	 fmul	QWORD PTR [ebx+1*16]	;; carry = carry * two-to-phi
	 fadd	QWORD PTR [esi+dist1]	;; new value = value + carry
	 fstp	QWORD PTR [esi+dist1]	;; Save the value
	fstp	QWORD PTR [esi]		;; Save the value
	ENDM


; *************** normalize macro ******************
; This macro "normalizes" eight FFT data values.  This involves
; multiplying the data value by two-to-minus-phi.  Rounding the
; value to an integer.  Making sure the integer is smaller than
; the maximum allowable integer, generating a carry if necessary.
; Finally, the value is multiplied by two-to-phi and stored.
; st(5) = sumout
; st(4) = carry
; st(3) = two-to-phi multiplier
; st(2) = two-to-minus-phi group multiplier
; st(1) = two-to-phi group multiplier
; st(0) = two-to-minus-phi multiplier
; esi = pointer to the FFT data values
; ebx = pointer two-to-power column multipliers
; edx = pointer two-to-power group multipliers
; ebp = number of big words
; edi = big vs. little running sum
; eax = the big vs. little word flag

normalize MACRO				;; ttmp,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi]		;; Mul value by two-to-minus-phi
					;; STALL
					;; STALL
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx]		;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi]		;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi]		;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+16]	;; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+24]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi+2*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,ttmpg,ttp,carry,sum
	  fstp	QWORD PTR [esi+dist1]	;; Save the previous value
	  				;; val,ttpg,ttmpg,ttp,carry,sum
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+32]	;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi+2*dist1]	;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+3*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi+2*dist1]	;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+32+16]	;; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+3*dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+32+24]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi+4*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,ttmpg,ttp,carry,sum
	  fstp	QWORD PTR [esi+3*dist1]	;; Save the previous value
	  				;; val,ttpg,ttmpg,ttp,carry,sum
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+2*32]	;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi+4*dist1]	;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+2*32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+5*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi+4*dist1]	;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+2*32+16];; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+5*dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+2*32+24];; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi+6*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,ttmpg,ttp,carry,sum
	  fstp	QWORD PTR [esi+5*dist1]	;; Save the previous value
	  				;; val,ttpg,ttmpg,ttp,carry,sum
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+3*32]	;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi+6*dist1]	;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+3*32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+7*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi+6*dist1]	;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+3*32+16];; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+7*dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+3*32+24];; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fxch	st(1)
	fstp	QWORD PTR [esi+7*dist1]
	ENDM


; *************** normalize macro ******************
; This macro finisishes the normalize process by adding the final
; carry from the first pass back into the lower three data value.
; We take advantage of the fact that the first two-to-phi multiplier
; and the first two-to-minus-phi multiplier are one.  We also know
; the first data value is a big word (eax would be -1).
; st(0) = carry
; esi = pointer to the FFT data values
; ebx = pointer two-to-power column multipliers
; ebp = number of big words
; edi = big vs. little running sum

normalize_012 MACRO
	fadd	QWORD PTR [esi]		;; x = value + carry
	  fld	limit_ttp_mult_high	;; Load next two-to-phi grp mult
	  fld	limit_bigmax_high	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x
	fadd	st, st(2)		;; y = top bits of x
	  fld	limit_ttmp_mult_high	;; Load nxt two-to-minus-phi grp mult
	  fld	limit_bigmax_high	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,y,ttpg,x
	fsubr	st, st(2)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(2)			;; y,ttmpg,z,ttpg,x
	  fmul	limit_inverse_high	;; next carry = shifted y
	  fld	QWORD PTR [ebx]		;; Load next two-to-phi
	  fxch	st(3)			;; z,carry,ttmpg,nxtttp,ttpg,x
	fsubp	st(5), st		;; rounded value = x - z
	  fxch	st(2)			;; nxtttp,ttmpg,carry,ttpg,val
	  fmul	st, st(3)		;; Compute next two-to-phi
	  fxch	st(4)			;; val,ttmpg,carry,ttpg,nxtttp
	fld	QWORD PTR [ebx+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(2)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttmpg,carry,ttpg,nxtttp

				;; ttmp,prev,ttmpg,carry,ttpg,ttp
	fmul	QWORD PTR [esi+dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttmpg,carry,ttpg,ttp
	  fstp	QWORD PTR [esi]		;; Save the previous value
	  				;; val,ttmpg,carry,ttpg,ttp
	faddp	st(2), st		;; x = value + carry
	  fxch	st(2)			;; ttpg,x,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(3)			;; ttmpg,ttpg,x,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,y,ttp
	fsubr	st, st(4)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(4)			;; y,ttmpg,ttpg,x,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+16]	;; Load next two-to-phi
	  fxch	st(5)			;; z,carry,ttmpg,ttpg,x,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(2)			;; ttpg,ttmpg,carry,val,nxtttp,ttp
	  fmulp	st(4), st		;; Compute next two-to-phi
	  fxch	st(4)			;; ttp,carry,val,nxtttp,ttmpg
	fmulp	st(2), st		;; new value = val * two-to-phi
	fld	QWORD PTR [ebx+24]	;; Load next two-to-minus-phi col mult
	fmulp	st(4), st		;; Compute next two-to-minus-phi
				;; carry,val,nxtttp,nxtttmp

				;; carry,prev,ttp,ttmp
	fxch	st(3)			;; ttmp,prev,ttp,carry
	fmul	QWORD PTR [esi+2*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttp,carry
	  fstp	QWORD PTR [esi+dist1]	;; Save the previous value
	  				;; val,ttp,carry
	faddp	st(2), st		;; x = value + carry
	fxch	st(1)			;; x,ttp
	fsub	BIGVAL			;; Round off
	fmulp	st(1), st		;; new value = val * two-to-phi
	fstp	QWORD PTR [esi+2*dist1]	;; Save the value
	ENDM


; *************** normalize-times-3 macro ******************
; Like the normalize macros except that it multiplies the result by three.
; This is used in the P-1 factoring code.  Note: this code could probably
; be optimized further.

simple_normalize_times_3 MACRO
	fld	QWORD PTR [esi+0*8]	;; Load value		;v0,c0,s
	fmul	QWORD PTR [ebx+0*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	sub	edi, ebp		;;*U - 2 steps to compute
	 fld	QWORD PTR [esi+1*8]	;; Load value		;v1,v0,c0,s
	 fxch	st(1)						;v0,v1,c0,s
	faddp	st(2), st		;; x = value + carry	;v1,x0,s
	 fmul	QWORD PTR [ebx+1*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	fld	limit_bigmax[eax*8]	;; y = rounding const	;y0,v1,x0,s
	fadd	st, st(2)		;; y = top bits of x
	fxch	st(3)						;s,v1,x0,y0
	fadd	QWORD PTR [esi+0*8]	;; sumout += value
	fld	limit_bigmax[eax*8]	;; z = rounding const	;z0,s,v1,x0,y0
	fsubr	st, st(4)		;; z = y - z
	fxch	st(4)						;y0,s,v1,x0,z0
	fmul	limit_inverse[eax*8]	;; next carry = shift y	;c1,s,v1,x0,z0
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	edi, ebp		;; V - 2 steps to compute
	  fld	QWORD PTR [esi+2*8]	;; Load value	;v2,c1,s,v1,x0,z0
	  fxch	st(5)					;z0,c1,s,v1,x0,v2
	fsubp	st(4), st		;; new value = x - z	;c1,s,v1,v0,v2
	 faddp	st(2), st		;; x = value + carry	;s,x1,v0,v2
	 fld	limit_bigmax[eax*8]	;; y = rounding const	;y1,s,x1,v0,v2
	 fxch	st(3)						;v0,s,x1,y1,v2
	fmul	QWORD PTR [ebx+0*16]	;; new value = val * two-to-phi
	fxch	st(3)						;y1,s,x1,v0,v2
	 fadd	st, st(2)		;; y = top bits of x
	 fxch	st(1)						;s,y1,x1,v0,v2
	 fadd	QWORD PTR [esi+1*8]	;; sumout += value
	 fxch	st(4)						;v2,y1,x1,v0,s
	  fmul	QWORD PTR [ebx+2*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	 fld	limit_bigmax[eax*8]	;; z = rounding const ;z1,v2,y1,x1,v0,s
	 fsubr	st, st(2)		;; z = y - z
	 fxch	st(2)					      ;y1,v2,z1,x1,v0,s
	 fmul	limit_inverse[eax*8]	;; carry = shift y    ;c2,v2,z1,x1,v0,s
	 fxch	st(4)					      ;v0,v2,z1,x1,c2,s
	fstp	QWORD PTR [esi+0*8]	;; Save the value	;v2,z1,x1,c2,s
	 sbb	eax, eax		;; U - next big vs. little flag
	  sub	edi, ebp		;; V - 2 steps to compute
	fld	QWORD PTR [esi+3*8]	;; Load value	      ;v3,v2,z1,x1,c2,s
	fxch	st(2)					      ;z1,v2,v3,x1,c2,s
	 fsubp	st(3), st		;; new value = x - z	;v2,v3,v1,c2,s
	  faddp	st(3), st		;; x = value + carry	;v3,v1,x2,s
	  fld	limit_bigmax[eax*8]	;; y = rounding const	;y2,v3,v1,x2,s
	  fxch	st(2)						;v1,v3,y2,x2,s
	 fmul	QWORD PTR [ebx+1*16]	;; new value = val * two-to-phi
	 fxch	st(2)						;y2,v3,v1,x2,s
	  fadd	st, st(3)		;; y = top bits of x
	  fxch	st(4)						;s,v3,v1,x2,y2
	  fadd	QWORD PTR [esi+2*8]	;; sumout += value
	  fxch	st(1)						;v3,s,v1,x2,y2
	fmul	QWORD PTR [ebx+3*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	  fld	limit_bigmax[eax*8]	;; z = rounding const ;z2,v3,s,v1,x2,y2
	  fsubr	st, st(5)		;; z = y - z
	  fxch	st(5)					      ;y2,v3,s,v1,x2,z2
	  fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c3,v3,s,v1,x2,z2
	  fxch	st(3)					      ;v1,v3,s,c3,x2,z2
	 fstp	QWORD PTR [esi+1*8]	;; Save the value	;v3,s,c3,x2,z2
	  sbb	eax, eax		;; U - next big vs. little flag
	sub	edi, ebp		;; V - 2 steps to compute
	 fld	QWORD PTR [esi+4*8]	;; Load value	      ;v4,v3,s,c3,x2,z2
	 fxch	st(5)					      ;z2,v3,s,c3,x2,v4
	  fsubp	st(4), st		;; value = x - z	;v3,s,c3,v2,v4
	faddp	st(2), st		;; x = value + carry	;s,x3,v2,v4
	fld	limit_bigmax[eax*8]	;; y = rounding const	;y3,s,x3,v2,v4
	fxch	st(3)						;v2,s,x3,y3,v4
	  fmul	QWORD PTR [ebx+2*16]	;; new value = val * two-to-phi
	  fxch	st(3)						;y3,s,x3,v2,v4
	fadd	st, st(2)		;; y = top bits of x
	fxch	st(1)						;s,y3,x3,v2,v4
	fadd	QWORD PTR [esi+3*8]	;; sumout += value
	fxch	st(4)						;v4,y3,x3,v2,s
	 fmul	QWORD PTR [ebx+4*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	fld	limit_bigmax[eax*8]	;; z = rounding const ;z3,v4,y3,x3,v2,s
	fsubr	st, st(2)		;; z = y - z
	fxch	st(2)					      ;y3,v4,z3,x3,v2,s
	fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c4,v4,z3,x3,v2,s
	fxch	st(4)					      ;v2,v4,z3,x3,c4,s
	  fstp	QWORD PTR [esi+2*8]	;; Save previous value	;v4,z3,x3,c4,s
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	edi, ebp		;; V - 2 steps to compute
	  fld	QWORD PTR [esi+5*8]	;; Load value	      ;v5,v4,z3,x3,c4,s
	  fxch	st(2)					      ;z3,v4,v5,x3,c4,s
	fsubp	st(3), st		;; value = x - z	;v4,v5,v3,c4,s
	 faddp	st(3), st		;; x = value + carry	;v5,v3,x4,s
	 fld	limit_bigmax[eax*8]	;; y = rounding const	;y4,v5,v3,x4,s
	 fxch	st(2)						;v3,v5,y4,x4,s
	fmul	QWORD PTR [ebx+3*16]	;; new value = val * two-to-phi
	fxch	st(2)						;y4,v5,v3,x4,s
	 fadd	st, st(3)		;; y = top bits of x
	 fxch	st(4)						;s,v5,v3,x4,y4
	 fadd	QWORD PTR [esi+4*8]	;; sumout += value
	 fxch	st(1)						;v5,s,v3,x4,y4
	  fmul	QWORD PTR [ebx+5*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	 fld	limit_bigmax[eax*8]	;; z = rounding const ;z4,v5,s,v3,x4,y4
	 fsubr	st, st(5)		;; z = y - z
	 fxch	st(5)					      ;y4,v5,s,v3,x4,z4
	 fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c5,v5,s,v3,x4,z4
	 fxch	st(3)					      ;v3,v5,s,c5,x4,z4
	fstp	QWORD PTR [esi+3*8]	;; Save previous value	;v5,s,c5,x4,z4
	 sbb	eax, eax		;; U - next big vs. little flag
	  sub	edi, ebp		;; V - 2 steps to compute
	fld	QWORD PTR [esi+6*8]	;; Load value	      ;v6,v5,s,c5,x4,z4
	fxch	st(5)					      ;z4,v5,s,c5,x4,v6
	 fsubp	st(4), st		;; value = x - z	;v5,s,c5,v4,v6
	  faddp	st(2), st		;; x = value + carry	;s,x5,v4,v6
	  fld	limit_bigmax[eax*8]	;; y = rounding const	;y5,s,x5,v4,v6
	  fxch	st(3)						;v4,s,x5,y5,v6
	 fmul	QWORD PTR [ebx+4*16]	;; new value = val * two-to-phi
	 fxch	st(3)						;y5,s,x5,v4,v6
	  fadd	st, st(2)		;; y = top bits of x
	  fxch	st(1)						;s,y5,x5,v4,v6
	  fadd	QWORD PTR [esi+5*8]	;; sumout += value
	  fxch	st(4)						;v6,y5,x5,v4,s
	fmul	QWORD PTR [ebx+6*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	  fld	limit_bigmax[eax*8]	;; z = rounding const ;z5,v6,y5,x5,v4,s
	  fsubr	st, st(2)		;; z = y - z
	  fxch	st(2)					      ;y5,v6,z5,x5,v4,s
	  fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c6,v6,z5,x5,v4,s
	  fxch	st(4)					      ;v4,v6,z5,x5,c6,s
	 fstp	QWORD PTR [esi+4*8]	;; Save previous value	;v6,z5,x5,c6,s
	  sbb	eax, eax		;; U - next big vs. little flag
	sub	edi, ebp		;; V - 2 steps to compute
	 fld	QWORD PTR [esi+7*8]	;; Load value	      ;v7,v6,z5,x5,c6,s
	 fxch	st(2)					      ;z5,v6,v7,x5,c6,s
	  fsubp	st(3), st		;; value = x - z	;v6,v7,v5,c6,s
	faddp	st(3), st		;; x = value + carry	;v7,v5,x6,s
	fld	limit_bigmax[eax*8]	;; y = rounding const	;y6,v7,v5,x6,s
	fxch	st(2)						;v5,v7,y6,x6,s
	  fmul	QWORD PTR [ebx+5*16]	;; new value = val * two-to-phi
	  fxch	st(2)						;y6,v7,v5,x6,s
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(4)						;s,v7,v5,x6,y6
	fadd	QWORD PTR [esi+6*8]	;; sumout += value
	fxch	st(1)						;v7,s,v5,x6,y6
	 fmul	QWORD PTR [ebx+7*16+8]	;; Mul value by two-to-minus-phi
fadd BIGVAL
fsub BIGVAL
fmul P3
	fld	limit_bigmax[eax*8]	;; z = rounding const ;z6,v7,s,v5,x6,y6
	fsubr	st, st(5)		;; z = y - z
	fxch	st(5)					      ;y6,v7,s,v5,x6,z6
	fmul	limit_inverse[eax*8]	;; carry = shifted y  ;c7,v7,s,v5,x6,z6
	fxch	st(3)					      ;v5,v7,s,c7,x6,z6
	  fstp	QWORD PTR [esi+5*8]	;; Save previous value	;v7,s,c7,x6,z6
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	edi, ebp		;; V - 2 steps to compute
	 faddp	st(2), st		;; x = value + carry	;s,x7,x6,z6
	 fxch	st(2)						;x6,x7,s,z6
	fsubrp	st(3), st		;; value = x - z	;x7,s,v6
	 fld	limit_bigmax[eax*8]	;; y = rounding const	;y7,x7,s,v6
	 fadd	st, st(1)		;; y = top bits of x
	 fxch	st(3)						;v6,x7,s,y7
	fmul	QWORD PTR [ebx+6*16]	;; new value = val * two-to-phi
	 fld	limit_bigmax[eax*8]	;; z = rounding const	;z7,v6,x7,s,y7
	 fsubr	st, st(4)		;; z = y - z
	 fxch	st(4)						;y7,v6,x7,s,z7
	 fmul	limit_inverse[eax*8]	;; carry = shifted y	;c,v6,x7,s,z7
	 fxch	st(3)						;s,v6,x7,c,z7
	 fadd	QWORD PTR [esi+7*8]	;; sumout += value
	 fxch	st(4)						;z7,v6,x7,c,s
	 fsubp	st(2), st		;; value = x - z	;v6,v7,c,s
	fstp	QWORD PTR [esi+6*8]	;; Save previous value	;v7,c,s
	 fmul	QWORD PTR [ebx+7*16]	;; new value = val * two-to-phi
	 sbb	eax, eax		;;*U - next big vs. little flag
					;; STALL
					;; STALL
	 fstp	QWORD PTR [esi+7*8]	;; Save previous value	;c,s
	ENDM

normalize_times_3 MACRO			;; ttmp,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi]		;; Mul value by two-to-minus-phi
					;; STALL
					;; STALL
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx]		;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi]		;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi]		;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+16]	;; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+24]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi+2*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,ttmpg,ttp,carry,sum
	  fstp	QWORD PTR [esi+dist1]	;; Save the previous value
	  				;; val,ttpg,ttmpg,ttp,carry,sum
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+32]	;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi+2*dist1]	;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+3*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi+2*dist1]	;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+32+16]	;; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+3*dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+32+24]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi+4*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,ttmpg,ttp,carry,sum
	  fstp	QWORD PTR [esi+3*dist1]	;; Save the previous value
	  				;; val,ttpg,ttmpg,ttp,carry,sum
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+2*32]	;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi+4*dist1]	;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+2*32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+5*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi+4*dist1]	;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+2*32+16];; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+5*dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+2*32+24];; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fmul	QWORD PTR [esi+6*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,ttmpg,ttp,carry,sum
	  fstp	QWORD PTR [esi+5*dist1]	;; Save the previous value
	  				;; val,ttpg,ttmpg,ttp,carry,sum
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(4), st		;; x = value + carry
	  				;; ttpg,ttmpg,ttp,x,sum
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,ttmpg,ttp,x,sum
	fadd	st, st(4)		;; y = top bits of x
	  fxch	st(2)			;; ttmpg,ttpg,y,ttp,x,sum
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,y,ttp,x,sum
	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(3)			;; y,ttmpg,ttpg,z,ttp,x,sum
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+3*32]	;; Load next two-to-phi
	  fxch	st(4)			;; z,carry,ttmpg,ttpg,nxtttp,ttp,x,sum
	fsubp	st(6), st		;; rounded value = x - z
	  fxch	st(3)			;; nxtttp,ttmpg,ttpg,carry,ttp,val,sum
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(6)			;; sum,ttmpg,ttpg,carry,ttp,val,nxtttp
	  fadd	QWORD PTR [esi+6*dist1]	;; sumout += value
	  fxch	st(4)			;; ttp,ttmpg,ttpg,carry,sum,val,nxtttp
	fmulp	st(5), st		;; new value = val * two-to-phi
	fxch	st(4)			;; val,ttpg,carry,sum,ttmpg,nxtttp
	fld	QWORD PTR [ebx+3*32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(5)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,carry,sum,ttmpg,nxtttp

				;; ttmp,prev,ttpg,carry,sum,ttmpg,ttp
	fmul	QWORD PTR [esi+7*dist1]	;; Mul value by two-to-minus-phi
	  fxch	st(1)			;; prev,val,ttpg,carry,sum,ttmpg,ttp
	  fstp	QWORD PTR [esi+6*dist1]	;; Save the previous value
	  				;; val,ttpg,carry,sum,ttmpg,ttp
fadd BIGVAL
fsub BIGVAL
fmul P3
	faddp	st(2), st		;; x = value + carry
	  				;; ttpg,x,sum,ttmpg,ttp
	  fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult 
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttpg,x,sum,ttmpg,ttp
	fadd	st, st(2)		;; y = top bits of x
	  fxch	st(4)			;; ttmpg,ttpg,x,sum,y,ttp
	  fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	  fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
					;; bigmax,ttmpg,ttpg,x,sum,y,ttp
	fsubr	st, st(5)		;; z = y - (maximum * BIGVAL - BIGVAL)
	  fxch	st(5)			;; y,ttmpg,ttpg,x,sum,z,ttp
	  fmul	limit_inverse[eax*8]	;; next carry = shifted y
	  fld	QWORD PTR [ebx+3*32+16];; Load next two-to-phi
	  fxch	st(6)			;; z,carry,ttmpg,ttpg,x,sum,nxtttp,ttp
	fsubp	st(4), st		;; rounded value = x - z
	  fxch	st(5)			;; nxtttp,ttmpg,ttpg,val,sum,carry,ttp
	  fmul	st, st(2)		;; Compute next two-to-phi
	  fxch	st(4)			;; sum,ttmpg,ttpg,val,nxtttp,carry,ttp
	  fadd	QWORD PTR [esi+7*dist1]	;; sumout += value
	  fxch	st(6)			;; ttp,ttmpg,ttpg,val,nxtttp,carry,sum
	fmulp	st(3), st		;; new value = val * two-to-phi
	fxch	st(2)			;; val,ttpg,ttmpg,nxtttp,carry,sum
	fld	QWORD PTR [ebx+3*32+24];; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	  sub	edi, ebp		;; U - 2 steps to compute
	  sbb	eax, eax		;;*U - next big vs. little flag
				;; nxtttmp,val,ttpg,ttmpg,nxtttp,carry,sum

				;; ttmp,prev,ttpg,ttmpg,ttp,carry,sum
	fxch	st(1)
	fstp	QWORD PTR [esi+7*dist1]
	ENDM


; *************** simple normalized add/sub macro ******************
; This macro adds or subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the summed values by
; two-to-minus-phi.  Rounding the value to an integer.  Making sure
; the integer is smaller than the maximum allowable integer, generating
; a carry if necessary. Finally, the value is multiplied by two-to-phi
; and stored.
; st(0) = carry
; ecx = pointer to first number
; edx = distance to second number
; ebp = big vs. little running sum
; ebx = pointer two-to-power multipliers
; esi = destination
; eax = the big vs. little word flag
; edi is preserved
; A pipelined version of this code:
;	fld	QWORD PTR [edx+0*8]	;; Load value
;	fop	QWORD PTR [ecx+0*8]	;; Add in second value
;	fmul	ttmp_ff			;; Mul value by two-to-minus-phi fudge
;	fmul	QWORD PTR [ebx+0*16+8]	;; Mul value by two-to-minus-phi
;	faddp	st(1), st		;; x = value + carry
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fadd	st, st(1)		;; y = top bits of x
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fsubr	st, st(1)		;; z = y - (maximum * BIGVAL - BIGVAL)
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y
;	sub	ebp, scaled_numbig	;; U - 2 steps to compute
;	sbb	eax, eax		;;*U - next big vs. little flag
;	fsubp	st(2), st		;; new value = x - z
;	fmul	QWORD PTR [ebx+0*16]	;; new value = val * two-to-phi
;	fstp	QWORD PTR [esi+0*8]	;; Save new value

simple_norm_op MACRO fop
	fld	QWORD PTR [edx+0*8]	;; Load value
	fop	QWORD PTR [ecx+0*8]	;; Add in second value
	push	edi			;; U - Save edi
	mov	edi, scaled_numbig	;; V - Value to compute big-vs-little
	sub	ebp, edi		;; U - 2 steps to compute
	lea	ebx, [ebx+8*16]		;; V - Next set of 8 multipliers
	fmul	ttmp_ff			;; Mul value by two-to-minus-phi fudge
	 fld	QWORD PTR [edx+1*8]	;; Load value
	 fop	QWORD PTR [ecx+1*8]	;; Add in second value
	fxch	st(1)			;; val,nxtval,carry
	fmul	QWORD PTR [ebx-8*16+0*16+8];; Mul value by two-to-minus-phi
	  fld	QWORD PTR [edx+2*8]	;; Load value
	  fop	QWORD PTR [ecx+2*8]	;; Add in second value
	fxch	st(3)			;; carry,val,nxtval,nxtnxtval
	faddp	st(1), st		;; x = value + carry
	fxch	st(1)			;; nxtval,x,nxtnxtval
	 fmul	ttmp_ff			;; Mul value by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fadd	st, st(2)		;; y = top bits of x
	fxch	st(1)			;; nxtval,y,x,nxtnxtval
	 fmul	QWORD PTR [ebx-8*16+1*16+8];; Mul value by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(2)			;; y,nxtval,z,x,nxtnxtval
	fsubr	st(2), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	 sub	ebp, edi		;; V - 2 steps to compute
	  fld	QWORD PTR [edx+3*8]	;; Load value
	  fop	QWORD PTR [ecx+3*8]	;; Add in second value
	fxch	st(3)			;; z,carry,nxtval,nnnval,x,nxtnxtval
	fsubp	st(4), st		;; new value = x - z
					;; carry,nxtval,nnnval,val,nxtnxtval

					;; carry,val,nxtnxtval,prevval,nxtval
	faddp	st(1), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; prevval,x,nxtnxtval,y,nxtval
	 fmul	QWORD PTR [ebx-8*16+0*16];; prevval = prevval * two-to-phi
	fxch	st(3)			;; y,x,nxtnxtval,prevval,nxtval
	fadd	st, st(1)		;; y = top bits of x
	fxch	st(4)			;; nxtval,x,nxtnxtval,prevval,y
	 fmul	ttmp_ff			;; Mul nxtval by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(5)			;; y,nxtval,x,nxtnxtval,prevval,z
	fsubr	st(5), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(4)			;; prevval,nxtval,x,nxtnxtval,carry,z
	 fstp	QWORD PTR [esi+0*8]	;; Save previous value
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, edi		;; V - 2 steps to compute
	 fld	QWORD PTR [edx+4*8]	;; Load future value
	fxch	st(1)			;; nxtval,nnnval,x,nxtnxtval,carry,z
	 fmul	QWORD PTR [ebx-8*16+2*16+8];; Mul nxtval by two-to-minus-phi
	fxch	st(1)			;; nnnval,nxtval,x,nxtnxtval,carry,z
	 fop	QWORD PTR [ecx+4*8]	;; Add in second value
	fxch	st(5)			;; z,nxtval,x,nxtnxtval,carry,nnnval
	fsubp	st(2), st		;; new value = x - z
					;; nxtval,val,nxtnxtval,carry,nnnval

					;; val,prevval,nxtval,carry,nxtnxtval
	faddp	st(3), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; prevval,y,nxtval,x,nxtnxtval
	 fmul	QWORD PTR [ebx-8*16+1*16];; prevval = prevval * two-to-phi
	fxch	st(1)			;; y,prevval,nxtval,x,nxtnxtval
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(2)			;; nxtval,prevval,y,x,nxtnxtval
	 fmul	ttmp_ff			;; Mul nxtval by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; y,nxtval,prevval,z,x,nxtnxtval
	fsubr	st(3), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(2)			;; prevval,nxtval,carry,z,x,nxtnxtval
	 fstp	QWORD PTR [esi+1*8]	;; Save previous value
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, edi		;; V - 2 steps to compute
	 fld	QWORD PTR [edx+5*8]	;; Load future value
	fxch	st(1)			;; nxtval,nnnval,carry,z,x,nxtnxtval
	 fmul	QWORD PTR [ebx-8*16+3*16+8];; Mul nxtval by two-to-minus-phi
	fxch	st(1)			;; nnnval,nxtval,carry,z,x,nxtnxtval
	 fop	QWORD PTR [ecx+5*8]	;; Add in second value
	fxch	st(3)			;; z,nxtval,carry,nnnval,x,nxtnxtval
	fsubp	st(4), st		;; new value = x - z
					;; nxtval,carry,nnnval,val,nxtnxtval

					;; val,carry,nxtnxtval,prevval,nxtval
	faddp	st(1), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; prevval,x,nxtnxtval,y,nxtval
	 fmul	QWORD PTR [ebx-8*16+2*16];; prevval = prevval * two-to-phi
	fxch	st(3)			;; y,x,nxtnxtval,prevval,nxtval
	fadd	st, st(1)		;; y = top bits of x
	fxch	st(4)			;; nxtval,x,nxtnxtval,prevval,y
	 fmul	ttmp_ff			;; Mul nxtval by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(5)			;; y,nxtval,x,nxtnxtval,prevval,z
	fsubr	st(5), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(4)			;; prevval,nxtval,x,nxtnxtval,carry,z
	 fstp	QWORD PTR [esi+2*8]	;; Save previous value
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, edi		;; V - 2 steps to compute
	 fld	QWORD PTR [edx+6*8]	;; Load future value
	fxch	st(1)			;; nxtval,nnnval,x,nxtnxtval,carry,z
	 fmul	QWORD PTR [ebx-8*16+4*16+8];; Mul nxtval by two-to-minus-phi
	fxch	st(1)			;; nnnval,nxtval,x,nxtnxtval,carry,z
	 fop	QWORD PTR [ecx+6*8]	;; Add in second value
	fxch	st(5)			;; z,nxtval,x,nxtnxtval,carry,nnnval
	fsubp	st(2), st		;; new value = x - z
					;; nxtval,val,nxtnxtval,carry,nnnval

					;; val,prevval,nxtval,carry,nxtnxtval
	faddp	st(3), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; prevval,y,nxtval,x,nxtnxtval
	 fmul	QWORD PTR [ebx-8*16+3*16];; prevval = prevval * two-to-phi
	fxch	st(1)			;; y,prevval,nxtval,x,nxtnxtval
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(2)			;; nxtval,prevval,y,x,nxtnxtval
	 fmul	ttmp_ff			;; Mul nxtval by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; y,nxtval,prevval,z,x,nxtnxtval
	fsubr	st(3), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(2)			;; prevval,nxtval,carry,z,x,nxtnxtval
	 fstp	QWORD PTR [esi+3*8]	;; Save previous value
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, edi		;; V - 2 steps to compute
	 fld	QWORD PTR [edx+7*8]	;; Load future value
	fxch	st(1)			;; nxtval,nnnval,carry,z,x,nxtnxtval
	 fmul	QWORD PTR [ebx-8*16+5*16+8];; Mul nxtval by two-to-minus-phi
	fxch	st(1)			;; nnnval,nxtval,carry,z,x,nxtnxtval
	 fop	QWORD PTR [ecx+7*8]	;; Add in second value
	fxch	st(3)			;; z,nxtval,carry,nnnval,x,nxtnxtval
	fsubp	st(4), st		;; new value = x - z
					;; nxtval,carry,nnnval,val,nxtnxtval

					;; val,carry,nxtnxtval,prevval,nxtval
	faddp	st(1), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; prevval,x,nxtnxtval,y,nxtval
	 fmul	QWORD PTR [ebx-8*16+4*16];; prevval = prevval * two-to-phi
	fxch	st(3)			;; y,x,nxtnxtval,prevval,nxtval
	fadd	st, st(1)		;; y = top bits of x
	fxch	st(4)			;; nxtval,x,nxtnxtval,prevval,y
	 fmul	ttmp_ff			;; Mul nxtval by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(5)			;; y,nxtval,x,nxtnxtval,prevval,z
	fsubr	st(5), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(4)			;; prevval,nxtval,x,nxtnxtval,carry,z
	 fstp	QWORD PTR [esi+4*8]	;; Save previous value
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, edi		;; V - 2 steps to compute
	 fmul	QWORD PTR [ebx-8*16+6*16+8];; Mul nxtval by two-to-minus-phi
	fxch	st(4)			;; z,x,nxtnxtval,carry,nxtval
	fsubp	st(1), st		;; new value = x - z
					;; val,nxtnxtval,carry,nxtval

	fxch	st(2)			;; carry,nxtval,prevval,val
	faddp	st(3), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(2)			;; prevval,nxtval,y,x
	 fmul	QWORD PTR [ebx-8*16+5*16];; prevval = prevval * two-to-phi
	fxch	st(2)			;; y,nxtval,prevval,x
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(1)			;; nxtval,y,prevval,x
	 fmul	ttmp_ff			;; Mul nxtval by two-to-minus-phi fudge
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(2)			;; y,nxtval,z,prevval,x
	fsubr	st(2), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(3)			;; prevval,nxtval,z,carry,x
	 fstp	QWORD PTR [esi+5*8]	;; Save previous value
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, edi		;; V - 2 steps to compute
	 fmul	QWORD PTR [ebx-8*16+7*16+8];; Mul nxtval by two-to-minus-phi
	fxch	st(1)			;; z,nxtval,carry,x
	fsubp	st(3), st		;; new value = x - z
					;; nxtval,carry,val

					;; val,carry,prevval
	faddp	st(1), st		;; x = value + carry
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(2)			;; prevval,x,y
	 fmul	QWORD PTR [ebx-8*16+6*16];; prevval = prevval * two-to-phi
	fxch	st(2)			;; y,x,prevval
	fadd	st, st(1)		;; y = top bits of x
	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; y,z,x,prevval
	fsubr	st(1), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fxch	st(3)			;; prevval,z,x,carry
	 fstp	QWORD PTR [esi+6*8]	;; Save previous value
	fsubp	st(1), st		;; new value = x - z
	sbb	eax, eax		;; U - next big vs. little flag
	pop	edi			;; V - restore edi
	fmul	QWORD PTR [ebx-8*16+7*16];; val = val * two-to-phi
	lea	ecx, [ecx+8*dist1]	;; U - Next source
	lea	edx, [edx+8*dist1]	;; V - Next source
	fstp	QWORD PTR [esi+7*8]	;; Save value
	lea	esi, [esi+8*dist1]	;; U - Next dest
	ENDM


; *************** simple normalized add and sub macro ******************
; This macro adds and subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the sum values by
; two-to-minus-phi.  Adding, subtracting and rounding the value to an
; integer.  Make sure the integer is smaller than the maximum allowable
; integer, generating carries if necessary.  Finally, the values are
; multiplied by two-to-phi and stored.
; st(1) = add carry
; st(0) = sub carry
; ecx = pointer to first number
; edx = distance to second number
; esi = destination for added numbers
; ebp = destination for subtracted numbers
; edi = big vs. little running sum
; ebx = pointer two-to-power multipliers
; eax = the big vs. little word flag
; A pipelined version of this code:
;	fld	QWORD PTR [edx+0*8]	;; Load first value
;	fld	st(0)			;; Copy first value
;	fadd	QWORD PTR [ecx+0*8]	;; Add in second value
;	fsub	QWORD PTR [ecx+0*8]	;; Subtract second value
;	fld	ttmp_ff			;; Load two-to-minus-phi fudge
;	fmul	QWORD PTR [ebx+0*16+8]	;; Mul by two-to-minus-phi
;	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
;	fmul	st, st(1)		;; Mul sub val by two-to-minus-phi
;	faddp	st(1), st		;; x1 = value + carry
;	faddp	st(1), st		;; x2 = value + carry
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fld	st(0)			;; Load maximum * BIGVAL - BIGVAL
;	fadd	st, st(1)		;; y1 = top bits of x1
;	fadd	st, st(1)		;; y2 = top bits of x2
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fld	st(0)			;; Load maximum * BIGVAL - BIGVAL
;	fsubr	st, st(1)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
;	fsubr	st, st(1)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
;	sub	edi, scaled_numbig	;; U - 2 steps to compute
;	sbb	eax, eax		;;*U - next big vs. little flag
;	fsubp	st(2), st		;; new value = x1 - z1
;	fsubp	st(2), st		;; new value = x2 - z2
;	fmul	QWORD PTR [ebx+0*16]	;; new value = val1 * two-to-phi
;	fmul	QWORD PTR [ebx+0*16]	;; new value = val2 * two-to-phi
;	fstp	QWORD PTR [esi+0*8]	;; Save new value
;	fstp	QWORD PTR [ebp+0*8]	;; Save new value

simple_norm_addsub MACRO
	fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fmul	QWORD PTR [ebx+0*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+0*8]	;; Load first value
	fadd	QWORD PTR [ecx+0*8]	;; Add in second value
	fld	QWORD PTR [edx+0*8]	;; Load first value
	fsub	QWORD PTR [ecx+0*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+0*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+0*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+0*8]	;; Save new value
	fstp	QWORD PTR [ebp+0*8]	;; Save new value

	fmul	QWORD PTR [ebx+1*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+1*8]	;; Load first value
	fadd	QWORD PTR [ecx+1*8]	;; Add in second value
	fld	QWORD PTR [edx+1*8]	;; Load first value
	fsub	QWORD PTR [ecx+1*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+1*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+1*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+1*8]	;; Save new value
	fstp	QWORD PTR [ebp+1*8]	;; Save new value

	fmul	QWORD PTR [ebx+2*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+2*8]	;; Load first value
	fadd	QWORD PTR [ecx+2*8]	;; Add in second value
	fld	QWORD PTR [edx+2*8]	;; Load first value
	fsub	QWORD PTR [ecx+2*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+2*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+2*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+2*8]	;; Save new value
	fstp	QWORD PTR [ebp+2*8]	;; Save new value

	fmul	QWORD PTR [ebx+3*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+3*8]	;; Load first value
	fadd	QWORD PTR [ecx+3*8]	;; Add in second value
	fld	QWORD PTR [edx+3*8]	;; Load first value
	fsub	QWORD PTR [ecx+3*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+3*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+3*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+3*8]	;; Save new value
	fstp	QWORD PTR [ebp+3*8]	;; Save new value

	fmul	QWORD PTR [ebx+4*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+4*8]	;; Load first value
	fadd	QWORD PTR [ecx+4*8]	;; Add in second value
	fld	QWORD PTR [edx+4*8]	;; Load first value
	fsub	QWORD PTR [ecx+4*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+4*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+4*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+4*8]	;; Save new value
	fstp	QWORD PTR [ebp+4*8]	;; Save new value

	fmul	QWORD PTR [ebx+5*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+5*8]	;; Load first value
	fadd	QWORD PTR [ecx+5*8]	;; Add in second value
	fld	QWORD PTR [edx+5*8]	;; Load first value
	fsub	QWORD PTR [ecx+5*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+5*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+5*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+5*8]	;; Save new value
	fstp	QWORD PTR [ebp+5*8]	;; Save new value

	fmul	QWORD PTR [ebx+6*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+6*8]	;; Load first value
	fadd	QWORD PTR [ecx+6*8]	;; Add in second value
	fld	QWORD PTR [edx+6*8]	;; Load first value
	fsub	QWORD PTR [ecx+6*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+6*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	 fld	ttmp_ff			;; Load two-to-minus-phi fudge
	fxch	st(2)			;; v2,v1,ff,c2,c1
	fmul	QWORD PTR [ebx+6*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,ff,c2,c1
	fstp	QWORD PTR [esi+6*8]	;; Save new value
	fstp	QWORD PTR [ebp+6*8]	;; Save new value

	fmul	QWORD PTR [ebx+7*16+8]	;; Mul by two-to-minus-phi
	fld	QWORD PTR [edx+7*8]	;; Load first value
	fadd	QWORD PTR [ecx+7*8]	;; Add in second value
	fld	QWORD PTR [edx+7*8]	;; Load first value
	fsub	QWORD PTR [ecx+7*8]	;; Subtract second value
	fxch	st(1)			;; v1,v2,ttmp,c2,c1
	fmul	st, st(2)		;; Mul added val by two-to-minus-phi
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fxch	st(3)			;; ttmp,v1,v2,z1,c2,c1
	fmulp	st(2), st		;; Mul sub val by two-to-minus-phi
	faddp	st(4), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = maximum * BIGVAL - BIGVAL
	fxch	st(1)			;; v2,y1,z1,c2,x1
	faddp	st(3), st		;; x2 = value + carry
	fadd	st, st(3)		;; y1 = top bits of x1
	fld	limit_bigmax[eax*8]	;; y2 = maximum * BIGVAL - BIGVAL
	fadd	st, st(3)		;; y2 = top bits of x2
	fxch	st(1)			;; y1,y2,z1,x2,x1
	fsubr	st(2), st		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y1,z2,y2,z1,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(5)			;; x1,z2,y2,z1,x2,c1
	fsubrp	st(3), st		;; new value = x1 - z1
	fxch	st(1)			;; y2,z2,v1,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(3)			;; x2,z2,v1,c2,c1
	fsubrp	st(1), st		;; new value = x2 - z2
	fxch	st(1)			;; v1,v2,c2,c1
	fmul	QWORD PTR [ebx+7*16]	;; new value = val1 * two-to-phi
	sub	edi, scaled_numbig	;; UU - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
	fxch	st(1)			;; v2,v1,c2,c1
	fmul	QWORD PTR [ebx+7*16]	;; new value = val2 * two-to-phi
	fxch	st(1)			;; v1,v2,c2,c1
	fstp	QWORD PTR [esi+7*8]	;; Save new value
	fstp	QWORD PTR [ebp+7*8]	;; Save new value

	lea	ebx, [ebx+8*16]		;; V - Next set of 8 multipliers
	lea	ecx, [ecx+8*dist1]	;; U - Next source
	lea	edx, [edx+8*dist1]	;; V - Next source
	lea	esi, [esi+8*dist1]	;; U - Next dest
	lea	ebp, [ebp+8*dist1]	;; U - Next dest
	ENDM


; *************** normalized add/sub macro ******************
; This macro adds or subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the summed values by
; two-to-minus-phi.  Rounding the value to an integer.  Making sure
; the integer is smaller than the maximum allowable integer, generating
; a carry if necessary. Finally, the value is multiplied by two-to-phi
; and stored.
; st(0) = carry
; ecx = pointer to first number
; edx = pointer to second number
; ebp = big vs. little running sum
; edi = pointer two-to-power multipliers
; esi = destination
; eax = the big vs. little word flag
; ebx is preserved
; A pipelined version of this code:
;	fld	QWORD PTR [ecx+0*dist1][edx];; Load source
;	fop	QWORD PTR [ecx+0*dist1]	;; Add in the second source
;	fmulp	st(1), st		;; Mul value by two-to-minus-phi
;	faddp	st(4), st		;; x = value + carry
;	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
;	fld	limit_bigmax[eax*8]	;; y = rounding const
;	fadd	st, st(4)		;; y = top bits of x
;	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
;	fld	limit_bigmax[eax*8]	;; Load maximum * BIGVAL - BIGVAL
;	fsubr	st, st(3)		;; z = y - (maximum * BIGVAL - BIGVAL)
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y
;	fld	QWORD PTR [edi+0*16]	;; Load next two-to-phi
;	fsubp	st(6), st		;; rounded value = x - z
;	fmul	st, st(2)		;; Compute next two-to-phi
;	fmulp	st(5), st		;; new value = val * two-to-phi
;	fld	QWORD PTR [edi+0*16+8]	;; Load next two-to-minus-phi col mult
;	fmul	st, st(5)		;; Compute next two-to-minus-phi
;	sub	ebp, scaled_numbig	;; U - Adjust scaled counter
;	sbb	eax, eax		;;*U - next big vs. little flag
;	fstp	QWORD PTR [esi+0*dist1]	;; Save the value

norm_op MACRO fop, nextdist		;; ttmp,ttpg,ttmpg,ttp,carry
	fld	QWORD PTR [ecx+0*dist1][edx];; Load source
	fop	QWORD PTR [ecx+0*dist1]	;; Add in the second source
	push	ebx			;; U - Save ebx
	mov	ebx, scaled_numbig	;; V - Value to compute big-vs-little
	sub	ebp, ebx		;; U - Adjust scaled counter
	lea	edi, [edi+8*16]		;; V - Next set of 8 multipliers
	fmulp	st(1), st		;; Mul value by two-to-minus-phi
	 fld	QWORD PTR [ecx+1*dist1][edx];; Load source
	 fop	QWORD PTR [ecx+1*dist1]	;; Add in the second source
	fxch	st(1)			;; value,nxtval,ttpg,ttmpg,ttp,carry
	faddp	st(5), st		;; x = value + carry
	fxch	st(1)			;; ttpg,nxtval,ttmpg,ttp,x
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; nxtval,ttpg,y,ttmpg,ttp,x
	 fmul	QWORD PTR [edi-8*16+0*16+8];; Apply next ttmp col mult
	fxch	st(2)			;; y,ttpg,nxtval,ttmpg,ttp,x
	fadd	st, st(5)		;; y = top bits of x
	fxch	st(3)			;; ttmpg,ttpg,nxtval,y,ttp,x
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fsubr	st, st(4)		;; z = y - (maximum * BIGVAL - BIGVAL)
	fxch	st(4)			;; y,ttmpg,ttpg,nxtval,z,ttp,x
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
	  fld	QWORD PTR [ecx+2*dist1][edx];; Load source
	  fop	QWORD PTR [ecx+2*dist1]	;; Add in the second source
	fxch	st(5)			;; z,carry,ttmpg,ttpg,nxtval,val2,ttp,x
	fsubp	st(7), st		;; rounded value = x - z
	fxch	st(1)			;; ttmpg,carry,ttpg,nxtval,val2,ttp,val
	 fmul	st(3), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+0*16];; Load next two-to-phi
	fxch	st(6)		;; ttp,ttmpg,carry,ttpg,nxtval,val2,nxtttp,val
	fmulp	st(7), st	;; new value = val * two-to-phi
				;; ttmpg,carry,ttpg,nxtval,val2,nxtttp,val

				;; ttmpg,carry,ttpg,val,nxtval,ttp,prevval
	fxch	st(1)		;; carry,ttmpg,ttpg,val,nxtval,ttp,prevval
	faddp	st(3), st		;; x = value + carry
	fxch	st(4)			;; ttp,ttpg,x,nxtval,ttmpg,prevval
	fmul	st, st(1)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; ttpg,ttp,y,x,nxtval,ttmpg,prevval
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; y,ttp,ttpg,x,nxtval,ttmpg,prevval
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(5)			;; ttmpg,ttp,ttpg,x,nxtval,y,prevval
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(6)			;; prevval,ttp,ttpg,x,nxtval,y,ttmpg
	fstp	QWORD PTR [esi+0*dist1]	;; Save previous value
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(4)			;; nxtval,ttp,ttpg,x,z,y,ttmpg
	 fmul	QWORD PTR [edi-8*16+1*16+8];; Apply next ttmp col mult
	fxch	st(5)			;; y,ttp,ttpg,x,z,nxtval,ttmpg
	fsubr	st(4), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
	  fld	QWORD PTR [ecx+3*dist1][edx];; Load source
	  fop	QWORD PTR [ecx+3*dist1]	;; Add in the second source
	fxch	st(5)			;; z,carry,ttp,ttpg,x,val2,nxtval,ttmpg
	fsubp	st(4), st		;; rounded value = x - z
	fxch	st(6)			;; ttmpg,ttp,ttpg,val,val2,nxtval,carry
	 fmul	st(5), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+1*16];; Load next two-to-phi
	fxch	st(2)		;; ttp,ttmpg,nxtttp,ttpg,val,val2,nxtval,carry
	fmulp	st(4), st	;; new value = val * two-to-phi
				;; ttmpg,nxtttp,ttpg,val,val2,nxtval,carry

				;; ttmpg,ttp,ttpg,prevval,nxtval,val,carry
	fxch	st(6)		;; carry,ttp,ttpg,prevval,nxtval,val,ttmpg
	faddp	st(5), st		;; x = value + carry
					;; ttp,ttpg,prevval,nxtval,x,ttmpg
	fmul	st, st(1)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; ttpg,ttp,y,prevval,nxtval,x,ttmpg
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; y,ttp,ttpg,prevval,nxtval,x,ttmpg
	fadd	st, st(5)		;; y = top bits of x
	fxch	st(6)			;; ttmpg,ttp,ttpg,prevval,nxtval,x,y
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(3)			;; prevval,ttp,ttpg,ttmpg,nxtval,x,y
	fstp	QWORD PTR [esi+1*dist1]	;; Save previous value
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(4)			;; nxtval,ttp,ttpg,ttmpg,z,x,y
	 fmul	QWORD PTR [edi-8*16+2*16+8];; Apply next ttmp col mult
	fxch	st(6)			;; y,ttp,ttpg,ttmpg,z,x,nxtval
	fsubr	st(4), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
	  fld	QWORD PTR [ecx+4*dist1][edx];; Load source
	  fop	QWORD PTR [ecx+4*dist1]	;; Add in the second source
	fxch	st(5)			;; z,carry,ttp,ttpg,ttmpg,val2,x,nxtval
	fsubp	st(6), st		;; rounded value = x - z
	fxch	st(3)			;; ttmpg,ttp,ttpg,carry,val2,val,nxtval
	 fmul	st(6), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+2*16];; Load next two-to-phi
	fxch	st(2)		;; ttp,ttmpg,nxtttp,ttpg,carry,val2,val,nxtval
	fmulp	st(6), st	;; new value = val * two-to-phi
				;; ttmpg,nxtttp,ttpg,carry,val2,val,nxtval

				;; ttmpg,ttp,ttpg,carry,nxtval,prevval,val
	fxch	st(3)		;; carry,ttp,ttpg,ttmpg,nxtval,prevval,val
	faddp	st(6), st		;; x = value + carry
					;; ttp,ttpg,ttmpg,nxtval,prevval,x
	fmul	st, st(1)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; ttpg,ttp,y,ttmpg,nxtval,prevval,x
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; y,ttp,ttpg,ttmpg,nxtval,prevval,x
	fadd	st, st(6)		;; y = top bits of x
	fxch	st(3)			;; ttmpg,ttp,ttpg,y,nxtval,prevval,x
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(5)			;; prevval,ttp,ttpg,y,nxtval,ttmpg,x
	fstp	QWORD PTR [esi+2*dist1]	;; Save previous value
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(4)			;; nxtval,ttp,ttpg,y,z,ttmpg,x
	 fmul	QWORD PTR [edi-8*16+3*16+8];; Apply next ttmp col mult
	fxch	st(3)			;; y,ttp,ttpg,nxtval,z,ttmpg,x
	fsubr	st(4), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
	  fld	QWORD PTR [ecx+5*dist1][edx];; Load source
	  fop	QWORD PTR [ecx+5*dist1]	;; Add in the second source
	fxch	st(5)			;; z,carry,ttp,ttpg,nxtval,val2,ttmpg,x
	fsubp	st(7), st		;; rounded value = x - z
	fxch	st(5)			;; ttmpg,ttp,ttpg,nxtval,val2,carry,val
	 fmul	st(3), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+3*16];; Load next two-to-phi
	fxch	st(2)		;; ttp,ttmpg,nxtttp,ttpg,nxtval,val2,carry,val
	fmulp	st(7), st	;; new value = val * two-to-phi
				;; ttmpg,nxtttp,ttpg,nxtval,val2,carry,val

				;; ttmpg,ttp,ttpg,val,nxtval,carry,prevval
	fxch	st(5)		;; carry,ttp,ttpg,val,nxtval,ttmpg,prevval
	faddp	st(3), st		;; x = value + carry
					;; ttp,ttpg,x,nxtval,ttmpg,prevval
	fmul	st, st(1)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; ttpg,ttp,y,x,nxtval,ttmpg,prevval
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; y,ttp,ttpg,x,nxtval,ttmpg,prevval
	fadd	st, st(3)		;; y = top bits of x
	fxch	st(5)			;; ttmpg,ttp,ttpg,x,nxtval,y,prevval
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(6)			;; prevval,ttp,ttpg,x,nxtval,y,ttmpg
	fstp	QWORD PTR [esi+3*dist1]	;; Save previous value
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(4)			;; nxtval,ttp,ttpg,x,z,y,ttmpg
	 fmul	QWORD PTR [edi-8*16+4*16+8];; Apply next ttmp col mult
	fxch	st(5)			;; y,ttp,ttpg,x,z,nxtval,ttmpg
	fsubr	st(4), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
	  fld	QWORD PTR [ecx+6*dist1][edx];; Load source
	  fop	QWORD PTR [ecx+6*dist1]	;; Add in the second source
	fxch	st(5)			;; z,carry,ttp,ttpg,x,val2,nxtval,ttmpg
	fsubp	st(4), st		;; rounded value = x - z
	fxch	st(6)			;; ttmpg,ttp,ttpg,val,val2,nxtval,carry
	 fmul	st(5), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+4*16];; Load next two-to-phi
	fxch	st(2)		;; ttp,ttmpg,nxtttp,ttpg,val,val2,nxtval,carry
	fmulp	st(4), st	;; new value = val * two-to-phi
				;; ttmpg,nxtttp,ttpg,val,val2,nxtval,carry

				;; ttmpg,ttp,ttpg,prevval,nxtval,val,carry
	fxch	st(6)		;; carry,ttp,ttpg,prevval,nxtval,val,ttmpg
	faddp	st(5), st		;; x = value + carry
					;; ttp,ttpg,prevval,nxtval,x,ttmpg
	fmul	st, st(1)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; ttpg,ttp,y,prevval,nxtval,x,ttmpg
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; y,ttp,ttpg,prevval,nxtval,x,ttmpg
	fadd	st, st(5)		;; y = top bits of x
	fxch	st(6)			;; ttmpg,ttp,ttpg,prevval,nxtval,x,y
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(3)			;; prevval,ttp,ttpg,ttmpg,nxtval,x,y
	fstp	QWORD PTR [esi+4*dist1]	;; Save previous value
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(4)			;; nxtval,ttp,ttpg,ttmpg,z,x,y
	 fmul	QWORD PTR [edi-8*16+5*16+8];; Apply next ttmp col mult
	fxch	st(6)			;; y,ttp,ttpg,ttmpg,z,x,nxtval
	fsubr	st(4), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
	  fld	QWORD PTR [ecx+7*dist1][edx];; Load source
	  fop	QWORD PTR [ecx+7*dist1]	;; Add in the second source
	fxch	st(5)			;; z,carry,ttp,ttpg,ttmpg,val2,x,nxtval
	fsubp	st(6), st		;; rounded value = x - z
	fxch	st(3)			;; ttmpg,ttp,ttpg,carry,val2,val,nxtval
	 fmul	st(6), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+5*16];; Load next two-to-phi
	fxch	st(2)		;; ttp,ttmpg,nxtttp,ttpg,carry,val2,val,nxtval
	fmulp	st(6), st	;; new value = val * two-to-phi
				;; ttmpg,nxtttp,ttpg,carry,val2,val,nxtval

				;; ttmpg,ttp,ttpg,carry,nxtval,prevval,val
	fxch	st(3)		;; carry,ttp,ttpg,ttmpg,nxtval,prevval,val
	faddp	st(6), st		;; x = value + carry
					;; ttp,ttpg,ttmpg,nxtval,prevval,x
	fmul	st, st(1)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(2)			;; ttpg,ttp,y,ttmpg,nxtval,prevval,x
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; y,ttp,ttpg,ttmpg,nxtval,prevval,x
	fadd	st, st(6)		;; y = top bits of x
	fxch	st(3)			;; ttmpg,ttp,ttpg,y,nxtval,prevval,x
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(5)			;; prevval,ttp,ttpg,y,nxtval,ttmpg,x
	fstp	QWORD PTR [esi+5*dist1]	;; Save previous value
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(4)			;; nxtval,ttp,ttpg,y,z,ttmpg,x
	 fmul	QWORD PTR [edi-8*16+6*16+8];; Apply next ttmp col mult
	fxch	st(3)			;; y,ttp,ttpg,nxtval,z,ttmpg,x
	fsubr	st(4), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	sbb	eax, eax		;; U - next big vs. little flag
	sub	ebp, ebx		;; V - Adjust scaled counter
					;; STALL
	fxch	st(4)			;; z,ttp,ttpg,nxtval,carry,ttmpg,x
	fsubp	st(6), st		;; rounded value = x - z
	fxch	st(4)			;; ttmpg,ttpg,nxtval,carry,ttp,val
	 fmul	st(2), st		;; Apply next two-to-minus-phi grp mult
	fld	QWORD PTR [edi-8*16+6*16];; Load next two-to-phi
	fxch	st(5)		;; ttp,ttmpg,ttpg,nxtval,carry,nxtttp,val
	fmulp	st(6), st	;; new value = val * two-to-phi
				;; ttmpg,ttpg,nxtval,carry,nxtttp,val

				;; ttmpg,ttpg,val,carry,ttp,prevval
	fxch	st(3)		;; carry,ttpg,val,ttmpg,ttp,prevval
	faddp	st(2), st		;; x = value + carry
	fxch	st(3)			;; ttp,x,ttmpg,ttpg,prevval
	fmul	st, st(3)		;; Finish computing this two-to-phi
	fld	limit_bigmax[eax*8]	;; y = rounding const
	fxch	st(4)			;; ttpg,ttp,x,ttmpg,y,prevval
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(2)			;; x,ttp,ttpg,ttmpg,y,prevval
	fadd	st(4), st		;; y = top bits of x
	fxch	st(3)			;; ttmpg,ttp,ttpg,x,y,prevval
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fld	limit_bigmax[eax*8]	;; z = Load maximum * BIGVAL - BIGVAL
	fxch	st(5)			;; y,ttmpg,ttp,ttpg,x,z,prevval
	fsubr	st(5), st		;; z = y - (maximum * BIGVAL - BIGVAL)
	fmul	limit_inverse[eax*8]	;; next carry = shifted y
	fld	QWORD PTR [edi-8*16+7*16];; Load next two-to-phi col mult
	fmul	st, st(4)		;; Compute next two-to-phi
	fxch	st(6)			;; z,carry,ttmpg,ttp,ttpg,x,nxtttp,pval
	fsubp	st(5), st		;; rounded value = x - z
	fxch	st(6)			;; pval,ttmpg,ttp,ttpg,val,nxtttp,carry
	fstp	QWORD PTR [esi+6*dist1]	;; Save previous value
	fxch	st(3)			;; val,ttp,ttpg,ttmpg,nxtttp,carry
	fmulp	st(1), st		;; new value = val * two-to-phi
	sbb	eax, eax		;; U - next big vs. little flag
	pop	ebx			;; V - restore ebx
	fld	QWORD PTR [edi-8*16+7*16+8];; Load next ttmp col mult
	fmul	st, st(3)		;; Compute next ttmp
	fxch	st(1)			;; val,ttmp,ttpg,ttmpg,ttp,carry
	fstp	QWORD PTR [esi+7*dist1]	;; Save value
	lea	ecx, [ecx+nextdist]	;; U - Next source
	lea	esi, [esi+nextdist]	;; V - Next dest
	ENDM


; *************** normalized add and sub macro ******************
; This macro adds and subtracts, then "normalizes" eight FFT
; data values.  This involves multiplying the summed values by
; two-to-minus-phi.  Rounding the value to an integer.  Making sure
; the integer is smaller than the maximum allowable integer, generating
; a carry if necessary. Finally, the value is multiplied by two-to-phi
; and stored.
; st(0) = ttmp
; st(1) = ttpg
; st(2) = ttmpg
; st(3) = ttp
; st(4) = sub carry
; st(5) = add carry
; ecx = pointer to first number
; edx = pointer to second number (difference)
; esi = destination #1
; ebp = destination #2 (difference)
; edi = pointer two-to-power multipliers
; eax = the big vs. little word flag
; ebx = big vs. little running sum
; NOTE:  Pops edx (assumes the caller pushed edx)
; A pipelined version of this code:
;	fld	QWORD PTR [ecx+0*dist1][edx];; Load source
;	fadd	QWORD PTR [ecx+0*dist1]	;; Add in the second source
;	fld	QWORD PTR [ecx+0*dist1][edx];; Load source
;	fsub	QWORD PTR [ecx+0*dist1]	;; Subtract out the second source
;	fmul	st(1), st		;; Mul value by two-to-minus-phi
;	fmulp	st(1), st		;; Mul value by two-to-minus-phi
;	faddp	st(4), st		;; x1 = value + carry
;	faddp	st(4), st		;; x2 = value + carry
;	fld	limit_bigmax[eax*8]	;; y1 = rounding const
;	fld	limit_bigmax[eax*8]	;; y2 = rounding const
;	fadd	st, st(4)		;; y1 = top bits of x1
;	fadd	st, st(4)		;; y2 = top bits of x2
;	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
;	fsubr	st, st(3)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
;	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
;	fsubr	st, st(3)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
;	fsubp	st(6), st		;; rounded value = x1 - z1
;	fsubp	st(6), st		;; rounded value = x2 - z2
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
;	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
;	fmul	st(5), st		;; new value = val1 * two-to-phi
;	fmulp	st(5), st		;; new value = val2 * two-to-phi
;	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
;	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
;	fld	QWORD PTR [edi+0*16]	;; Load next two-to-phi
;	fmul	st, st(2)		;; Compute next two-to-phi
;	fld	QWORD PTR [edi+0*16+8]	;; Load next two-to-minus-phi col mult
;	fmul	st, st(5)		;; Compute next two-to-minus-phi
;	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
;	sbb	eax, eax		;;*U - next big vs. little flag
;	fstp	QWORD PTR [esi+0*dist1]	;; Save the value
;	fstp	QWORD PTR [esi+0*dist1][ebp];; Save the value

norm_addsub MACRO nextdist		;; ttmp,ttpg,ttmpg,ttp,c2,c1
	fld	QWORD PTR [ecx+0*dist1]	;; Load source
	fadd	QWORD PTR [ecx+0*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+0*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+0*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+0*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+0*dist1]	;; Save the value
	fld	QWORD PTR [edi+0*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+0*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+1*dist1]	;; Load source
	fadd	QWORD PTR [ecx+1*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+1*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+1*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+1*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+1*dist1]	;; Save the value
	fld	QWORD PTR [edi+1*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+1*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+2*dist1]	;; Load source
	fadd	QWORD PTR [ecx+2*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+2*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+2*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+2*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+2*dist1]	;; Save the value
	fld	QWORD PTR [edi+2*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+2*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+3*dist1]	;; Load source
	fadd	QWORD PTR [ecx+3*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+3*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+3*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+3*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+3*dist1]	;; Save the value
	fld	QWORD PTR [edi+3*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+3*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+4*dist1]	;; Load source
	fadd	QWORD PTR [ecx+4*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+4*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+4*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+4*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+4*dist1]	;; Save the value
	fld	QWORD PTR [edi+4*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+4*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+5*dist1]	;; Load source
	fadd	QWORD PTR [ecx+5*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+5*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+5*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+5*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+5*dist1]	;; Save the value
	fld	QWORD PTR [edi+5*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+5*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+6*dist1]	;; Load source
	fadd	QWORD PTR [ecx+6*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+6*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+6*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+6*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+6*dist1]	;; Save the value
	fld	QWORD PTR [edi+6*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+6*dist1][ebp];; Save the value
	sub	ebx, scaled_numbig	;; UU - Adjust scaled counter
	sbb	eax, eax		;;*U - next big vs. little flag

	fld	QWORD PTR [ecx+7*dist1]	;; Load source
	fadd	QWORD PTR [ecx+7*dist1][edx];; Add in the second source
	fld	QWORD PTR [ecx+7*dist1][edx];; Load source
	fsub	QWORD PTR [ecx+7*dist1]	;; Subtract out the second source
	fxch	st(1)			;; v1,v2,ttmp,ttpg,ttmpg,ttp,c2,c1
	fmul	st, st(2)		;; Mul value by two-to-minus-phi
	fxch	st(1)			;; v2,v1,ttmp,ttpg,ttmpg,ttp,c2,c1
	pop	edx			;; U - Restore edx (pushed by caller)
	lea	ecx, [ecx+nextdist]	;; V - Next source
	fmulp	st(2), st		;; Mul value by two-to-minus-phi
	faddp	st(6), st		;; x1 = value + carry
	fld	limit_bigmax[eax*8]	;; y1 = rounding const
	fxch	st(1)			;; v2,y1,ttpg,ttmpg,ttp,c2,x1
	faddp	st(5), st		;; x2 = value + carry
	fxch	st(1)			;; ttpg,y1,ttmpg,ttp,x2,x1
	fmul	limit_ttp_mult[eax*4]	;; Adjust next two-to-phi grp mult
	fxch	st(1)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(5)		;; y1 = top bits of x1
	fxch	st(2)			;; ttmpg,ttpg,y1,ttp,x2,x1
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; y1,ttpg,ttmpg,ttp,x2,x1
	fld	limit_bigmax[eax*8]	;; y2 = rounding const
	fld	limit_bigmax[eax*8]	;; z1 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z1 = y1-(maximum * BIGVAL - BIGVAL)
	fxch	st(1)			;; y2,z1,y1,ttpg,ttmpg,ttp,x2,x1
	fadd	st, st(6)		;; y2 = top bits of x2
	fxch	st(2)			;; y1,z1,y2,ttpg,ttmpg,ttp,x2,x1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y1
	fxch	st(7)			;; x1,z1,y2,ttpg,ttmpg,ttp,x2,c1
	fsubrp	st(1), st		;; rounded value = x1 - z1
	fld	limit_bigmax[eax*8]	;; z2 = maximum * BIGVAL - BIGVAL
	fsubr	st, st(2)		;; z2 = y2-(maximum * BIGVAL - BIGVAL)
	fxch	st(2)			;; y2,v1,z2,ttpg,ttmpg,ttp,x2,c1
	fmul	limit_inverse[eax*8]	;; next carry = shifted y2
	fxch	st(6)			;; x2,v1,z2,ttpg,ttmpg,ttp,c2,c1
					;; STALL
	fsubrp	st(2), st		;; rounded value = x2 - z2
	fmul	st, st(4)		;; new value = val1 * two-to-phi
	fld	QWORD PTR [edi+7*16]	;; Load next two-to-phi
	fmul	st, st(3)		;; Compute next two-to-phi
					;; STALL
	fxch	st(5)			;; ttp,v1,v2,ttpg,ttmpg,nxtttp,c2,c1
	fmulp	st(2), st		;; new value = val2 * two-to-phi
	fstp	QWORD PTR [esi+7*dist1]	;; Save the value
	fld	QWORD PTR [edi+7*16+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; v2,nxtttmp,ttpg,ttmpg,nxtttp,c2,c1
	fstp	QWORD PTR [esi+7*dist1][ebp];; Save the value
	mov	eax, scaled_numbig	;; U - Adjust scaled counter
	lea	edi, [edi+8*16]		;; V - Next set of 8 multipliers
	sub	ebx, eax		;; U - Adjust scaled counter
	lea	esi, [esi+nextdist]	;; V - Next dest
	sbb	eax, eax		;; U - next big vs. little flag
	ENDM


; *************** error_check macro ******************
; This macro finds the maximum error (distance from an integer).
; st(0) = The current maximum error
; esi = pointer to the FFT data values
; ebx = pointer two-to-phi multipliers

simple_error_check MACRO
	LOCAL	less
	fld	QWORD PTR [esi]		;; Load value
	fmul	QWORD PTR [ebx+8]	;; Mul by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(1), st		;; This is the error
	fabs
	fcom	st(1)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less		;; Error is less than maximum
	fxch	st(1)			;; Error is greater - swap with maximum
less:	fcomp	st			;; Pop non-maximum
	ENDM


; *************** error_check macro ******************
; This macro finds the maximum error (distance from an integer).
; st(2) = The current maximum error
; st(1) = two-to-minus-phi group multiplier
; st(0) = two-to-minus-phi multiplier
; esi = pointer to the FFT data values
; ebx = pointer two-to-power column multipliers
; edx = pointer two-to-power group multipliers
; ebp = number of big words
; edi = big vs. little running sum
; eax = this big vs. little word flag

error_check MACRO
	LOCAL	less1, less2, less3, less4, less5, less6, less7, less8

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi]		;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less1		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less1:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+24]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less2		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less2:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+2*dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less3		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less3:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+3*dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+32+24]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less4		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less4:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+4*dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+2*32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less5		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less5:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+5*dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+2*32+24];; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less6		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less6:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+6*dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+3*32+8]	;; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less7		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less7:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

					;; ttmp,ttmpg,maxerr
	fmul	QWORD PTR [esi+7*dist1]	;; Mul value by two-to-minus-phi
	fld	BIGVAL			;; bigval,value,ttmpg,maxerr
	fxch	st(2)			;; ttmpg,value,bigval,maxerr
	fmul	limit_ttmp_mult[eax*4]	;; Adjust nxt two-to-minus-phi grp mult
	fxch	st(2)			;; bigval,value,ttmpg,maxerr
	fadd	st, st(1)		;; Round off the value - step 1
	fld	QWORD PTR [ebx+3*32+24];; Load next two-to-minus-phi col mult
	fmul	st, st(3)		;; Compute next two-to-minus-phi
	fxch	st(1)			;; intval,nxtttmp,value,ttmpg,maxerr
	fsub	BIGVAL			;; Round off the value - step 2
	fsubp	st(2), st		;; This is the error
	fxch	st(1)			;; error,nxtttmp,ttmpg,maxerr
	fabs
	fcom	st(3)			;; Compare to maximum error
	fstsw	ax			;; Copy comparison results
	and	eax, 100h		;; Isolate C0 bit
	jnz	short less8		;; Error is less than maximum
	fxch	st(3)			;; Error is greater - swap with maximum
less8:	fcomp	st(3)			;; Pop non-maximum
	sub	edi, ebp		;; U - 2 steps to compute
	sbb	eax, eax		;;*U - next big vs. little flag
					;; nxtttmp,ttmpg,maxerr

	ENDM
