; Copyright 1998-2000 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;

; ********************************************************
; ********************************************************
; ********************  FFT MACROS  **********************
; ********************************************************
; ********************************************************


fft32 MACRO type
	LOCAL	b1b, b4b, c1b

;; Do 4 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * dist1
;;	do 4 iterations

	IF	type NE 4
	mov	al, 4			;; U - 4 iterations
b1b:	disp eight_reals_first_fft, 4*dist1, 8*dist1, 16*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1]	;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft_2 operations (FFT levels 4,5)
;; Distance between fft data elements is dist1

	IF	type EQ 1
	disp eight_reals_fft_2, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_2, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_2, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_2, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 3 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is dist1
;;	do 3 iterations

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations
	IF	type EQ 1
b4b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b4b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b4b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b4b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b4b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn32
	ENDIF
	IF	type EQ 3
	JMP_X	cmn32
	ENDIF

;; Do 4 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 4 * dist1
;;	do 4 iterations

	IF	type EQ 4
cmn32:	lea	esi, [esi-32*dist1+128]	;; U - restore source pointer
c1b:	dispc eight_reals_last_unfft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft32p MACRO type
	LOCAL	b1b, b4b, c1b

;; Do 4 four_complex_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 4 * dist1
;;	do 4 iterations

	IF type NE 4
	mov	edi, plus1_premults	;; Address of the multipliers
	mov	al, 4			;; U - 4 iterations
b1b:	disp four_complex_first_fft, 4*dist1, 8*dist1, 16*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	JNZ_X	b1b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist1]	;; U - Load source pointer
	ENDIF

;; Do 4 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is dist1
;;	do 4 iterations

	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations
	IF	type EQ 1
b4b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b4b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b4b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b4b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b4b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn32p
	ENDIF
	IF	type EQ 3
	JMP_X	cmn32p
	ENDIF

;; Do 4 four_complex_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 4 * dist1
;;	do 4 iterations

	IF type EQ 4
cmn32p:	lea	esi, [esi-32*dist1+128]	;; U - restore source pointer
	mov	edi, plus1_premults	;; Address of the multipliers
c1b:	dispc four_complex_last_unfft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	add	al, 256/4		;; U - Test loop counter
	JNC_X	c1b			;; V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft40 MACRO type
	LOCAL	b1b, b2b, b3b, c1b, c2b

;; Do 8 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	IF	type NE 4
	mov	al, 8			;; V - 8 iterations
b1b:	disp five_reals_first_fft, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary

;; Do 4 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 2 iterations of 2

;;	lea	esi, [esi-8*dist1+8*dist1];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 2			;; V - 2 iterations of 2
b2b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	JNZ_X	b2b			;; V - Iterate if necessary
	lea	esi, [esi-40*dist1]	;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is dist1
;;	do 1 iterations

	IF	type EQ 1
	disp eight_reals_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_3, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 8 two_complex_fft macros (FFT levels 6)
;;	distance between fft data elements is dist1
;;	do 4 iterations

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	al, 4			;; V - 4 iterations
	IF	type EQ 1
b3b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b3b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b3b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	mov	edi, sincos2		;; U - Load sin/cos pointer
b3b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b3b			;;*V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn40
	ENDIF
	IF	type EQ 3
	JMP_X	cmn40
	ENDIF

;; Do 4 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 2 iterations of 2

	IF	type EQ 4
cmn40:	lea	esi, [esi-40*dist1+8*dist1];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 2			;; V - 2 iterations of 2
c2b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c2b			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c2b			;; V - Iterate if necessary

;; Do 8 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	lea	esi, [esi-40*dist1+128]	;; U - Load source pointer
c1b:	dispc five_reals_last_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft48 MACRO type
	LOCAL	b1b, b2b, b3b, c1b, c2b

;; Do 8 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	IF	type NE 4
	mov	al, 8			;; V - 8 iterations
b1b:	disp six_reals_first_fft, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary

;; Do 4 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 2 iterations of 2

	lea	esi, [esi-8*dist1+16*dist1];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 2			;; V - 2 iterations of 2
b2b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b2b			;; V - Iterate if necessary
	lea	esi, [esi-48*dist1]	;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is dist1
;;	do 1 iterations

	IF	type EQ 1
	disp eight_reals_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_3, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 8 real values into 4 complex values.
;; Do 1 four_complex_fft operations (FFT levels 5,6)
;; Distance between fft data elements is dist1

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	IF	type EQ 1
	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	mov	edi, sincos2		;; U - Load sin/cos pointer
	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 8 two_complex_fft macros (FFT levels 6)
;;	distance between fft data elements is dist1
;;	do 4 iterations

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	mov	al, 4			;; V - 4 iterations
	IF	type EQ 1
b3b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b3b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b3b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b3b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn48
	ENDIF
	IF	type EQ 3
	JMP_X	cmn48
	ENDIF

;; Do 4 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 2 iterations of 2

	IF	type EQ 4
cmn48:	lea	esi, [esi-48*dist1+16*dist1];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 2			;; V - 2 iterations of 2
c2b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c2b			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c2b			;; V - Iterate if necessary

;; Do 8 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	lea	esi, [esi-48*dist1+128]	;; U - Load source pointer
c1b:	dispc six_reals_last_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft56 MACRO type
	LOCAL	b1b, b2b, b3b, c1b, c2b

;; Do 8 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	IF	type NE 4
	mov	al, 8			;; V - 8 iterations
b1b:	disp seven_reals_first_fft, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary

;; Do 6 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 3 iterations of 2

;;	lea	esi, [esi-8*dist1+8*dist1];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations of 2
b2b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b2b			;; V - Iterate if necessary
	lea	esi, [esi-56*dist1]	;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is dist1
;;	do 1 iterations

	IF	type EQ 1
	disp eight_reals_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_3, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 12 two_complex_fft macros (FFT levels 6)
;;	distance between fft data elements is dist1
;;	do 6 iterations

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	al, 6			;; V - 6 iterations
	IF	type EQ 1
b3b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b3b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b3b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	mov	edi, sincos2		;; U - Load sin/cos pointer
b3b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b3b			;;*V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn56
	ENDIF
	IF	type EQ 3
	JMP_X	cmn56
	ENDIF

;; Do 4 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 3 iterations of 2

	IF	type EQ 4
cmn56:	lea	esi, [esi-56*dist1+8*dist1];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations of 2
c2b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c2b			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c2b			;; V - Iterate if necessary

;; Do 8 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	lea	esi, [esi-56*dist1+128]	;; U - Load source pointer
c1b:	dispc seven_reals_last_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft64 MACRO type
	LOCAL	b1b, b2b, b3b, c1b, c2b

;; Do 8 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	IF	type NE 4
	mov	al, 8			;; V - 8 iterations
b1b:	disp eight_reals_first_fft, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary

;; Do 6 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 3 iterations of 2

	lea	esi, [esi-8*dist1+16*dist1];; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations of 2
b2b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b2b			;; V - Iterate if necessary
	lea	esi, [esi-64*dist1]	;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is dist1
;;	do 1 iterations

	IF	type EQ 1
	disp eight_reals_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_3, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_3, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 8 real values into 4 complex values.
;; Do 1 four_complex_fft operations (FFT levels 5,6)
;; Distance between fft data elements is dist1

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	mov	edi, sincos_real	;; V - Load sin/cos pointer
	IF	type EQ 1
	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 12 two_complex_fft macros (FFT levels 6)
;;	distance between fft data elements is dist1
;;	do 6 iterations

	lea	esi, [esi+8*dist1]	;; U - Load source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	mov	al, 6			;; V - 6 iterations
	IF	type EQ 1
b3b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b3b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b3b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b3b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn64
	ENDIF
	IF	type EQ 3
	JMP_X	cmn64
	ENDIF

;; Do 6 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 2 * dist1
;;	do 3 iterations of 2

	IF	type EQ 4
cmn64:	lea	esi, [esi-64*dist1+16*dist1];; U - Load source pointer
	mov	edi, sincos_real	;; U - Load sin/cos pointer
	mov	al, 3			;; V - 3 iterations of 2
c2b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c2b			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c2b			;; V - Iterate if necessary

;; Do 8 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	lea	esi, [esi-64*dist1+128]	;; U - Load source pointer
c1b:	dispc eight_reals_last_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/8		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft64p MACRO type
	LOCAL	b1b, b2b, b3b, c1b, c2b

;; Do 8 four_complex_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	IF type NE 4
	mov	edi, plus1_premults	;; Address of the multipliers
	mov	al, 8			;; V - 8 iterations
b1b:	disp four_complex_first_fft, 8*dist1, 16*dist1, 32*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	JNZ_X	b1b			;; V - Iterate if necessary

;; Do 8 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 2 * dist1
;;	do 4 iterations of 2

	lea	esi, [esi-8*dist1]	;; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 2
b2b:	disp four_complex_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	b2b			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; V - Test outer loop counter
	JNZ_X	b2b			;; V - Iterate if necessary
	lea	esi, [esi-64*dist1]	;; U - Load source pointer
	ENDIF

;; Do 16 two_complex_fft macros (FFT levels 5)
;;	distance between fft data elements is dist1
;;	do 8 iterations

	mov	edi, sincos_complex	;; V - sine/cosine pointer
	mov	al, 8			;; V - 8 iterations
	IF	type EQ 1
b3b:	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b3b:	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b3b:	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b3b:	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b3b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn64p
	ENDIF
	IF	type EQ 3
	JMP_X	cmn64p
	ENDIF

;; Do 8 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 2 * dist1
;;	do 4 iterations of 2

	IF	type EQ 4
cmn64p:	lea	esi, [esi-64*dist1]	;; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 2
c2b:	disp four_complex_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test inner loop counter
	JNC_X	c2b			;; V - Iterate if necessary
	lea	esi, [esi-2*dist1+16*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c2b			;; V - Iterate if necessary

;; Do 8 four_complex_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 8 * dist1
;;	do 8 iterations

	lea	esi, [esi-64*dist1+128]	;; U - Load source pointer
	mov	edi, plus1_premults	;; V - Address of the multipliers
c1b:	dispc four_complex_last_unfft, 8*dist1, 16*dist1, 32*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	add	al, 256/8		;; U - Test loop counter
	JNC_X	c1b			;; V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft80 MACRO type
	LOCAL	b1b, c1b

;; Do 16 five_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type NE 4
	mov	al, 16			;; V - 16 iterations
b1b:	disp five_reals_first_fft, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1]	;; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn128_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end80
	JMP_X	cmn128_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end80
	JMP_X	cmn128_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn128_4
	ENDIF

;; Do 16 five_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type EQ 4
end80:	lea	esi, [esi-80*dist1]	;; U - Load source pointer
c1b:	dispc five_reals_last_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft96 MACRO type
	LOCAL	b1b, c1b, c2b

;; Do 16 six_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type NE 4
	mov	al, 16			;; V - 16 iterations
b1b:	disp six_reals_first_fft, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 16*dist1
	IF	type EQ 1
	JMP_X	cmn128a_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end96
	JMP_X	cmn128a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end96
	JMP_X	cmn128a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn128a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.

;; Do 4 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 4*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end96:	lea	esi, [esi-96*dist1-128+16*dist1] ;; U - Load source pointer
c2b:	disp two_two_complex_unfft_2, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 16 six_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	lea	esi, [esi-2*dist1-16*dist1+128];; U - Load source pointer
c1b:	dispc six_reals_last_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft112 MACRO type
	LOCAL	b1b, c1b

;; Do 16 seven_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type NE 4
	mov	al, 16			;; V - 16 iterations
b1b:	disp seven_reals_first_fft, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	lea	esi, [esi-16*dist1]	;; U - Restore source pointer
	ENDIF

;; Call common code to perform the rest of the FFT

	sub	ecx, ecx
	IF	type EQ 1
	JMP_X	cmn128_1
	ENDIF
	IF	type EQ 2
	push	OFFSET end112
	JMP_X	cmn128_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end112
	JMP_X	cmn128_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn128_4
	ENDIF

;; Do 16 seven_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type EQ 4
end112:	lea	esi, [esi-112*dist1]	;; U - Load source pointer
c1b:	dispc seven_reals_last_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM


fft128 MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b6b, c1b, c2a, c2b, c3b

;; Do 16 eight_reals_first_fft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF	type NE 4
	mov	al, 16			;; V - 16 iterations
b1b:	disp eight_reals_first_fft, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	dec	al			;; V - Test loop counter
	JNZ_X	b1b			;;*V - Iterate if necessary
	ENDIF

;; Call common code to perform the rest of the FFT

	mov	ecx, 16*dist1
;;	IF	type EQ 1
;;	JMP_X	cmn128a_1		;; Fall through to cmn128a_1
;;	ENDIF
	IF	type EQ 2
	push	OFFSET end128
	JMP_X	cmn128a_2
	ENDIF
	IF	type EQ 3
	push	OFFSET end128
	JMP_X	cmn128a_3
	ENDIF
	IF	type EQ 4
	CALL_X	cmn128a_4
	ENDIF

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.

;; Do 4 two_complex_unfft operations (FFT levels 5)
;; Distance between fft data elements is 4*dist1
;; However, for better pipelining we merge two two_complex_unfft operations
;; into a single two_two_complex_unfft macro that operates on two
;; independent sets of 4 data values.

	IF	type EQ 4
end128:	lea	esi, [esi-128*dist1-128+16*dist1] ;; U - Load source pointer
c2a:	disp two_two_complex_unfft_2, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	c2a			;;*V - Iterate if necessary

;; Do 16 eight_reals_last_unfft macros (FFT levels 1,2,3)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	lea	esi, [esi-2*dist1-16*dist1+128];; U - Load source pointer
c1b:	dispc eight_reals_last_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/16		;; V - Test loop counter
	JNC_X	c1b			;;*V - Iterate if necessary
	fft_3_ret
	ENDIF

;;
;; Common code to perform the rest of the FFT
;; Note - this first chunk is only done for fft96 and fft128
;;

cmn128a_&type:

;; Do nothing (FFT level 4)
;; This will turn these 16 real values into 8 complex values.

;; Do 4 two_complex_fft operations (FFT levels 5)
;; Distance between fft data elements is 4*dist1
;; However, for better pipelining we merge two two_complex_fft operations
;; into a single two_two_complex_fft macro that operates on two
;; independent sets of 4 data values.

	IF	type NE 4
b2a:	disp two_two_complex_fft_2, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	b2a			;;*V - Iterate if necessary
	lea	esi, [esi-2*dist1-16*dist1];; Restore source pointer
	ENDIF

;; Entry point for fft80 and fft112

cmn128_&type:

;; Do 2 eight_reals_fft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * dist1
;;	do 2 iterations

	IF	type NE 4
b2b:	disp eight_reals_fft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	b2b			;;*V - Iterate if necessary

;; Do 8/12 four_complex_fft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * dist1
;;	do 2/3 iterations of 4

	lea	esi, [esi-2*dist1+16*dist1+128][ecx];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 4
b3b:	dispc four_complex_fft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary
	mov	esi, _DESTARG		;; U - Load source pointer
	ENDIF

;; Do 1 eight_reals_fft_1 macros (FFT level 7)
;;	distance between fft data elements is dist1
;;	1 iterations

	IF	type EQ 1
	disp eight_reals_fft_1, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp eight_reals_with_square_1, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp eight_reals_with_mult_1, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp eight_reals_with_mulf_1, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 1 two_two_complex_fft macros (FFT level 7)
;;	distance between fft data elements is dist1

	lea	esi, [esi+8*dist1]	;; U - Restore source ptr
	mov	edi, sincos2		;; U - Load sin/cos pointer
	IF	type EQ 1
	disp two_two_complex_fft_n, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
	disp two_two_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
	disp two_two_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
	disp two_two_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF

;; Do 8/10/12/14 four_complex_fft macros (FFT levels 6,7)
;;	distance between fft data elements is dist
;;	do 8/10/12/14 iterations

	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	mov	eax, count2		;; V - 8/10/12/14 iterations
	IF	type EQ 1
b6b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b6b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b6b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b6b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b6b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn128
	ENDIF
	IF	type EQ 3
	JMP_X	cmn128
	ENDIF

;; Do 2 eight_reals_unfft operations (FFT levels 4,5,6)
;; Distance between fft data elements is 2 * dist1
;;	do 2 iterations

	IF	type EQ 4
cmn128:	mov	esi, _DESTARG		;; U - Load source pointer
c2b:	disp eight_reals_unfft, 2*dist1, 4*dist1, 8*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/2		;; V - Test loop counter
	JNC_X	c2b			;;*V - Iterate if necessary

;; Do 8/12 four_complex_unfft macros (FFT levels 4,5)
;;	distance between fft data elements is 4 * dist1
;;	do 2/3 iterations of 4

	lea	esi, [esi-2*dist1+16*dist1+128][ecx];; U - Load source pointer
	mov	edi, sincos1		;; U - Load sin/cos pointer
	mov	eax, count1		;; V - 2/3 iterations of 4
c3b:	dispc four_complex_unfft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary
	retn				;; return from common code
	ENDIF
	ENDM

fft128p MACRO type
	LOCAL	b1b, b2a, b2b, b3b, b6b, c1b, c2a, c2b, c3b

;; Do 16 four_complex_fft macros (FFT levels 1,2)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	IF type NE 4
	mov	edi, plus1_premults	;; Address of the multipliers
	mov	al, 16			;; V - 16 iterations
b1b:	disp four_complex_first_fft, 16*dist1, 32*dist1, 64*dist1
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	dec	al			;; U - Test loop counter
	JNZ_X	b1b			;; V - Iterate if necessary

;; Do 16 four_complex_fft macros (FFT levels 3,4)
;;	distance between fft data elements is 4 * dist1
;;	do 4 iterations of 4

	lea	esi, [esi-16*dist1+128]	;; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 4
b3b:	dispc four_complex_fft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	b3b			;;*V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	b3b			;; V - Iterate if necessary
	lea	esi, [esi-128*dist1-128];; U - Load source pointer
	ENDIF

;; Do 16 four_complex_fft macros (FFT levels 5,6)
;;	distance between fft data elements is dist
;;	do 16 iterations

	mov	edi, sincos_complex	;; V - Sine/cosine pointer
	mov	al, 16			;; V - 16 iterations
	IF	type EQ 1
b6b:	disp four_complex_fft, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 2
b6b:	disp four_complex_with_square, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 3
b6b:	disp four_complex_with_mult, dist1, 2*dist1, 4*dist1
	ENDIF
	IF	type EQ 4
b6b:	disp four_complex_with_mulf, dist1, 2*dist1, 4*dist1
	ENDIF
	lea	esi, [esi+8*dist1]	;; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test loop counter
	JNZ_X	b6b			;; V - Iterate if necessary

;; Share the inverse transform code

	IF	type EQ 2
	JMP_X	cmn128p
	ENDIF
	IF	type EQ 3
	JMP_X	cmn128p
	ENDIF

;; Do 16 four_complex_unfft macros (FFT levels 3,4)
;;	distance between fft data elements is 4 * dist1
;;	do 4 iterations of 4

	IF type EQ 4
cmn128p:lea	esi, [esi-128*dist1+128];; U - Load source pointer
	mov	edi, sincos_complex	;; U - Load sin/cos pointer
	mov	al, 4			;; V - 4 iterations of 4
c3b:	dispc four_complex_unfft, 4*dist1, 8*dist1, 16*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	add	al, 256/4		;; V - Test inner loop counter
	JNC_X	c3b			;; V - Iterate if necessary
	lea	esi, [esi-4*dist1+32*dist1];; U - Next source pointer
	lea	edi, [edi+SCD]		;; V - Next sine/cosine pointer
	dec	al			;; U - Test outer loop counter
	JNZ_X	c3b			;; V - Iterate if necessary

;; Do 16 four_complex_unfft macros (FFT levels 1,2)
;;	distance between fft data elements is 16 * dist1
;;	do 16 iterations

	lea	esi, [esi-128*dist1]	;; U - Load source pointer
	mov	edi, plus1_premults	;; V - Address of the multipliers
c1b:	dispc four_complex_last_unfft, 16*dist1, 32*dist1, 64*dist1, -128
	lea	esi, [esi+dist1]	;; U - Next source pointer
	lea	edi, [edi+64]		;; V - Next multipliers
	add	al, 256/16		;; U - Test loop counter
	JNC_X	c1b			;; V - Iterate if necessary
	fft_3_ret
	ENDIF
	ENDM

