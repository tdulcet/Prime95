; Copyright 2001 - Just For Fun Software, Inc., all rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros take the basic XMM FFT building blocks and build even
; larger building blocks used in the final pass of a multi-pass FFT.
;

; ********************************************************
; ********************************************************
; *******************  PASS 2 MACROS  ********************
; ********************************************************
; ********************************************************


; The goal of this pass is to perform the last FFT levels.
;
; To reduce the amount of sine-cosine data we read in from
; main memory, we pre-multiply each set of values by a different
; set of sine-cosine values and then perform a standard 11-level
; FFT on each 2 sets of 2048 complex values.  The root of this idea
; comes from articles by David Bailey available on the web.

;; esi = destination pointer
;; ebx = distance from esi to source (zero for types 2, 3)
;; ebp = distance from esi to multiplier (zero for types 1, 2)
;; ecx = number of complex 2nd passes remaining
;; edx = premultiplier data

;; On entry the 64KB block (1024 64-byte cache lines) has these FFT
;; data values (high word of xmm registers being 1K greater than the low word):
;;	0	+1K	2048	+1K	4096	+1K	6144	+1K
;;	1	...
;;	...
;;	1023	...


; *************** xmm-pass2-11-levels-real macro ******************
; This macro takes 2048 real values, 2048 semi-real values and the
; first 2048 complex values and performs the final 11 levels of the
; FFT process, squares the results, and does the first 11 levels of
; the inverse FFT.

xpass2_11_levels_real MACRO incr
	LOCAL	b0b, b0d, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	baa, bab, bac, bad
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b

;; We switch to the same format used in one-pass FFTs (that is, the
;; high word of xmm registers being 1 greater than the low word):

;; Load the TLBs for this data set and the next data set.
;; This data set is spread over 16 pages (64KB), the next data set also
;; takes 16 pages (64KB), and we touch one more page because the data
;; sets do not start on exact on 4KB boudaries.

	mov	al, 2			;; Load loop counter
b0b:	mov	edi, [esi]		;; Read from this page (loads the TLB)
	lea	esi, [esi+4096]		;; Next page
	add	al, 256/16		;; Test loop counter
	jnc	short b0b		;; Iterate if necessary
	lea	esi, [esi-16*4096+blkdst];; Next block
	sub	al, 1			;; Test outer loop counter
	jnz	short b0b		;; Iterate if necessary
	mov	edi, [esi-blkdst+16*4096-128];; Read from last page
	lea	esi, [esi-2*blkdst]	;; Next source pointer

;; Type 4 FFTs skip the forward FFT process

	cmp	ffttype, 4
	JE_X	xpass2_11_levels_real_4

;; Do FFT level 1
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+1K	2048	+1K	4096	+1K	6144	+1K
;;	1	...
;;	...
;;	1023	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	1024	1025	2048	2049	3172	3173
;;	4096	...
;;	2	...
;;	...
;;	1022	...
;;	5118	...

;; Do eight_reals_fft_1 on real values 0 - 2047
;; Do nothing on semi-real values from 2048 - 4095
;; Do two_complex_fft on complex values from 4096 - 8191
;;	distance between fft data elements is 1K
;;	do 256 iterations

	mov	eax, 512		;; Load loop counter
b1b:	s2cl_eight_reals_fft_1 esi, 2*64, 64
	prefetcht1 [esi+7*128]		;; Prefetch a few iterations ahead
	sub	eax, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-512*2*64]	;; Restore source pointer

;; Do FFT levels 2,3
;; Values 0-1023 is real data, 1024-2047 is semi-real data, 2048-8191 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	1024	1025	2048	2049	3172	3173
;;	4096	...
;;	2	...
;;	...
;;	1022	...
;;	5118	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	256	257	512	513	768	769
;;	4096	...
;;	2	...
;;	...
;;	254	...
;;	4350	...
;;	1024	...
;;	...

;; Do 128 eight_reals_fft_2 macros
;; Do 128 nop_two_two_complex_fft_2 macros
;; Do 256 four_complex_fft macros
;;	distance between fft data elements is 256
;;	do 128 macros each processing 32 data values

	mov	edi, sincos10		;; Load sin/cos pointer
b2b:	x4cl_eight_reals_fft_2 esi, 2*64, 256*64, 512*64
	add	al, 256/128		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary

;; Do 512 four_complex_fft macros
;;	distance between fft data elements is 256
;;	do 128 macros each processing 32 data values

	lea	ecx, [esi+blkdst]	;; Prefetch pointer
	lea	esi, [esi-128*2*64+64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 2*64, 256*64, 512*64
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/128		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	lea	esi, [esi-128*2*64-64]	;; Restore source pointer

;; Do FFT levels 4,5
;; Values 0-255 is real data, 256-511 is semi-real data, 512-8191 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	256	257	512	513	768	769
;;	4096	...
;;	2	...
;;	...
;;	254	...
;;	4350	...
;;	1024	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	64	65	128	129	192	193
;;	4096	...
;;	2	...
;;	...
;;	62	...
;;	4158	...
;;	256	...
;;	...

;; Do 32 eight_reals_fft_2 macros
;; Do 32 nop_two_two_complex_fft_2 macros
;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 64
;;	do 32 macros each processing 32 data values

	mov	edi, sincos9		;; Load sin/cos pointer
b4b:	x4cl_eight_reals_fft_2 esi, 2*64, 64*64, 128*64
	add	al, 256/32		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary

;; Do 896 four_complex_fft macros
;;	distance between fft data elements is 64
;;	do 224 macros each processing 32 data values

	lea	esi, [esi-32*2*64+256*64];; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 3			;; 3 then 4 iterations of 32
b5b:	x4cl_four_complex_fft esi, 2*64, 64*64, 128*64
	add	al, 256/32		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	lea	esi, [esi-32*2*64+256*64];; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*256*64+64]	;; Next source pointer
	mov	al, 4			;; 4 more iterations of 32
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	b5b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 6,7
;; Values 0-63 is real data, 64-127 is semi-real data, 128-8191 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	64	65	128	129	192	193
;;	4096	...
;;	2	...
;;	...
;;	62	...
;;	4158	...
;;	256	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	16	17	32	33	48	49
;;	4096	...
;;	2	...
;;	...
;;	14	...
;;	4110	...
;;	64	...
;;	...

;; Do 8 eight_reals_fft_2 macros
;; Do 8 nop_two_two_complex_fft_2 macros
;; Do 16 four_complex_fft macros
;;	distance between fft data elements is 16
;;	do 8 macros each processing 32 data values

	mov	edi, sincos8		;; Load sin/cos pointer
b6b:	x4cl_eight_reals_fft_2 esi, 2*64, 16*64, 32*64
	add	al, 256/8		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary

;; Do 992 four_complex_fft macros
;;	distance between fft data elements is 16
;;	do 248 macros each processing 32 data values

	lea	esi, [esi-8*2*64+64*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 15			;; 15 then 16 iterations of 8
b7b:	x4cl_four_complex_fft esi, 2*64, 16*64, 32*64
	add	al, 256/8		;; Test inner loop counter
	JNC_X	b7b			;; Iterate if necessary
	lea	esi, [esi-8*2*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b7b			;; Iterate if necessary
	lea	esi, [esi-16*64*64+64]	;; Next source pointer
	mov	al, 16			;; 16 more iterations of 8
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	b7b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 8,9
;; Values 0-15 is real data, 16-31 is semi-real data, 32-8191 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	16	17	32	33	48	49
;;	4096	...
;;	2	...
;;	...
;;	14	...
;;	4110	...
;;	64	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	4	5	8	9	12	13
;;	4096	...
;;	2	...
;;	4098	...
;;	16	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 4
;;	do 2 macros each processing 32 data values

	mov	edi, sincos7		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 2*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 1016 four_complex_fft macros
;;	distance between fft data elements is 4
;;	do 254 macros each processing 32 data values

	lea	esi, [esi-2*2*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 63			;; 63 then 64 iterations of 2
b9b:	x4cl_four_complex_fft esi, 2*64, 4*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	b9b			;; Loop if necessary
	lea	esi, [esi-2*2*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-64*16*64+64]	;; Next source pointer
	mov	al, 64			;; 64 more iterations of 2
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	b9b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 10,11
;; Values 0-3 is real data, 4-7 is semi-real data, 8-8191 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	4	5	8	9	12	13
;;	4096	...
;;	2	...
;;	4098	...
;;	16	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	2	3	4	5	6	7
;;	4096	...
;;	8	...
;;	...

;; Do 1/2 eight_reals_fft_2 macros
;; Do 1/2 nop_two_two_complex_fft_2 macros
;; Do 1 four_complex_fft macros
;;	distance between fft data elements is 1

;; Do 1022 more four_complex_fft macros
;;	distance between fft data elements is 1
;;	do 511 macros each processing 16 data values

	mov	edi, sincos6		;; Load sin/cos pointer

;; Execute the proper middle step

	cmp	ffttype, 2
	JL_X	xpass2_11_levels_real_1
	JG_X	xpass2_11_levels_real_3

xpass2_11_levels_real_2:
	s2cl_eight_reals_with_square_2 esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/256		;; 255 then 256 iterations
baa:	s2cl_four_complex_with_square esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/256		;; Test loop counter
	JNC_X	baa			;; Loop if necessary
	lea	esi, [esi-256*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	baa			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	JMP_X	xpass2_11_real_unfft

xpass2_11_levels_real_1:
	s2cl_eight_reals_fft_2_final esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/256		;; 255 then 256 iterations
bab:	s2cl_four_complex_fft_final esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/256		;; Test loop counter
	JNC_X	bab			;; Loop if necessary
	lea	esi, [esi-256*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	bab			;; Iterate if necessary
	lea	esi, [esi-2*64+incr]	;; Next source block
	JMP_X	xpass2_11_real_done

xpass2_11_levels_real_3:
	s2cl_eight_reals_with_mult_2 esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/256		;; 255 then 256 iterations
bac:	s2cl_four_complex_with_mult esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/256		;; Test loop counter
	JNC_X	bac			;; Loop if necessary
	lea	esi, [esi-256*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	bac			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	JMP_X	xpass2_11_real_unfft

xpass2_11_levels_real_4:
	mov	edi, sincos6		;; Load sin/cos pointer
	s2cl_eight_reals_with_mulf_2 esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/256		;; 255 then 256 iterations
bad:	s2cl_four_complex_with_mulf esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/256		;; Test loop counter
	JNC_X	bad			;; Loop if necessary
	lea	esi, [esi-256*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	bad			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0	1	2	3	4	5	6	7
;;	4096	...
;;	8	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	8	9	16	17	24	25
;;	4096	...
;;	2	...
;;	...
;;	6	...
;;	4102	...
;;	32	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4
;;	do 1 macro processing 32 data values

xpass2_11_real_unfft:
	x4cl_eight_reals_unfft_2 esi, 8*64, 2*64, 4*64

;; Do 1020 four_complex_unfft macros
;;	distance between fft data elements is 4
;;	do 255 macros each processing 32 data values

	mov	edi, sincos7		;; Load sin/cos pointer
	mov	al, 127			;; 127 then 128 iterations
c8b:	x4cl_four_complex_unfft esi, 8*64, 2*64, 4*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c8b			;; Iterate if necessary
	lea	esi, [esi-128*8*64+64]	;; Next source pointer
	mov	al, 128			;; 128 more iterations
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c8b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0	1	8	9	16	17	24	25
;;	4096	...
;;	2	...
;;	...
;;	6	...
;;	4102	...
;;	32	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	32	33	64	65	96	97
;;	4096	...
;;	2	...
;;	...
;;	30	...
;;	4126	...
;;	128	...
;;	...

;; Do 8 eight_reals_unfft_2 macros
;; Do 8 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 16
;;	do 4 macros each processing 32 data values

c6b:	x4cl_eight_reals_unfft_2 esi, 2*64, 8*64, 16*64
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c6b			;; Iterate if necessary

;; Do 1008 four_complex_unfft macros
;;	distance between fft data elements is 16
;;	do 252 macros each processing 32 data values

	mov	edi, sincos8		;; Load sin/cos pointer
	lea	esi, [esi-4*2*64+32*64]	;; Load source pointer
	mov	al, 31			;; 31 then 32 iterations of 4
c7b:	x4cl_four_complex_unfft esi, 2*64, 8*64, 16*64
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c7b			;; Iterate if necessary
	lea	esi, [esi-4*2*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c7b			;; Iterate if necessary
	lea	esi, [esi-32*32*64+64]	;; Next source pointer
	mov	al, 32			;; 32 more iterations
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c7b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0	1	32	33	64	65	96	97
;;	4096	...
;;	2	...
;;	...
;;	30	...
;;	4126	...
;;	128	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	128	129	256	257	384	385
;;	4096	...
;;	2	...
;;	...
;;	126	...
;;	4222	...
;;	512	...
;;	...

;; Do 32 eight_reals_unfft_2 macros
;; Do 32 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 64
;;	do 16 macros each processing 32 data values

c4b:	x4cl_eight_reals_unfft_2 esi, 2*64, 32*64, 64*64
	add	al, 256/16		;; Test inner loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 960 four_complex_unfft macros
;;	distance between fft data elements is 16
;;	do 240 macros each processing 32 data values

	mov	edi, sincos9		;; Load sin/cos pointer
	lea	esi, [esi-16*2*64+128*64];; Load source pointer
	mov	al, 7			;; 7 then 8 iterations of 16
c5b:	x4cl_four_complex_unfft esi, 2*64, 32*64, 64*64
	add	al, 256/16		;; Test inner loop counter
	JNC_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*2*64+128*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*128*64+64]	;; Next source pointer
	mov	al, 8			;; 8 more iterations of 16
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c5b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT levels 2,3
;; On input the 64-byte cache lines hold these data values:
;;	0	1	128	129	256	257	384	385
;;	4096	...
;;	2	...
;;	...
;;	126	...
;;	4222	...
;;	512	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	512	513	1024	1025	1536	1537
;;	4096	...
;;	2	...
;;	...
;;	510	...
;;	4606	...
;;	2048	...
;;	...

;; Do 128 eight_reals_unfft_2 macros
;; Do 128 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 256
;;	do 64 macros each processing 32 data values

c2b:	x4cl_eight_reals_unfft_2 esi, 2*64, 128*64, 256*64
	add	al, 256/64		;; Test inner loop counter
	JNC_X	c2b			;; Iterate if necessary

;; Do 512/768 four_complex_unfft macros
;;	distance between fft data elements is 256
;;	do 128/192 macros each processing 32 data values

	lea	esi, [esi-64*2*64+512*64];; Next source pointer
	mov	edi, sincos10		;; Load sin/cos pointer
	mov	al, 1			;; 1 then 2 iterations of 64
c3b:	x4cl_four_complex_unfft esi, 2*64, 128*64, 256*64
	add	al, 256/64		;; Test inner loop counter
	JNC_X	c3b			;; Iterate if necessary
	lea	esi, [esi-64*2*64+512*64];; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*512*64+64]	;; Next source pointer
	mov	al, 2			;; 2 more iterations of 64
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c3b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT level 1
;; On input the 64-byte cache lines hold these data values:
;;	0	1	512	513	1024	1025	1536	1537
;;	4096	...
;;	2	...
;;	...
;;	510	...
;;	4606	...
;;	2048	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+1K	2048	+1K	4096	+1K	6144	+1K
;;	1	...
;;	...
;;	1023	...

;; Do 512 eight_reals_last_unfft macros
;; Do 512 two_two_complex_unfft macros
;;	distance between fft data elements is 1024
;;	do 256 macros each processing 16 data values

c1b:	s4cl_eight_reals_unfft_1 esi, 2*64, 512*64, 64
	add	al, 256/256		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary

	lea	esi, [esi-256*2*64+incr];; Next source block
xpass2_11_real_done:
	ENDM


; *************** xmm-pass2-11-levels-complex macro ******************
; This macro takes 2 groups of 2048 complex values, premultiplies them and
; performs the final 11 levels of the FFT process, squares the
; results, and does the first 11 levels of the inverse FFT.
; NOTE: Rather than remembering 2048 multipliers we break them up
; into 512 groups of 4 columns.  By remembering these 516 values we can compute
; all 2048 multipliers using a single complex multiply.  These extra
; complex multiplies can probably be done faster than the computer can read the
; extra multipliers from memory (and are more likely stay in the L2 cache)
; esi = Pointer to the FFT data
; ebx/ebp = Differences to point to second and third operands
; edx = Pointer to the group and column pre-multiplier values

xpass2_11_levels_complex MACRO incr
	LOCAL	b0b, b0c, b0d, b1b, b2b, b2c, b3b, b4b, b5b, b6a, b6b, b6c, b6d
	LOCAL	c1b, c2a, c2b, d2a, d2b, e2a, e2b, f2a, f2b, c3b, c4b, c5b

;; Load the TLBs for this data set and the next data set.
;; This data set is spread over 16 pages (64KB), the next data set also
;; takes 16 pages (64KB), and we touch one more page because the data
;; sets do not start on exact on 4KB boudaries.  Also, preload TLBs for
;; premultiplier data.

	push	ecx
	cmp	ecx, 1			;; Test pass2 counter
	je	short b0c		;; Skip if this is last data set
	mov	al, 2			;; Load loop counter
b0b:	mov	edi, [esi]		;; Read from this page (loads the TLB)
	lea	esi, [esi+4096]		;; Next page
	add	al, 256/16		;; Test loop counter
	jnc	short b0b		;; Iterate if necessary
	lea	esi, [esi-16*4096+blkdst];; Next block
	sub	al, 1			;; Test outer loop counter
	jnz	short b0b		;; Iterate if necessary
	mov	edi, [esi-blkdst+16*4096-128];; Read from last page
	lea	esi, [esi-2*blkdst]	;; Next source pointer
	mov	al, 8			;; Load loop counter
	mov	ecx, edx		;; Premultiplier table address
b0d:	mov	edi, [ecx]		;; Load premultiplier TLB
	lea	ecx, [ecx+4096]		;; Next page
	sub	al, 1			;; Test loop counter
	jnz	short b0d		;; Iterate til done
	mov	edi, [edx+263*XMM_PMD]	;; Load last TLB
b0c:

;; Type 4 FFTs skip the forward FFT process

	cmp	ffttype, 4
	JE_X	xpass2_11_levels_complex_4

;; Do FFT level 1,2
;;
;; We swizzle the data so that one set of data is in the high word of
;; an xmm register, the other set is in the low word.  This means
;; a distance of 4096 data values.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+1K	2048	+1K	4096	+1K	6144	+1K
;;	1	...
;;	...
;;	1023
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	512	+4K	1024	+4K	1536	+4K
;;	1	...
;;	...
;;	511	...
;;	2048	...
;;	...

;; Do 1024 four_complex_gpm_fft macros
;;	distance between fft data elements is 512
;;	do 512 macros each processing 16 data values

start_timer 4
	mov	edi, edx		;; The 512 group multipliers
	mov	eax, 128*256		;; 128 iterations of 4
b1b:	s2cl_four_complex_gpm_fft esi, 64, 512*64
	prefetcht1 [esi+7*64]		;; Prefetch a few iterations ahead in
	prefetcht1 [esi+519*64]		;; case they are not in the L2 cache
	add	al, 256/4		;; Test inner loop counter
	JNC_X	b1b			;; Iterate if necessary
	lea	edi, [edi+XMM_PMD]	;; Next group multiplier
	prefetcht1 [edi+4*XMM_PMD]
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-512*64]	;; Restore source pointer
end_timer 4

;; Do FFT levels 3,4
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	512	+4K	1024	+4K	1536	+4K
;;	1	...
;;	...
;;	511	...
;;	2048	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	128	+4K	256	+4K	384	+4K
;;	1	...
;;	...
;;	127	...
;;	512	...
;;	...

;; Do 4 groups of four_complex_fft_cpm macros
;; To make things run faster we precompute the column multipliers times the
;; 4 different sine/cosine multipliers we run into in this section.  This
;; costs some memory but saves us some complex multiplies.

;; Do 1024 four_complex_cpm_fft macros
;;	distance between fft data elements is 128
;;	do 128 macros each processing 64 data values

;; NOTE: We duplicate the looping code, because operating on 8 different
;; cache lines that are 2KB apart incurs significant penalties.

start_timer 5
	lea	ecx, [edx+132*XMM_PMD]	;; Prefetch pointer
	mov	al, 32			;; 32 iterations of 4
b2b:	x4cl_four_complex_cpm01_fft esi, 64, 128*64, 256*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/4		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	lea	edi, [edi-4*XMM_PMD]	;; Restore column premultiplier
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary
	lea	esi, [esi-128*64+512*64];; Next source pointer
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]

	lea	ecx, [edx+132*XMM_PMD]	;; Prefetch pointer
	mov	al, 32			;; 32 iterations of 4
b2c:	x4cl_four_complex_cpm23_fft esi, 64, 128*64, 256*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/4		;; Test inner loop counter
	JNC_X	b2c			;; Iterate if necessary
	lea	edi, [edi-4*XMM_PMD]	;; Restore column premultiplier
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2c			;; Iterate if necessary
	lea	esi, [esi-128*64-512*64];; Restore source pointer
	prefetcht1 [ecx+256]
	prefetcht1 [ecx+384]
end_timer 5

;; Do FFT levels 5
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	128	+4K	256	+4K	384	+4K
;;	1	...
;;	...
;;	127	...
;;	512	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	64	+4K	128	+4K	192	+4K
;;	1	...
;;	...
;;	63	...
;;	256	...
;;	...

;; Do 1024 two_two_complex_fft macros
;;	distance between fft data elements is 64
;;	do 512 macros each processing 16 data values

start_timer 6
	lea	ecx, [esi+blkdst]	;; Prefetch pointer
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 8*256		;; 8 iterations of 64
b3b:	x2cl_two_complex_fft esi, 64, 64*64
	add	eax, 40000000h		;; 4 iterations
	JNC_X	b3b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/16		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	lea	esi, [esi-64*64+128*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	b3b			;; Iterate if necessary
	lea	esi, [esi-8*128*64]	;; Restore source pointer
end_timer 6

;; Do FFT levels 6,7
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	64	+4K	128	+4K	192	+4K
;;	1	...
;;	...
;;	63	...
;;	256	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	16	+4K	32	+4K	48	+4K
;;	1	...
;;	...
;;	15	...
;;	64	...
;;	...

;; Do 1024 four_complex_fft macros
;;	distance between fft data elements is 16
;;	do 256 macros each processing 32 data values

start_timer 7
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 16*256		;; 16 iterations of 16
b4b:	x4cl_four_complex_fft esi, 64, 16*64, 32*64
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/8		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	b4b			;; Iterate if necessary
	lea	esi, [esi-16*64*64]	;; Restore source pointer
end_timer 7

;; Do FFT levels 8,9
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	16	+4K	32	+4K	48	+4K
;;	1	...
;;	...
;;	15	...
;;	64	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	4	+4K	8	+4K	12	+4K
;;	1	...
;;	...
;;	3	...
;;	16	...
;;	...

;; Do 1024 four_complex_fft macros
;;	distance between fft data elements is 4
;;	do 256 macros each processing 32 data values

start_timer 8
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 64*256		;; 64 iterations of 4
b5b:	x4cl_four_complex_fft esi, 64, 4*64, 8*64
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-64*16*64]	;; Restore source pointer
end_timer 8

;; Do FFT levels 10,11 as well as inverse FFT levels 10,11
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	4	+4K	8	+4K	12	+4K
;;	1	...
;;	...
;;	3	...
;;	16	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	2	+4K	4	+4K	6	+4K
;;	1	...
;;	8	...
;;	...

;; Do 1024 four_complex_fft macros
;;	distance between fft data elements is 1
;;	do 256 macros each processing 32 data values

	mov	edi, xsincos_complex	;; Load sin/cos pointer

;; Execute the right middle step

	cmp	ffttype, 2
	JL_X	xpass2_11_levels_complex_1
	JG_X	xpass2_11_levels_complex_3

xpass2_11_levels_complex_2:
start_timer 9
b6a:	x4cl_four_complex_with_square esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6a			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/128		;; Test loop counter
	JNC_X	b6a			;; Loop if necessary
end_timer 9
	lea	esi, [esi-256*4*64]	;; Restore source pointer
	JMP_X	xpass2_11_levels_complex_unfft

xpass2_11_levels_complex_1:
start_timer 9
b6b:	x4cl_four_complex_fft_final esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/128		;; Test loop counter
	JNC_X	b6b			;; Loop if necessary
end_timer 9
	lea	esi, [esi-256*4*64+incr];; Next source block
	JMP_X	xpass2_11_levels_complex_done

xpass2_11_levels_complex_3:
start_timer 9
b6c:	x4cl_four_complex_with_mult esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6c			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/128		;; Test loop counter
	JNC_X	b6c			;; Loop if necessary
end_timer 9
	lea	esi, [esi-256*4*64]	;; Restore source pointer
	JMP_X	xpass2_11_levels_complex_unfft

xpass2_11_levels_complex_4:
start_timer 9
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	sub	eax, eax
b6d:	x4cl_four_complex_with_mulf esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6d			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/128		;; Test loop counter
	JNC_X	b6d			;; Loop if necessary
end_timer 9
	lea	esi, [esi-256*4*64]	;; Restore source pointer

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	2	+4K	4	+4K	6	+4K
;;	1	...
;;	8	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	8	+4K	16	+4K	24	+4K
;;	1	...
;;	...
;;	7	...
;;	32	...
;;	...

;; Do 1024 four_complex_unfft macros
;;	distance between fft data elements is 4
;;	do 256 macros each processing 32 data values

xpass2_11_levels_complex_unfft:
start_timer 10
	lea	ecx, [esi+blkdst]	;; Prefetch pointer
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 128*256		;; 128 iterations of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	lea	esi, [esi-2*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-128*8*64]	;; Restore source pointer
end_timer 10

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	8	+4K	16	+4K	24	+4K
;;	1	...
;;	...
;;	7	...
;;	32	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	32	+4K	64	+4K	96	+4K
;;	1	...
;;	...
;;	31	...
;;	128	...
;;	...

;; Do 1024 four_complex_unfft macros
;;	distance between fft data elements is 16
;;	do 256 macros each processing 32 data values

start_timer 11
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 32*256		;; 32 iterations of 8
c4b:	x4cl_four_complex_unfft esi, 64, 8*64, 16*64
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	c4b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c4b			;; Iterate if necessary
	lea	esi, [esi-8*64+32*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	c4b			;; Iterate if necessary
	lea	esi, [esi-32*32*64]	;; Restore source pointer
end_timer 11

;; Do inverse FFT levels 5
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	32	+4K	64	+4K	96	+4K
;;	1	...
;;	...
;;	31	...
;;	128	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	64	+4K	128	+4K	192	+4K
;;	1	...
;;	...
;;	63	...
;;	256	...
;;	...

;; Do 512 two_two_complex_unfft macros
;;	distance between fft data elements is 64
;;	do 512 macros each processing 16 data values

start_timer 12
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 16*256		;; 16 iterations of 32
c3b:	x2cl_two_complex_unfft esi, 64, 32*64
	add	eax, 40000000h		;; Test inner loop counter
	JNC_X	c3b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/8		;; Test inner loop counter
	JNC_X	c3b			;; Iterate if necessary
	lea	esi, [esi-32*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-16*64*64]	;; Restore source pointer
end_timer 12

;; Do inverse FFT levels 3,4
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	64	+4K	128	+4K	192	+4K
;;	1	...
;;	...
;;	63	...
;;	256	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+4K	256	+4K	512	+4K	768	+4K
;;	1	...
;;	...
;;	255	...
;;	1024	...
;;	...

;; Do 4 groups of 256 four_complex_fft macros (FFT levels 3,4)
;; In this section we also apply the 4 column multipliers (actually three
;; since the first column multiplier is always one).  To make things
;; run faster we precompute the column multipliers times the 4 different
;; sine/cosine multipliers we run into in this section.  This costs some
;; memory but saves us some complex multiplies.

;; Do 1024 four_complex_cpm_unfft macros
;;	distance between fft data elements is 128
;;	do 64 macros each processing 128 data values

;; NOTE: We duplicate the looping code, because operating on 16 different
;; cache lines that are a multiple of 2KB apart incurs significant penalties.

start_timer 13
	mov	al, 16			;; 16 iterations of 4
c2a:	lea	edi, [edx+128*XMM_PMD]	;; Load column multipliers pointer
c2b:	x4cl_four_complex_cpm0_unfft esi, 64, 64*64, 128*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c2a			;; Iterate if necessary
	lea	esi, [esi-64*64+256*64]	;; Next source pointer

	mov	al, 16			;; 16 iterations of 4
d2a:	lea	edi, [edx+128*XMM_PMD]	;; Load column multipliers pointer
d2b:	x4cl_four_complex_cpm1_unfft esi, 64, 64*64, 128*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2a			;; Iterate if necessary
	lea	esi, [esi-64*64+256*64]	;; Restore source pointer

	mov	al, 16			;; 16 iterations of 4
e2a:	lea	edi, [edx+128*XMM_PMD]	;; Load column multipliers pointer
e2b:	x4cl_four_complex_cpm2_unfft esi, 64, 64*64, 128*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	e2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	e2a			;; Iterate if necessary
	lea	esi, [esi-64*64+256*64]	;; Restore source pointer

	mov	al, 16			;; 16 iterations of 4
f2a:	lea	edi, [edx+128*XMM_PMD]	;; Load column multipliers pointer
f2b:	x4cl_four_complex_cpm3_unfft esi, 64, 64*64, 128*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	f2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	f2a			;; Iterate if necessary
	lea	esi, [esi-64*64-3*256*64];; Restore source pointer
end_timer 13

;; Do inverse FFT levels 1,2
;; On input the 64-byte cache lines hold these data values:
;;	0	+4K	256	+4K	512	+4K	768	+4K
;;	1	...
;;	...
;;	255	...
;;	1024	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+1K	2048	+1K	4096	+1K	6144	+1K
;;	1	...
;;	...
;;	1023

;; Do 256 four_complex_gpm_unfft macros
;;	distance between fft data elements is 512
;;	do 256 macros each processing 32 data values

start_timer 14
	lea	ecx, [edx+132*XMM_PMD]	;; Next group pre-multipliers
	mov	edi, edx		;; Load group multiplier pointer
	mov	eax, 64*256		;; 64 iterations of 4
c1b:	s4cl_four_complex_gpm_unfft esi, 64, 256*64, 512*64, 64*XMM_PMD
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/2		;; Test inner loop counter
	JNC_X	c1b			;; Iterate if necessary
	lea	edi, [edi+XMM_PMD]	;; Next set of multipliers
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c1b			;; Iterate if necessary
end_timer 14

	lea	esi, [esi-256*64+incr]	;; Next source block
xpass2_11_levels_complex_done:
	pop	ecx
	lea	edx, [edx+132*XMM_PMD]	;; Next group pre-multipliers
	ENDM






; *************** xmm-pass2-8-levels-real macro ******************
; This macro takes 256 real values, 256 semi-real values and the
; first 256 complex values and performs the final 8 levels of the
; FFT process, squares the results, and does the first 8 levels of
; the inverse FFT.

xpass2_8_levels_real MACRO incr
	LOCAL	b0b, b0d, b1b, b2b, b3b, b4b, b5b, b6b, b7b, b8b, b9b
	LOCAL	baa, bab, bac, bad
	LOCAL	c0b, c1b, c2b, c3b, c4b, c5b, c6b, c7b, c8b

;; We switch to the same format used in one-pass FFTs (that is, the
;; high word of xmm registers being 1 greater than the low word):

;; Load the TLBs for this data set and the next data set.
;; This data set is spread over 2 pages (8KB), the next data set also
;; takes 2 pages (8KB), and we touch one more page because the data
;; sets do not start on exact on 4KB boudaries.

	mov	al, 2			;; Load loop counter
b0b:	mov	edi, [esi]		;; Read from this page (loads the TLB)
	lea	esi, [esi+4096]		;; Next page
	add	al, 256/2		;; Test loop counter
	jnc	short b0b		;; Iterate if necessary
	lea	esi, [esi-2*4096+blkdst];; Next block
	sub	al, 1			;; Test outer loop counter
	jnz	short b0b		;; Iterate if necessary
	mov	edi, [esi-blkdst+2*4096-128];; Read from last page
	lea	esi, [esi-2*blkdst]	;; Next source pointer

;; Type 4 FFTs skip the forward FFT process

	cmp	ffttype, 4
	JE_X	xpass2_8_levels_real_4

;; Do FFT level 1
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+128	256	+128	512	+128	768	+128
;;	1	...
;;	...
;;	127	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	128	129	256	257	384	385
;;	+512	...
;;	2	...
;;	...
;;	126	...
;;	+512	...

;; Do eight_reals_fft_1 on real values 0 - 255
;; Do nothing on semi-real values from 256 - 511
;; Do two_complex_fft on complex values from 512 - 1023
;;	distance between fft data elements is 128

	mov	eax, 64			;; Load loop counter
b1b:	s2cl_eight_reals_fft_1 esi, 2*64, 64
	prefetcht1 [esi+7*128]		;; Prefetch a few iterations ahead
	sub	eax, 1			;; Test loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*2*64]	;; Restore source pointer

;; Do FFT levels 2,3
;; Values 0-127 is real data, 128-255 is semi-real data, 256-1023 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	128	129	256	257	384	385
;;	+512	...
;;	2	...
;;	...
;;	126	...
;;	+512	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	32	33	64	65	96	97
;;	+512	...
;;	2	...
;;	...
;;	30	...
;;	+512	...
;;	128	...
;;	...

;; Do 16 eight_reals_fft_2 macros
;; Do 16 nop_two_two_complex_fft_2 macros
;; Do 32 four_complex_fft macros
;;	distance between fft data elements is 32
;;	do 16 macros each processing 32 data values

	mov	edi, sincos10		;; Load sin/cos pointer
b2b:	x4cl_eight_reals_fft_2 esi, 2*64, 32*64, 64*64
	add	al, 256/16		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary

;; Do 64 four_complex_fft macros
;;	distance between fft data elements is 32
;;	do 16 macros each processing 32 data values

	lea	ecx, [esi+blkdst]	;; Prefetch pointer
	lea	esi, [esi-16*2*64+64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
b3b:	x4cl_four_complex_fft esi, 2*64, 32*64, 64*64
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/16		;; Test inner loop counter
	JNC_X	b3b			;; Iterate if necessary
	lea	esi, [esi-16*2*64-64]	;; Restore source pointer

;; Do FFT levels 4
;; Values 0-31 is real data, 32-63 is semi-real data, 64-1023 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	32	33	64	65	96	97
;;	+512	...
;;	2	...
;;	...
;;	30	...
;;	+512	...
;;	128	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	16	17	32	33	48	49
;;	+512	...
;;	2	...
;;	...
;;	14	...
;;	+512	...
;;	64	...
;;	...

;; Do 16 eight_reals_fft_1 macros
;;	distance between fft data elements is 16
;;	do 8 macros each processing 16 data values

	mov	edi, sincos9		;; Load sin/cos pointer
b4b:	x2cl_eight_reals_fft_1 esi, 2*64, 16*64
	add	al, 256/8		;; Test inner loop counter
	JNC_X	b4b			;; Iterate if necessary

;; Do 112 two_complex_fft macros
;;	distance between fft data elements is 64
;;	do 56 macros each processing 16 data values

	lea	esi, [esi-8*2*64+32*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 3			;; 3 then 4 iterations of 4
b5b:	x2cl_two_complex_fft esi, 2*64, 16*64
	add	al, 256/8		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*2*64+32*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*32*64+64]	;; Next source pointer
	mov	al, 4			;; 4 more iterations of 4
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	b5b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 5,6
;; Values 0-15 is real data, 16-31 is semi-real data, 32-1023 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	16	17	32	33	48	49
;;	+512	...
;;	2	...
;;	...
;;	14	...
;;	+512	...
;;	64	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	4	5	8	9	12	13
;;	+512	...
;;	2	...
;;	+512	...
;;	16	...
;;	...

;; Do 2 eight_reals_fft_2 macros
;; Do 2 nop_two_two_complex_fft_2 macros
;; Do 4 four_complex_fft macros
;;	distance between fft data elements is 4
;;	do 2 macros each processing 32 data values

	mov	edi, sincos7		;; Load sin/cos pointer
b8b:	x4cl_eight_reals_fft_2 esi, 2*64, 4*64, 8*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b8b			;; Iterate if necessary

;; Do 120 four_complex_fft macros
;;	distance between fft data elements is 4
;;	do 30 macros each processing 32 data values

	lea	esi, [esi-2*2*64+16*64]	;; Load source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 7			;; 7 then 8 iterations of 2
b9b:	x4cl_four_complex_fft esi, 2*64, 4*64, 8*64
	add	al, 256/2		;; Test loop counter
	JNC_X	b9b			;; Loop if necessary
	lea	esi, [esi-2*2*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test middle loop counter
	JNZ_X	b9b			;; Iterate if necessary
	lea	esi, [esi-8*16*64+64]	;; Next source pointer
	mov	al, 8			;; 8 more iterations of 2
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	b9b			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do FFT levels 7,8
;; Values 0-3 is real data, 4-7 is semi-real data, 8-1023 is
;; complex data.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	1	4	5	8	9	12	13
;;	+512	...
;;	2	...
;;	+512	...
;;	16	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	2	3	4	5	6	7
;;	+512	...
;;	8	...
;;	...

;; Do 1/2 eight_reals_fft_2 macros
;; Do 1/2 nop_two_two_complex_fft_2 macros
;; Do 1 four_complex_fft macros
;;	distance between fft data elements is 1

;; Do 126 more four_complex_fft macros
;;	distance between fft data elements is 1
;;	do 63 macros each processing 16 data values

	mov	edi, sincos6		;; Load sin/cos pointer

;; Execute the proper middle step

	cmp	ffttype, 2
	JL_X	xpass2_8_levels_real_1
	JG_X	xpass2_8_levels_real_3

xpass2_8_levels_real_2:
	s2cl_eight_reals_with_square_2 esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/32		;; 31 then 32 iterations
baa:	s2cl_four_complex_with_square esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/32		;; Test loop counter
	JNC_X	baa			;; Loop if necessary
	lea	esi, [esi-32*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	baa			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	JMP_X	xpass2_8_real_unfft

xpass2_8_levels_real_1:
	s2cl_eight_reals_fft_2_final esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/32		;; 31 then 32 iterations
bab:	s2cl_four_complex_fft_final esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/32		;; Test loop counter
	JNC_X	bab			;; Loop if necessary
	lea	esi, [esi-32*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	bab			;; Iterate if necessary
	lea	esi, [esi-2*64+incr]	;; Next source block
	JMP_X	xpass2_8_real_done

xpass2_8_levels_real_3:
	s2cl_eight_reals_with_mult_2 esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/32		;; 31 then 32 iterations
bac:	s2cl_four_complex_with_mult esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/32		;; Test loop counter
	JNC_X	bac			;; Loop if necessary
	lea	esi, [esi-32*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	bac			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	JMP_X	xpass2_8_real_unfft

xpass2_8_levels_real_4:
	mov	edi, sincos6		;; Load sin/cos pointer
	s2cl_eight_reals_with_mulf_2 esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	mov	al, 1*256/32		;; 31 then 32 iterations
bad:	s2cl_four_complex_with_mulf esi, 4*64, 2*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	add	al, 256/32		;; Test loop counter
	JNC_X	bad			;; Loop if necessary
	lea	esi, [esi-32*4*64+64]	;; Next source pointer
	add	eax, 80000000h		;; Test outer loop counter
	JNC_X	bad			;; Iterate if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0	1	2	3	4	5	6	7
;;	+512	...
;;	8	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	8	9	16	17	24	25
;;	+512	...
;;	2	...
;;	...
;;	6	...
;;	+512	...
;;	32	...
;;	...

;; Do 2 eight_reals_unfft_2 macros
;; Do 2 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 4
;;	do 1 macro processing 32 data values

xpass2_8_real_unfft:
	x4cl_eight_reals_unfft_2 esi, 8*64, 2*64, 4*64

;; Do 124 four_complex_unfft macros
;;	distance between fft data elements is 4
;;	do 31 macros each processing 32 data values

	mov	edi, sincos7		;; Load sin/cos pointer
	mov	al, 15			;; 15 then 16 iterations
c8b:	x4cl_four_complex_unfft esi, 8*64, 2*64, 4*64
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test loop counter
	JNZ_X	c8b			;; Iterate if necessary
	lea	esi, [esi-16*8*64+64]	;; Next source pointer
	mov	al, 16			;; 128 more iterations
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c8b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT levels 4
;; On input the 64-byte cache lines hold these data values:
;;	0	1	8	9	16	17	24	25
;;	+512	...
;;	2	...
;;	...
;;	6	...
;;	+512	...
;;	32	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	16	17	32	33	48	49
;;	+512	...
;;	2	...
;;	...
;;	14	...
;;	+512	...
;;	64	...
;;	...

;; Do 8 eight_reals_unfft_1 macros
;;	distance between fft data elements is 16
;;	do 4 macros each processing 16 data values

c4b:	x2cl_eight_reals_unfft_1 esi, 2*64, 8*64
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c4b			;; Iterate if necessary

;; Do 960 two_complex_unfft macros
;;	distance between fft data elements is 16
;;	do 240 macros each processing 32 data values

	mov	edi, sincos9		;; Load sin/cos pointer
	lea	esi, [esi-4*2*64+16*64]	;; Load source pointer
	mov	al, 7			;; 7 then 8 iterations of 4
c5b:	x2cl_two_complex_unfft esi, 2*64, 8*64
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c5b			;; Iterate if necessary
	lea	esi, [esi-4*2*64+16*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-8*16*64+64]	;; Next source pointer
	mov	al, 8			;; 8 more iterations of 16
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c5b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT levels 2,3
;; On input the 64-byte cache lines hold these data values:
;;	0	1	16	17	32	33	48	49
;;	+512	...
;;	2	...
;;	...
;;	14	...
;;	+512	...
;;	64	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	1	64	65	128	129	192	193
;;	+512	...
;;	2	...
;;	...
;;	62	...
;;	+512	...
;;	256	...
;;	...

;; Do 128 eight_reals_unfft_2 macros
;; Do 128 nop_two_two_complex_unfft_2 macros
;;	distance between fft data elements is 256
;;	do 8 macros each processing 32 data values

c2b:	x4cl_eight_reals_unfft_2 esi, 2*64, 16*64, 32*64
	add	al, 256/8		;; Test inner loop counter
	JNC_X	c2b			;; Iterate if necessary

;; Do 96 four_complex_unfft macros
;;	distance between fft data elements is 32
;;	do 24 macros each processing 32 data values

	lea	esi, [esi-8*2*64+64*64]	;; Next source pointer
	mov	edi, sincos10		;; Load sin/cos pointer
	mov	al, 1			;; 1 then 2 iterations of 64
c3b:	x4cl_four_complex_unfft esi, 2*64, 16*64, 32*64
	add	al, 256/8		;; Test inner loop counter
	JNC_X	c3b			;; Iterate if necessary
	lea	esi, [esi-8*2*64+64*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c3b			;; Iterate if necessary
	lea	esi, [esi-2*64*64+64]	;; Next source pointer
	mov	al, 2			;; 2 more iterations of 64
	add	eax, 80000000h		;; Test loop counter
	JNC_X	c3b			;; Loop if necessary
	lea	esi, [esi-2*64]		;; Restore source pointer
	sub	eax, eax

;; Do inverse FFT level 1
;; On input the 64-byte cache lines hold these data values:
;;	0	1	64	65	128	129	192	193
;;	+512	...
;;	2	...
;;	...
;;	62	...
;;	+512	...
;;	256	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+128	256	+128	512	+128	768	+128
;;	1	...
;;	...
;;	127	...

;; Do 64 eight_reals_last_unfft macros
;; Do 64 two_two_complex_unfft macros
;;	distance between fft data elements is 128
;;	do 32 macros each processing 16 data values

c1b:	s4cl_eight_reals_unfft_1 esi, 2*64, 64*64, 64
	add	al, 256/32		;; Test loop counter
	JNC_X	c1b			;; Iterate if necessary

	lea	esi, [esi-32*2*64+incr]	;; Next source block
xpass2_8_real_done:
	ENDM


; *************** xmm-pass2-8-levels-complex macro ******************
; This macro takes 2 groups of 256 complex values, premultiplies them and
; performs the final 8 levels of the FFT process, squares the
; results, and does the first 8 levels of the inverse FFT.
; NOTE: Rather than remembering 256 multipliers we break them up
; into 64 groups of 4 columns.  By remembering these 68 values we can compute
; all 256 multipliers using a single complex multiply.  These extra
; complex multiplies can probably be done faster than the computer can read the
; extra multipliers from memory (and are more likely stay in the L2 cache)
; esi = Pointer to the FFT data
; ebx/ebp = Differences to point to second and third operands
; edx = Pointer to the group and column pre-multiplier values

xpass2_8_levels_complex MACRO incr
	LOCAL	b0b, b0c, b1b, b2b, b2c, b5b, b6a, b6b, b6c, b6d
	LOCAL	c1b, c2a, c2b, d2a, d2b, e2a, e2b, f2a, f2b, c5b

;; Load the TLBs for this data set and the next data set.
;; This data set is spread over 16 pages (64KB), the next data set also
;; takes 16 pages (64KB), and we touch one more page because the data
;; sets do not start on exact on 4KB boudaries.  Also, preload TLBs for
;; premultiplier data.

	push	ecx
	cmp	ecx, 1			;; Test pass2 counter
	je	short b0c		;; Skip if this is last data set
	mov	al, 2			;; Load loop counter
b0b:	mov	edi, [esi]		;; Read from this page (loads the TLB)
	lea	esi, [esi+4096]		;; Next page
	add	al, 256/2		;; Test loop counter
	jnc	short b0b		;; Iterate if necessary
	lea	esi, [esi-2*4096+blkdst];; Next block
	sub	al, 1			;; Test outer loop counter
	jnz	short b0b		;; Iterate if necessary
	mov	edi, [esi-blkdst+2*4096-128];; Read from last page
	lea	esi, [esi-2*blkdst]	;; Next source pointer
	mov	ecx, edx		;; Premultiplier table address
	mov	edi, [ecx]		;; Load premultiplier TLB
	mov	edi, [edx+31*XMM_PMD]	;; Load last TLB
b0c:

;; Type 4 FFTs skip the forward FFT process

	cmp	ffttype, 4
	JE_X	xpass2_8_levels_complex_4

;; Do FFT level 1,2
;;
;; We swizzle the data so that one set of data is in the high word of
;; an xmm register, the other set is in the low word.  This means
;; a distance of 4096 data values.
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+128	256	+128	512	+128	768	+128
;;	1	...
;;	...
;;	127
;; On output the 64-byte cache lines hold these data values:
;;	0	+512	64	+512	128	+512	192	+512
;;	1	...
;;	...
;;	63	...
;;	256	...
;;	...

;; Do 128 four_complex_gpm_fft macros
;;	distance between fft data elements is 64
;;	do 64 macros each processing 16 data values

start_timer 4
	mov	edi, edx		;; The 64 group multipliers
	mov	eax, 16			;; 16 iterations of 4
b1b:	s2cl_four_complex_gpm_fft esi, 64, 64*64
	prefetcht1 [esi+7*64]		;; Prefetch a few iterations ahead in
	prefetcht1 [esi+71*64]		;; case they are not in the L2 cache
	add	al, 256/4		;; Test inner loop counter
	JNC_X	b1b			;; Iterate if necessary
	lea	edi, [edi+XMM_PMD]	;; Next group multiplier
	prefetcht1 [edi+4*XMM_PMD]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b1b			;; Iterate if necessary
	lea	esi, [esi-64*64]	;; Restore source pointer
end_timer 4

;; Do FFT levels 3,4
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+512	64	+512	128	+512	192	+512
;;	1	...
;;	...
;;	63	...
;;	256	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+512	16	+512	32	+512	48	+512
;;	1	...
;;	...
;;	15	...
;;	64	...
;;	...

;; Do 4 groups of four_complex_fft_cpm macros
;; To make things run faster we precompute the column multipliers times the
;; 4 different sine/cosine multipliers we run into in this section.  This
;; costs some memory but saves us some complex multiplies.

;; Do 128 four_complex_cpm_fft macros
;;	distance between fft data elements is 16
;;	do 16 macros each processing 64 data values

;; NOTE: We duplicate the looping code, because operating on 8 different
;; cache lines that are 2KB apart incurs significant penalties.

start_timer 5
	lea	ecx, [edx+20*XMM_PMD]	;; Prefetch pointer
	mov	al, 4			;; 4 iterations of 4
b2b:	x4cl_four_complex_cpm01_fft esi, 64, 16*64, 32*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/4		;; Test inner loop counter
	JNC_X	b2b			;; Iterate if necessary
	lea	edi, [edi-4*XMM_PMD]	;; Restore column premultiplier
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2b			;; Iterate if necessary
	lea	esi, [esi-16*64+64*64]	;; Next source pointer
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]

	lea	ecx, [edx+20*XMM_PMD]	;; Prefetch pointer
	mov	al, 4			;; 4 iterations of 4
b2c:	x4cl_four_complex_cpm23_fft esi, 64, 16*64, 32*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/4		;; Test inner loop counter
	JNC_X	b2c			;; Iterate if necessary
	lea	edi, [edi-4*XMM_PMD]	;; Restore column premultiplier
	sub	al, 1			;; Test outer loop counter
	JNZ_X	b2c			;; Iterate if necessary
	lea	esi, [esi-16*64-64*64]	;; Restore source pointer
	prefetcht1 [ecx+256]
	prefetcht1 [ecx+384]
end_timer 5

;; Do FFT levels 5,6
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+512	16	+512	32	+512	48	+512
;;	1	...
;;	...
;;	15	...
;;	64	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+512	4	+512	8	+512	12	+512
;;	1	...
;;	...
;;	3	...
;;	16	...
;;	...

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 4
;;	do 32 macros each processing 32 data values

start_timer 8
	lea	ecx, [esi+blkdst]	;; Prefetch pointer
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 8*256		;; 8 iterations of 4
b5b:	x4cl_four_complex_fft esi, 64, 4*64, 8*64
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/2		;; Test inner loop counter
	JNC_X	b5b			;; Iterate if necessary
	lea	esi, [esi-4*64+16*64]	;; Next source pointer
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	b5b			;; Iterate if necessary
	lea	esi, [esi-8*16*64]	;; Restore source pointer
end_timer 8

;; Do FFT levels 7,8 as well as inverse FFT levels 7,8
;;
;; On input the 64-byte cache lines hold these data values:
;;	0	+512	4	+512	8	+512	12	+512
;;	1	...
;;	...
;;	3	...
;;	16	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+512	2	+512	4	+512	6	+512
;;	1	...
;;	8	...
;;	...

;; Do 128 four_complex_fft macros
;;	distance between fft data elements is 1
;;	do 32 macros each processing 32 data values

	mov	edi, xsincos_complex	;; Load sin/cos pointer

;; Execute the right middle step

	cmp	ffttype, 2
	JL_X	xpass2_8_levels_complex_1
	JG_X	xpass2_8_levels_complex_3

xpass2_8_levels_complex_2:
start_timer 9
b6a:	x4cl_four_complex_with_square esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6a			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/16		;; Test loop counter
	JNC_X	b6a			;; Loop if necessary
end_timer 9
	lea	esi, [esi-32*4*64]	;; Restore source pointer
	JMP_X	xpass2_8_levels_complex_unfft

xpass2_8_levels_complex_1:
start_timer 9
b6b:	x4cl_four_complex_fft_final esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/16		;; Test loop counter
	JNC_X	b6b			;; Loop if necessary
end_timer 9
	lea	esi, [esi-32*4*64+incr];; Next source block
	JMP_X	xpass2_8_levels_complex_done

xpass2_8_levels_complex_3:
start_timer 9
b6c:	x4cl_four_complex_with_mult esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6c			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/16		;; Test loop counter
	JNC_X	b6c			;; Loop if necessary
end_timer 9
	lea	esi, [esi-32*4*64]	;; Restore source pointer
	JMP_X	xpass2_8_levels_complex_unfft

xpass2_8_levels_complex_4:
start_timer 9
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	sub	eax, eax
;; bug ecx set improperly for prefetching....
b6d:	x4cl_four_complex_with_mulf esi, 4*64, 64, 2*64
	lea	edi, [edi+2*XMM_SCD]	;; Next sine/cosine pointer
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	b6d			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/16		;; Test loop counter
	JNC_X	b6d			;; Loop if necessary
end_timer 9
	lea	esi, [esi-32*4*64]	;; Restore source pointer

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0	+512	2	+512	4	+512	6	+512
;;	1	...
;;	8	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+512	8	+512	16	+512	24	+512
;;	1	...
;;	...
;;	7	...
;;	32	...
;;	...

;; Do 128 four_complex_unfft macros
;;	distance between fft data elements is 4
;;	do 32 macros each processing 32 data values

xpass2_8_levels_complex_unfft:
start_timer 10
	lea	ecx, [esi+blkdst]	;; Prefetch pointer
	mov	edi, xsincos_complex	;; Load sin/cos pointer
	mov	eax, 16*256		;; 16 iterations of 2
c5b:	x4cl_four_complex_unfft esi, 64, 2*64, 4*64
	add	al, 256/2		;; Test inner loop counter
	JNC_X	c5b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	lea	esi, [esi-2*64+8*64]	;; Next source pointer
	lea	edi, [edi+XMM_SCD]	;; Next sine/cosine pointer
	sub	eax, 256		;; Test loop counter
	JNZ_X	c5b			;; Iterate if necessary
	lea	esi, [esi-16*8*64]	;; Restore source pointer
end_timer 10

;; Do inverse FFT levels 3,4
;; On input the 64-byte cache lines hold these data values:
;;	0	+512	8	+512	16	+512	24	+512
;;	1	...
;;	...
;;	7	...
;;	32	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+512	32	+512	64	+512	96	+512
;;	1	...
;;	...
;;	31	...
;;	128	...
;;	...

;; Do 4 groups of 32 four_complex_fft macros (FFT levels 3,4)
;; In this section we also apply the 4 column multipliers (actually three
;; since the first column multiplier is always one).  To make things
;; run faster we precompute the column multipliers times the 4 different
;; sine/cosine multipliers we run into in this section.  This costs some
;; memory but saves us some complex multiplies.

;; Do 128 four_complex_cpm_unfft macros
;;	distance between fft data elements is 16
;;	do 8 macros each processing 128 data values

;; NOTE: We duplicate the looping code, because operating on 16 different
;; cache lines that are a multiple of 2KB apart incurs significant penalties.

start_timer 13
	mov	al, 2			;; 2 iterations of 4
c2a:	lea	edi, [edx+16*XMM_PMD]	;; Load column multipliers pointer
c2b:	x4cl_four_complex_cpm0_unfft esi, 64, 8*64, 16*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	c2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	c2a			;; Iterate if necessary
	lea	esi, [esi-8*64+32*64]	;; Next source pointer

	mov	al, 2			;; 2 iterations of 4
d2a:	lea	edi, [edx+16*XMM_PMD]	;; Load column multipliers pointer
d2b:	x4cl_four_complex_cpm1_unfft esi, 64, 8*64, 16*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	d2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	d2a			;; Iterate if necessary
	lea	esi, [esi-8*64+32*64]	;; Restore source pointer

	mov	al, 2			;; 2 iterations of 4
e2a:	lea	edi, [edx+16*XMM_PMD]	;; Load column multipliers pointer
e2b:	x4cl_four_complex_cpm2_unfft esi, 64, 8*64, 16*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	e2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	e2a			;; Iterate if necessary
	lea	esi, [esi-8*64+32*64]	;; Restore source pointer

	mov	al, 2			;; 2 iterations of 4
f2a:	lea	edi, [edx+16*XMM_PMD]	;; Load column multipliers pointer
f2b:	x4cl_four_complex_cpm3_unfft esi, 64, 8*64, 16*64
	lea	edi, [edi+XMM_PMD]	;; Next column premultiplier
	add	al, 256/4		;; Test inner loop counter
	JNC_X	f2b			;; Iterate if necessary
	prefetcht1 [ecx]
	prefetcht1 [ecx+128]
	lea	ecx, [ecx+256]
	sub	al, 1			;; Test outer loop counter
	JNZ_X	f2a			;; Iterate if necessary
	lea	esi, [esi-8*64-3*32*64]	;; Restore source pointer
end_timer 13

;; Do inverse FFT levels 1,2
;; On input the 64-byte cache lines hold these data values:
;;	0	+512	32	+512	64	+512	96	+512
;;	1	...
;;	...
;;	31	...
;;	128	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0	+128	256	+128	512	+128	768	+128
;;	1	...
;;	...
;;	255

;; Do 32 four_complex_gpm_unfft macros
;;	distance between fft data elements is 64
;;	do 32 macros each processing 32 data values

start_timer 14
	lea	ecx, [edx+20*XMM_PMD]	;; Next group pre-multipliers
	mov	edi, edx		;; Load group multiplier pointer
	mov	eax, 8*256		;; 8 iterations of 4
c1b:	s4cl_four_complex_gpm_unfft esi, 64, 32*64, 64*64, 8*XMM_PMD
	add	eax, 80000000h		;; Test inner loop counter
	JNC_X	c1b			;; Iterate if necessary
	prefetcht1 [ecx]
	lea	ecx, [ecx+128]
	add	al, 256/2		;; Test inner loop counter
	JNC_X	c1b			;; Iterate if necessary
	lea	edi, [edi+XMM_PMD]	;; Next set of multipliers
	sub	eax, 256		;; Test outer loop counter
	JNZ_X	c1b			;; Iterate if necessary
end_timer 14

	lea	esi, [esi-32*64+incr]	;; Next source block
xpass2_8_levels_complex_done:
	pop	ecx
	lea	edx, [edx+20*XMM_PMD]	;; Next group pre-multipliers
	ENDM
